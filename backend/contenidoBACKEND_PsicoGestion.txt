

/package.json:
--------------------------------------------------------------------------------
{
  "name": "psico-gestion-backend",
  "version": "1.0.0",
  "description": "Backend API para sistema de gestión psicológica",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"No tests yet\""
  },
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "exceljs": "^4.4.0",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "googleapis": "^128.0.0",
    "jsonwebtoken": "^9.0.3",
    "mysql2": "^3.15.3",
    "json2csv": "^5.0.0",
    "nodemailer": "^6.9.7",
    "pdfkit": "^0.14.0",
    "sequelize": "^6.37.7",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  }
}

/server.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerDocument = require('./src/doc/swagger.json');
const cors = require('cors');

const sequelize = require('./src/config/db');

// Importar modelos
require('./src/models/userModel');
require('./src/models/pacienteModel');
require('./src/models/citaModel');
// Importar otros modelos según necesites

const authRoutes = require('./src/routes/authRoutes');
const citaRoutes = require('./src/routes/citaRoutes');
const roleRoutes = require('./src/routes/roleRoutes');
const fundacionRoutes = require('./src/routes/fundacionRoutes');
const asignacionRoutes = require('./src/routes/asignacionRoutes');
const sesionRoutes = require('./src/routes/sesionRoutes');
const notificacionRoutes = require('./src/routes/notificacionRoutes');
const altaRoutes = require('./src/routes/altaRoutes');
const reporteRoutes = require('./src/routes/reporteRoutes');
const observacionRoutes = require('./src/routes/observacionRoutes');
const disponibilidadRoutes = require('./src/routes/disponibilidadRoutes');
const expedienteRoutes = require('./src/routes/expedienteRoutes');
const dashboardRoutes = require('./src/routes/dashboardRoutes');
const agendaRoutes = require('./src/routes/agendaRoutes');
const estadisticaRoutes = require('./src/routes/estadisticaRoutes');
const pacienteRoutes = require('./src/routes/pacienteRoutes');
const app = express();
const PORT = process.env.PORT || 3000;



app.use(cors({
  origin: 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.get('/', (req, res) => {
  res.send('Server is running! Check /api-docs for documentation.');
});

app.use('/api/auth', authRoutes);
app.use('/api/citas', citaRoutes);
app.use('/api/fundaciones', fundacionRoutes);
app.use('/api/asignaciones', asignacionRoutes);
app.use('/api/sesiones', sesionRoutes);
app.use('/api/notificaciones', notificacionRoutes);
app.use('/api/altas', altaRoutes);
app.use('/api/reportes', reporteRoutes);
app.use('/api/observaciones', observacionRoutes);
app.use('/api/disponibilidad', disponibilidadRoutes);
app.use('/api/expedientes', expedienteRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/agenda', agendaRoutes);
app.use('/api/estadisticas', estadisticaRoutes);
const userRoutes = require('./src/routes/userRoutes');
app.use('/api/users', userRoutes);
app.use('/api/roles', roleRoutes);
app.use('/api/pacientes', pacienteRoutes);
// Sincronizar modelos
sequelize.sync({ force: false, alter: false })
    .then(() => {
        console.log("✅ Tablas sincronizadas (base de datos lista)");
        app.listen(PORT, () => {
          console.log(`Backend running on http://localhost:${PORT}`);
          console.log(`Swagger docs: http://localhost:${PORT}/api-docs`);
          console.log(`CORS permitido para: http://localhost:3001`);
          console.log(`Endpoints disponibles:`);
          console.log(`  GET  /api/citas/citas-por-fecha?fecha=YYYY-MM-DD&becario_id=1`);
          console.log(`  GET  /api/citas/reporte-mensual?mes=1&anio=2024`);
          console.log(`  POST /api/citas/alta-paciente`);
          console.log(`  PUT  /api/citas/cita/:id`);
        });
    })
    .catch((error) => {
        console.error("❌ Error al sincronizar la base de datos:", error.message);
    });

/src\config\db.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASSWORD,
    {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'mysql',
        logging: false,
        
        dialectOptions: {
            ssl: {
                require: true,
                rejectUnauthorized: false
            }
        },

        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000
        }
    }
);

async function testConnection() {
    try {
        await sequelize.authenticate();
        console.log('✅ Conexión a base de datos establecida exitosamente.');
    } catch (error) {
        console.error('❌ No se pudo conectar a la base de datos:', error);
    }
}

testConnection();

module.exports = sequelize;

/src\controllers\agendaController.js:
--------------------------------------------------------------------------------
// backend/src/controllers/agendaController.js - Versión simplificada sin verificación de roles
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes, Op } = require('sequelize');
const sequelize = require('../config/db');

class AgendaController {

    static async obtenerAgendaGlobal(req, res) {
        try {
            const { 
                fecha_inicio, 
                fecha_fin, 
                psicologo_id, 
                becario_id, 
                paciente_id,
                estado,
                tipo_consulta,
                limit = 50,
                offset = 0
            } = req.query;
            
            // Construir condiciones de filtro
            const whereClause = {};
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [Op.between]: [fecha_inicio, fecha_fin]
                };
            } else if (fecha_inicio) {
                whereClause.fecha = { [Op.gte]: fecha_inicio };
            } else if (fecha_fin) {
                whereClause.fecha = { [Op.lte]: fecha_fin };
            } else {
                // Por defecto, mostrar solo citas futuras y de hoy
                whereClause.fecha = { [Op.gte]: new Date().toISOString().split('T')[0] };
            }
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (becario_id) whereClause.becario_id = becario_id;
            if (paciente_id) whereClause.paciente_id = paciente_id;
            if (estado) whereClause.estado = estado;
            if (tipo_consulta) whereClause.tipo_consulta = tipo_consulta;
            
            console.log('Where clause:', whereClause);
            
            const citas = await Cita.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['id', 'nombre', 'apellido', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [
                    ['fecha', 'ASC'],
                    ['hora', 'ASC']
                ],
                limit: parseInt(limit),
                offset: parseInt(offset)
            });
            
            console.log('Citas encontradas:', citas.length);
            
            // Incluir estadísticas - consulta simplificada
            let estadisticas = null;
            try {
                // Construir condiciones WHERE para SQL
                let whereSQL = '1=1';
                const replacements = [];
                
                if (fecha_inicio && fecha_fin) {
                    whereSQL += ' AND fecha BETWEEN ? AND ?';
                    replacements.push(fecha_inicio, fecha_fin);
                } else if (fecha_inicio) {
                    whereSQL += ' AND fecha >= ?';
                    replacements.push(fecha_inicio);
                } else if (fecha_fin) {
                    whereSQL += ' AND fecha <= ?';
                    replacements.push(fecha_fin);
                }
                
                if (psicologo_id) {
                    whereSQL += ' AND psicologo_id = ?';
                    replacements.push(psicologo_id);
                }
                
                if (estado) {
                    whereSQL += ' AND estado = ?';
                    replacements.push(estado);
                }
                
                const query = `
                    SELECT 
                        COUNT(*) as total_citas,
                        SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                        SUM(CASE WHEN estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                        SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                        SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                        COUNT(DISTINCT psicologo_id) as psicologos_involucrados,
                        COUNT(DISTINCT becario_id) as becarios_involucrados,
                        COUNT(DISTINCT paciente_id) as pacientes_atendidos
                    FROM citas
                    WHERE ${whereSQL}
                `;
                
                const [stats] = await sequelize.query(query, {
                    replacements,
                    type: QueryTypes.SELECT
                });
                
                estadisticas = stats;
                console.log('Estadísticas:', estadisticas);
                
            } catch (statsError) {
                console.error('Error al obtener estadísticas:', statsError);
                // Continuar sin estadísticas
                estadisticas = {
                    total_citas: citas.length,
                    programadas: citas.filter(c => c.estado === 'programada').length,
                    confirmadas: citas.filter(c => c.estado === 'confirmada').length,
                    completadas: citas.filter(c => c.estado === 'completada').length,
                    canceladas: citas.filter(c => c.estado === 'cancelada').length,
                    psicologos_involucrados: new Set(citas.map(c => c.psicologo_id)).size,
                    becarios_involucrados: new Set(citas.map(c => c.becario_id)).size - 1, // Restar null
                    pacientes_atendidos: new Set(citas.map(c => c.paciente_id)).size
                };
            }
            
            res.json({
                success: true,
                data: {
                    citas,
                    estadisticas,
                    filtros: {
                        fecha_inicio,
                        fecha_fin,
                        psicologo_id,
                        becario_id,
                        paciente_id,
                        estado,
                        tipo_consulta
                    }
                },
                count: citas.length
            });
            
        } catch (error) {
            console.error('Error detallado en obtenerAgendaGlobal:', error);
            console.error('Stack trace:', error.stack);
            res.status(500).json({
                success: false,
                message: 'Error al obtener agenda global',
                error: error.message,
                stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
            });
        }
    }
    
    static async obtenerAgendaDiaria(req, res) {
        try {
            const { fecha } = req.query;
            
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            
            const query = `
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    c.duracion as duracion_minutos,
                    c.notas,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario,
                    u_psi.especialidad as psicologo_especialidad
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.fecha = ?
                ORDER BY c.hora
            `;
            
            const replacements = [fechaConsulta];
            
            const citas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Obtener disponibilidad de profesionales para este día
            const diaSemana = this.obtenerDiaSemana(fechaConsulta);
            const [disponibilidad] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    GROUP_CONCAT(
                        CONCAT(
                            TIME_FORMAT(d.hora_inicio, '%H:%i'), 
                            ' - ', 
                            TIME_FORMAT(d.hora_fin, '%H:%i')
                        ) SEPARATOR ', '
                    ) as horarios_disponibles,
                    COUNT(DISTINCT c.id) as citas_programadas
                FROM users u
                LEFT JOIN disponibilidades d ON u.id = d.usuario_id 
                    AND d.dia_semana = ?
                    AND d.activo = TRUE
                LEFT JOIN citas c ON u.id = c.psicologo_id 
                    AND c.fecha = ?
                    AND c.estado IN ('programada', 'confirmada')
                WHERE u.rol IN ('psicologo', 'becario')
                AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido, u.rol
                ORDER BY u.rol, u.apellido, u.nombre
            `, {
                replacements: [diaSemana, fechaConsulta],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    fecha: fechaConsulta,
                    citas,
                    disponibilidad: disponibilidad || [],
                    total_citas: citas.length
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerAgendaDiaria:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener agenda diaria'
            });
        }
    }
    
    static async obtenerCalendarioMensual(req, res) {
        try {
            const { mes, anio } = req.query;
            
            const mesActual = mes || new Date().getMonth() + 1;
            const anioActual = anio || new Date().getFullYear();
            
            // Obtener citas del mes
            const query = `
                SELECT 
                    c.fecha,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                    SUM(CASE WHEN c.estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                    GROUP_CONCAT(
                        CONCAT(
                            TIME_FORMAT(c.hora, '%H:%i'), ' ', 
                            SUBSTRING(p.nombre, 1, 1), '. ', p.apellido
                        ) 
                        ORDER BY c.hora 
                        SEPARATOR '; '
                    ) as detalle_citas
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE MONTH(c.fecha) = ? AND YEAR(c.fecha) = ?
                GROUP BY c.fecha ORDER BY c.fecha
            `;
            
            const replacements = [mesActual, anioActual];
            
            const citasPorDia = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Crear calendario
            const diasMes = new Date(anioActual, mesActual, 0).getDate();
            const calendario = [];
            
            for (let dia = 1; dia <= diasMes; dia++) {
                const fecha = `${anioActual}-${mesActual.toString().padStart(2, '0')}-${dia.toString().padStart(2, '0')}`;
                const datosDia = citasPorDia.find(c => c.fecha === fecha);
                
                calendario.push({
                    fecha,
                    dia,
                    dia_semana: this.obtenerDiaSemana(fecha),
                    total_citas: datosDia ? datosDia.total_citas : 0,
                    programadas: datosDia ? datosDia.programadas : 0,
                    confirmadas: datosDia ? datosDia.confirmadas : 0,
                    completadas: datosDia ? datosDia.completadas : 0,
                    canceladas: datosDia ? datosDia.canceladas : 0,
                    detalle_citas: datosDia ? datosDia.detalle_citas : null
                });
            }
            
            // Estadísticas del mes
            const [estadisticasMes] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_citas_mes,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(AVG(duracion), 1) as duracion_promedio
                FROM citas
                WHERE MONTH(fecha) = ? AND YEAR(fecha) = ?
            `, {
                replacements: [mesActual, anioActual],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    mes: mesActual,
                    anio: anioActual,
                    calendario,
                    estadisticas: estadisticasMes || {},
                    total_dias: diasMes
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerCalendarioMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener calendario mensual'
            });
        }
    }
    
    static async reprogramarCita(req, res) {
        try {
            const { id } = req.params;
            const { nueva_fecha, nueva_hora, motivo } = req.body;
            
            const cita = await Cita.findByPk(id);
            
            if (!cita) {
                return res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
            }
            
            // Verificar que la nueva fecha/hora no se solape
            const [solapamiento] = await sequelize.query(`
                SELECT id FROM citas 
                WHERE (
                    (psicologo_id = ? OR becario_id = ?)
                    AND fecha = ?
                    AND hora = ?
                    AND estado IN ('programada', 'confirmada')
                    AND id != ?
                )
            `, {
                replacements: [
                    cita.psicologo_id,
                    cita.becario_id || 0,
                    nueva_fecha,
                    nueva_hora,
                    id
                ],
                type: QueryTypes.SELECT
            });
            
            if (solapamiento) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe una cita programada en ese horario'
                });
            }
            
            // Guardar datos originales para log
            const datosOriginales = {
                fecha: cita.fecha,
                hora: cita.hora,
                estado: cita.estado
            };
            
            // Actualizar cita
            await cita.update({
                fecha: nueva_fecha,
                hora: nueva_hora,
                estado: 'programada',
                motivo_cancelacion: motivo ? `Reprogramación: ${motivo}` : 'Reprogramación'
            });
            
            // Crear notificaciones
            const [paciente] = await sequelize.query(
                'SELECT email, nombre, apellido FROM pacientes WHERE id = ?',
                { replacements: [cita.paciente_id], type: QueryTypes.SELECT }
            );
            
            // Notificar al psicólogo
            if (cita.psicologo_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'cita_modificada', 'Cita reprogramada', 
                    CONCAT('Cita reprogramada para el paciente: ', ?, '. Nueva fecha: ', ?, ' ', ?), NOW())
                `, {
                    replacements: [
                        cita.psicologo_id,
                        `${paciente?.nombre || 'Paciente'} ${paciente?.apellido || ''}`,
                        nueva_fecha,
                        nueva_hora
                    ]
                });
            }
            
            // Notificar al becario si está asignado
            if (cita.becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'cita_modificada', 'Cita reprogramada', 
                    CONCAT('Cita reprogramada para el paciente: ', ?, '. Nueva fecha: ', ?, ' ', ?), NOW())
                `, {
                    replacements: [
                        cita.becario_id,
                        `${paciente?.nombre || 'Paciente'} ${paciente?.apellido || ''}`,
                        nueva_fecha,
                        nueva_hora
                    ]
                });
            }
            
            res.json({
                success: true,
                message: 'Cita reprogramada exitosamente',
                data: {
                    cita_id: id,
                    fecha_anterior: datosOriginales.fecha,
                    hora_anterior: datosOriginales.hora,
                    nueva_fecha,
                    nueva_hora
                }
            });
            
        } catch (error) {
            console.error('Error en reprogramarCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al reprogramar cita'
            });
        }
    }
    
    static async obtenerDisponibilidadProfesionales(req, res) {
        try {
            const { fecha } = req.query;
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            const diaSemana = this.obtenerDiaSemana(fechaConsulta);
            
            // Consulta simplificada sin verificación de roles
            const disponibilidad = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    u.especialidad,
                    MAX(CASE WHEN d.dia_semana = ? THEN TIME_FORMAT(d.hora_inicio, '%H:%i') END) as hora_inicio,
                    MAX(CASE WHEN d.dia_semana = ? THEN TIME_FORMAT(d.hora_fin, '%H:%i') END) as hora_fin,
                    MAX(CASE WHEN d.dia_semana = ? THEN d.max_citas_dia END) as max_citas_dia,
                    COALESCE(c.citas_programadas, 0) as citas_programadas,
                    GREATEST(0, COALESCE(d.max_citas_dia, 8) - COALESCE(c.citas_programadas, 0)) as cupos_disponibles
                FROM users u
                LEFT JOIN disponibilidades d ON u.id = d.usuario_id 
                    AND d.dia_semana = ?
                    AND d.activo = TRUE
                LEFT JOIN (
                    SELECT psicologo_id, COUNT(*) as citas_programadas
                    FROM citas 
                    WHERE fecha = ?
                        AND estado IN ('programada', 'confirmada')
                    GROUP BY psicologo_id
                ) c ON u.id = c.psicologo_id
                WHERE u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido, u.rol, u.especialidad, c.citas_programadas
                ORDER BY u.rol, u.apellido, u.nombre
            `, {
                replacements: [diaSemana, diaSemana, diaSemana, diaSemana, fechaConsulta],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    fecha: fechaConsulta,
                    dia_semana: diaSemana,
                    disponibilidad,
                    total_profesionales: disponibilidad.length
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDisponibilidadProfesionales:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad de profesionales',
                error: error.message
            });
        }
    }
    
    // Métodos auxiliares
    static obtenerDiaSemana(fecha) {
        const dias = [
            'domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'
        ];
        const fechaObj = new Date(fecha);
        return dias[fechaObj.getDay()];
    }
    
    static construirWhereSQL(whereClause) {
        const condiciones = [];
        
        for (const [key, value] of Object.entries(whereClause)) {
            if (typeof value === 'object' && value[Op.between]) {
                condiciones.push(`${key} BETWEEN '${value[Op.between][0]}' AND '${value[Op.between][1]}'`);
            } else if (typeof value === 'object' && value[Op.gte]) {
                condiciones.push(`${key} >= '${value[Op.gte]}'`);
            } else if (typeof value === 'object' && value[Op.lte]) {
                condiciones.push(`${key} <= '${value[Op.lte]}'`);
            } else {
                condiciones.push(`${key} = ${typeof value === 'string' ? `'${value}'` : value}`);
            }
        }
        
        return condiciones.join(' AND ');
    }
}

module.exports = AgendaController;

/src\controllers\altaController.js:
--------------------------------------------------------------------------------
const Alta = require('../models/altaModel');
const Paciente = require('../models/pacienteModel');
const Cita = require('../models/citaModel');
const Asignacion = require('../models/asignacionModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class AltaController {
    
    static async darAltaPaciente(req, res) {
        try {
            const { paciente_id, tipo_alta, motivo_detallado, recomendaciones, 
                    evaluacion_final, seguimiento_recomendado, fecha_seguimiento } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el paciente existe y está activo
            const paciente = await Paciente.findByPk(paciente_id);
            
            if (!paciente || !paciente.activo) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado o ya dado de alta'
                });
            }
            
            // Verificar que el usuario tiene permisos
            const tienePermiso = await this.verificarPermisoAlta(usuarioId, paciente_id);
            
            if (!tienePermiso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para dar de alta a este paciente'
                });
            }
            
            // Obtener estadísticas del paciente
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_sesiones,
                    COUNT(CASE WHEN estado = 'completada' THEN 1 END) as sesiones_completadas,
                    MIN(fecha) as primera_sesion,
                    MAX(fecha) as ultima_sesion
                FROM citas 
                WHERE paciente_id = ?
                AND estado IN ('completada', 'cancelada')
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Iniciar transacción
            const transaction = await sequelize.transaction();
            
            try {
                // 1. Registrar el alta
                const alta = await Alta.create({
                    paciente_id,
                    usuario_id: usuarioId,
                    tipo_alta,
                    fecha_alta: new Date().toISOString().split('T')[0],
                    motivo_detallado,
                    recomendaciones,
                    sesiones_totales: estadisticas?.sesiones_completadas || 0,
                    evaluacion_final,
                    seguimiento_recomendado,
                    fecha_seguimiento: seguimiento_recomendado ? fecha_seguimiento : null
                }, { transaction });
                
                // 2. Desactivar paciente
                await paciente.update({
                    activo: false,
                    estado: `alta_${tipo_alta}`,
                    updated_at: new Date()
                }, { transaction });
                
                // 3. Finalizar asignaciones activas
                await Asignacion.update({
                    estado: 'finalizada',
                    fecha_fin: new Date().toISOString().split('T')[0],
                    motivo_fin: `Paciente dado de alta (${tipo_alta})`
                }, {
                    where: { paciente_id, estado: 'activa' },
                    transaction
                });
                
                // 4. Cancelar citas futuras
                await Cita.update({
                    estado: 'cancelada',
                    motivo_cancelacion: `Paciente dado de alta (${tipo_alta})`,
                    updated_at: new Date()
                }, {
                    where: {
                        paciente_id,
                        fecha: { [sequelize.Op.gte]: new Date().toISOString().split('T')[0] },
                        estado: { [sequelize.Op.in]: ['programada', 'confirmada'] }
                    },
                    transaction
                });
                
                // 5. Obtener profesionales asignados para notificaciones
                const [profesionales] = await sequelize.query(`
                    SELECT DISTINCT 
                        a.psicologo_id,
                        a.becario_id
                    FROM asignaciones a
                    WHERE a.paciente_id = ?
                    AND a.estado = 'activa'
                `, {
                    replacements: [paciente_id],
                    type: QueryTypes.SELECT,
                    transaction
                });
                
                // 6. Crear notificaciones
                if (profesionales) {
                    const notificaciones = [];
                    const titulo = 'Paciente dado de alta';
                    const mensaje = `El paciente ${paciente.nombre} ${paciente.apellido} ha sido dado de alta (${tipo_alta}).`;
                    
                    if (profesionales.psicologo_id) {
                        notificaciones.push([profesionales.psicologo_id, 'alerta_sistema', titulo, mensaje]);
                    }
                    
                    if (profesionales.becario_id) {
                        notificaciones.push([profesionales.becario_id, 'alerta_sistema', titulo, mensaje]);
                    }
                    
                    for (const [usuarioIdNotif, tipo, tituloNotif, mensajeNotif] of notificaciones) {
                        await sequelize.query(`
                            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                            VALUES (?, ?, ?, ?, NOW())
                        `, {
                            replacements: [usuarioIdNotif, tipo, tituloNotif, mensajeNotif],
                            transaction
                        });
                    }
                }
                
                // 7. Registrar log
                await sequelize.query(`
                    INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                    VALUES (?, 'modificacion', 'altas', 'Dar de alta paciente', ?, NOW())
                `, {
                    replacements: [usuarioId, `Alta paciente ${paciente_id} - Tipo: ${tipo_alta}`],
                    transaction
                });
                
                // Commit transacción
                await transaction.commit();
                
                res.json({
                    success: true,
                    message: 'Paciente dado de alta exitosamente',
                    data: {
                        alta,
                        paciente: {
                            id: paciente.id,
                            nombre: paciente.nombre,
                            apellido: paciente.apellido,
                            estado: paciente.estado
                        },
                        estadisticas
                    }
                });
                
            } catch (error) {
                await transaction.rollback();
                throw error;
            }
            
        } catch (error) {
            console.error('Error en darAltaPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al dar de alta paciente',
                error: error.message
            });
        }
    }
    
    static async obtenerAltas(req, res) {
        try {
            const { fecha_inicio, fecha_fin, tipo_alta, psicologo_id } = req.query;
            
            let query = `
                SELECT 
                    a.*,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    p.telefono AS paciente_telefono,
                    u.nombre AS usuario_nombre,
                    u.apellido AS usuario_apellido,
                    COUNT(DISTINCT c.id) AS total_sesiones
                FROM altas a
                JOIN pacientes p ON a.paciente_id = p.id
                JOIN users u ON a.usuario_id = u.id
                LEFT JOIN citas c ON a.paciente_id = c.paciente_id AND c.estado = 'completada'
                WHERE 1=1
            `;
            
            const replacements = [];
            
            if (fecha_inicio) {
                query += ` AND a.fecha_alta >= ?`;
                replacements.push(fecha_inicio);
            }
            
            if (fecha_fin) {
                query += ` AND a.fecha_alta <= ?`;
                replacements.push(fecha_fin);
            }
            
            if (tipo_alta) {
                query += ` AND a.tipo_alta = ?`;
                replacements.push(tipo_alta);
            }
            
            if (psicologo_id) {
                query += ` AND EXISTS (
                    SELECT 1 FROM asignaciones asig 
                    WHERE asig.paciente_id = a.paciente_id 
                    AND asig.psicologo_id = ?
                    AND asig.estado = 'finalizada'
                )`;
                replacements.push(psicologo_id);
            }
            
            query += ` GROUP BY a.id, p.id, u.id
                      ORDER BY a.fecha_alta DESC, p.apellido, p.nombre`;
            
            const altas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: altas,
                count: altas.length
            });
            
        } catch (error) {
            console.error('Error en obtenerAltas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener altas'
            });
        }
    }
    
    static async obtenerAltaDetalle(req, res) {
        try {
            const { id } = req.params;
            
            const query = `
                SELECT 
                    a.*,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    p.fecha_nacimiento,
                    p.genero,
                    p.email AS paciente_email,
                    p.telefono AS paciente_telefono,
                    u.nombre AS usuario_nombre,
                    u.apellido AS usuario_apellido,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = a.paciente_id AND estado = 'completada') AS total_sesiones,
                    (SELECT GROUP_CONCAT(DISTINCT DATE_FORMAT(fecha, '%Y-%m-%d') ORDER BY fecha DESC SEPARATOR ', ') 
                     FROM citas WHERE paciente_id = a.paciente_id AND estado = 'completada' LIMIT 10) AS ultimas_sesiones
                FROM altas a
                JOIN pacientes p ON a.paciente_id = p.id
                JOIN users u ON a.usuario_id = u.id
                LEFT JOIN (
                    SELECT DISTINCT paciente_id, psicologo_id 
                    FROM asignaciones 
                    WHERE paciente_id = ? 
                    ORDER BY fecha_inicio DESC 
                    LIMIT 1
                ) asig ON p.id = asig.paciente_id
                LEFT JOIN users u_psi ON asig.psicologo_id = u_psi.id
                WHERE a.id = ?
            `;
            
            const [alta] = await sequelize.query(query, {
                replacements: [id, id],
                type: QueryTypes.SELECT
            });
            
            if (!alta) {
                return res.status(404).json({
                    success: false,
                    message: 'Alta no encontrada'
                });
            }
            
            res.json({
                success: true,
                data: alta
            });
            
        } catch (error) {
            console.error('Error en obtenerAltaDetalle:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener detalle de alta'
            });
        }
    }
    
    static async obtenerEstadisticasAltas(req, res) {
        try {
            const { fecha_inicio, fecha_fin } = req.query;
            
            const query = `
                SELECT 
                    tipo_alta,
                    COUNT(*) as total,
                    MONTH(fecha_alta) as mes,
                    YEAR(fecha_alta) as anio,
                    AVG(sesiones_totales) as promedio_sesiones,
                    SUM(CASE WHEN seguimiento_recomendado = TRUE THEN 1 ELSE 0 END) as seguimientos_recomendados
                FROM altas
                WHERE 1=1
            `;
            
            const replacements = [];
            
            if (fecha_inicio) {
                query += ` AND fecha_alta >= ?`;
                replacements.push(fecha_inicio);
            }
            
            if (fecha_fin) {
                query += ` AND fecha_alta <= ?`;
                replacements.push(fecha_fin);
            }
            
            query += ` GROUP BY tipo_alta, YEAR(fecha_alta), MONTH(fecha_alta)
                      ORDER BY anio DESC, mes DESC, total DESC`;
            
            const estadisticas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Totales generales
            const [totales] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_altas,
                    AVG(sesiones_totales) as promedio_sesiones_global,
                    MIN(fecha_alta) as primera_alta,
                    MAX(fecha_alta) as ultima_alta
                FROM altas
                WHERE 1=1 ${fecha_inicio ? 'AND fecha_alta >= ?' : ''} ${fecha_fin ? 'AND fecha_alta <= ?' : ''}
            `, {
                replacements: fecha_inicio && fecha_fin ? [fecha_inicio, fecha_fin] : 
                            fecha_inicio ? [fecha_inicio] : fecha_fin ? [fecha_fin] : [],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    totales
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasAltas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas de altas'
            });
        }
    }
    
    // Método auxiliar para verificar permisos
    static async verificarPermisoAlta(usuarioId, pacienteId) {
        const usuarioRol = await this.obtenerRolUsuario(usuarioId);
        
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
            `, {
                replacements: [pacienteId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!asignacion;
        }
        
        return false;
    }
    
    static async obtenerRolUsuario(usuarioId) {
        const [usuario] = await sequelize.query(
            'SELECT rol FROM users WHERE id = ?',
            { replacements: [usuarioId], type: QueryTypes.SELECT }
        );
        
        return usuario?.rol;
    }
}

module.exports = AltaController;

/src\controllers\asignacionController.js:
--------------------------------------------------------------------------------
const Asignacion = require('../models/asignacionModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class AsignacionController {
    
    static async crearAsignacion(req, res) {
        try {
            const { paciente_id, psicologo_id, becario_id, notas } = req.body;
            const usuarioId = req.user.id;
            
            // Validar que el paciente existe y está activo
            const paciente = await Paciente.findByPk(paciente_id);
            if (!paciente || !paciente.activo) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado o inactivo'
                });
            }
            
            // Validar que el psicólogo existe y es psicólogo
            const psicologo = await User.findOne({
                where: { id: psicologo_id, rol: 'psicologo', activo: true }
            });
            
            if (!psicologo) {
                return res.status(404).json({
                    success: false,
                    message: 'Psicólogo no encontrado o inactivo'
                });
            }
            
            // Validar que el becario existe si se especifica
            if (becario_id) {
                const becario = await User.findOne({
                    where: { id: becario_id, rol: 'becario', activo: true }
                });
                
                if (!becario) {
                    return res.status(404).json({
                        success: false,
                        message: 'Becario no encontrado o inactivo'
                    });
                }
            }
            
            // Verificar que no haya asignación activa
            const asignacionExistente = await Asignacion.findOne({
                where: {
                    paciente_id,
                    estado: 'activa'
                }
            });
            
            if (asignacionExistente) {
                // Finalizar asignación anterior
                await asignacionExistente.update({
                    estado: 'finalizada',
                    fecha_fin: new Date().toISOString().split('T')[0],
                    motivo_fin: 'Reasignación'
                });
            }
            
            // Crear nueva asignación
            const asignacion = await Asignacion.create({
                paciente_id,
                psicologo_id,
                becario_id,
                notas,
                fecha_inicio: new Date().toISOString().split('T')[0]
            });
            
            // Actualizar paciente con psicólogo asignado
            await paciente.update({ fundacion_id: psicologo.fundacion_id });
            
            // Crear notificaciones
            await sequelize.query(`
                INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                VALUES 
                (?, 'asignacion_nueva', 'Nueva asignación', CONCAT('Se le ha asignado el paciente: ', ?), NOW()),
                (?, 'asignacion_nueva', 'Nueva asignación', CONCAT('Ha sido asignado como supervisor del paciente: ', ?), NOW())
            `, {
                replacements: [
                    psicologo_id,
                    `${paciente.nombre} ${paciente.apellido}`,
                    usuarioId,
                    `${paciente.nombre} ${paciente.apellido}`
                ]
            });
            
            if (becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'asignacion_nueva', 'Nueva asignación', CONCAT('Se le ha asignado el paciente: ', ?), NOW())
                `, {
                    replacements: [
                        becario_id,
                        `${paciente.nombre} ${paciente.apellido}`
                    ]
                });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'asignaciones', 'Crear asignación', ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Asignación creada: Paciente ${paciente.id} → Psicólogo ${psicologo_id}${becario_id ? ` + Becario ${becario_id}` : ''}`
                ]
            });
            
            res.json({
                success: true,
                message: 'Asignación creada exitosamente',
                data: asignacion
            });
            
        } catch (error) {
            console.error('Error en crearAsignacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear asignación',
                error: error.message
            });
        }
    }
    
    static async obtenerAsignacionesActivas(req, res) {
        try {
            const { psicologo_id, becario_id, paciente_id } = req.query;
            const usuarioId = req.user.id;
            
            const whereClause = { estado: 'activa' };
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (becario_id) whereClause.becario_id = becario_id;
            if (paciente_id) whereClause.paciente_id = paciente_id;
            
            const asignaciones = await Asignacion.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['id', 'nombre', 'apellido', 'email', 'telefono', 'estado']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'email', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            res.json({
                success: true,
                data: asignaciones,
                count: asignaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerAsignacionesActivas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener asignaciones'
            });
        }
    }
    
    static async obtenerMisPacientes(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            let query = '';
            let replacements = [usuarioId];
            
            if (usuarioRol === 'psicologo') {
                query = `
                    SELECT 
                        p.*,
                        a.fecha_inicio,
                        a.becario_id,
                        u_bec.nombre AS becario_nombre,
                        u_bec.apellido AS becario_apellido,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.estado = 'completada') AS sesiones_completadas,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.estado = 'programada'
                         AND c.fecha >= CURDATE()) AS citas_pendientes
                    FROM asignaciones a
                    JOIN pacientes p ON a.paciente_id = p.id
                    LEFT JOIN users u_bec ON a.becario_id = u_bec.id
                    WHERE a.psicologo_id = ? 
                    AND a.estado = 'activa'
                    AND p.activo = TRUE
                    ORDER BY p.apellido, p.nombre
                `;
            } else if (usuarioRol === 'becario') {
                query = `
                    SELECT 
                        p.*,
                        a.fecha_inicio,
                        a.psicologo_id,
                        u_psi.nombre AS psicologo_nombre,
                        u_psi.apellido AS psicologo_apellido,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.becario_id = ?
                         AND c.estado = 'completada') AS sesiones_completadas,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.becario_id = ?
                         AND c.estado = 'programada'
                         AND c.fecha >= CURDATE()) AS citas_pendientes
                    FROM asignaciones a
                    JOIN pacientes p ON a.paciente_id = p.id
                    JOIN users u_psi ON a.psicologo_id = u_psi.id
                    WHERE a.becario_id = ? 
                    AND a.estado = 'activa'
                    AND p.activo = TRUE
                    ORDER BY p.apellido, p.nombre
                `;
                replacements = [usuarioId, usuarioId, usuarioId];
            } else {
                return res.status(403).json({
                    success: false,
                    message: 'Acceso no permitido para este rol'
                });
            }
            
            const pacientes = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: pacientes,
                count: pacientes.length
            });
            
        } catch (error) {
            console.error('Error en obtenerMisPacientes:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener pacientes asignados'
            });
        }
    }
    
    static async finalizarAsignacion(req, res) {
        try {
            const { id } = req.params;
            const { motivo_fin, notas } = req.body;
            const usuarioId = req.user.id;
            
            const asignacion = await Asignacion.findByPk(id);
            
            if (!asignacion || asignacion.estado !== 'activa') {
                return res.status(404).json({
                    success: false,
                    message: 'Asignación activa no encontrada'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...asignacion.toJSON() };
            
            await asignacion.update({
                estado: 'finalizada',
                fecha_fin: new Date().toISOString().split('T')[0],
                motivo_fin: motivo_fin || 'Finalización manual',
                notas: notas ? `${asignacion.notas || ''}\n--- Finalización ---\n${notas}` : asignacion.notas
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'asignaciones', 'Finalizar asignación', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Asignación finalizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(asignacion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Asignación finalizada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en finalizarAsignacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al finalizar asignación'
            });
        }
    }
    
    static async obtenerHistorialAsignaciones(req, res) {
        try {
            const { paciente_id } = req.params;
            
            const asignaciones = await Asignacion.findAll({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            res.json({
                success: true,
                data: asignaciones,
                count: asignaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerHistorialAsignaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener historial de asignaciones'
            });
        }
    }
}

module.exports = AsignacionController;

/src\controllers\authController.js:
--------------------------------------------------------------------------------
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
// Importamos el modelo de Sequelize
const User = require('../models/userModel'); 

class AuthController {
    
    static async login(req, res) {
        try {
            const { email, password } = req.body;

            // 1. Validar entrada básica
            if (!email || !password) {
                return res.status(400).json({ message: 'Por favor ingrese email y contraseña' });
            }

            // 2. Buscar el usuario usando Sequelize
            // En vez de SQL crudo, usamos el método findOne con una cláusula 'where'
            const user = await User.findOne({ 
                where: { email: email } 
            });

            // 3. Verificar si el usuario existe
            if (!user) {
                // 'user' será null si no se encuentra
                return res.status(401).json({ message: 'Credenciales inválidas' });
            }

            // 4. Comparar la contraseña (user.password accede al campo del objeto Sequelize)
            const isMatch = await bcrypt.compare(password, user.password);

            if (!isMatch) {
                return res.status(401).json({ message: 'Credenciales inválidas' });
            }

            // 5. Generar el JWT (usamos user.id y user.email del objeto Sequelize)
            const payload = {
                id: user.id,
                email: user.email
            };

            const token = jwt.sign(
                payload, 
                process.env.JWT_SECRET, 
                { expiresIn: process.env.JWT_EXPIRES_IN }
            );

            // 6. Responder (user.toJSON() limpia metadatos de Sequelize si es necesario)
            res.json({
                message: 'Login exitoso',
                token: token,
                user: { 
                    id: user.id, 
                    email: user.email,
                    nombre: user.nombre, // Añade esto
                    apellido: user.apellido, // Añade esto
                    rol: user.rol, // Añade esto
                    especialidad: user.especialidad, // Añade esto (si aplica)
                    created_at: user.created_at // Cambia createdAt por created_at
                }
            });

        } catch (error) {
            console.error('Error en el login:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }

    static async getMe(req, res) {
        try {
            const userId = req.user.id;
            
            // Buscar usuario en la base de datos
            const user = await User.findOne({ 
                where: { id: userId },
                attributes: ['id', 'email', 'nombre', 'apellido', 'rol', 'especialidad', 'created_at'] // Cambia 'createdAt' por 'created_at'
            });
            
            if (!user) {
                return res.status(404).json({ message: 'Usuario no encontrado' });
            }
            
            res.json({
                message: 'Usuario obtenido exitosamente',
                user: user
            });
            
        } catch (error) {
            console.error('Error al obtener usuario:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }
}

module.exports = AuthController

/src\controllers\citaController.js:
--------------------------------------------------------------------------------
const DatabaseService = require('../services/databaseService');

class CitaController {
    
    static async obtenerCitasPorFecha(req, res) {
        try {
            console.log('obtenerCitasPorFecha llamado');
            console.log('Query params:', req.query);
            
            const { fecha, becario_id } = req.query;
            
            // Validar parámetro requerido
            if (!fecha) {
                return res.status(400).json({
                    success: false,
                    message: 'El parámetro "fecha" es requerido (formato: YYYY-MM-DD)'
                });
            }
            
            const becarioId = becario_id ? parseInt(becario_id) : null;
            
            console.log(`Buscando citas para fecha: ${fecha}, becarioId: ${becarioId}`);
            
            const citas = await DatabaseService.obtenerCitasPorFechaBecario(fecha, becarioId);
            
            console.log(`Citas encontradas: ${Array.isArray(citas) ? citas.length : 0}`);
            
            // Asegurarnos de que citas siempre sea un array
            const citasArray = Array.isArray(citas) ? citas : [];
            
            res.json({
                success: true,
                data: citasArray,
                count: citasArray.length
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFecha:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener citas',
                error: error.message
            });
        }
    }

    static async crearNuevaCita(req, res) {
        try {
            const { paciente, fecha, hora, tipo_consulta, duracion, notas, becario_id } = req.body;
            const usuarioId = req.user.id;
            
            console.log('📝 Datos recibidos para nueva cita:', {
                paciente,
                fecha,
                hora,
                tipo_consulta,
                duracion,
                notas,
                becario_id,
                usuarioId
            });
            
            // Validar campos requeridos
            if (!paciente || !paciente.nombre || !paciente.apellido || !fecha || !hora) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente (nombre, apellido), fecha y hora'
                });
            }
            
            // Crear la cita usando DatabaseService
            const nuevaCita = await DatabaseService.crearNuevaCita({
                paciente,
                fecha,
                hora,
                tipo_consulta: tipo_consulta || 'presencial',
                duracion: duracion || 50,
                notas,
                becario_id,
                usuarioId
            });
            
            res.json({
                success: true,
                message: 'Cita creada exitosamente',
                data: nuevaCita
            });
            
        } catch (error) {
            console.error('❌ Error en crearNuevaCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear la cita',
                error: error.message
            });
        }
    }
    
    static async generarReporteMensual(req, res) {
        try {
            const { mes, anio, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const reporte = await DatabaseService.generarReporteMensual(
                parseInt(mes),
                parseInt(anio),
                psicologoId
            );
            
            res.json({
                success: true,
                data: reporte,
                count: reporte.length,
                mes: mes,
                anio: anio
            });
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte',
                error: error.message
            });
        }
    }
    
    static async darAltaPaciente(req, res) {
        try {
            const { paciente_id, tipo_alta, notas } = req.body;
            const usuarioId = req.user.id;
            
            if (!paciente_id || !tipo_alta) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente_id y tipo_alta'
                });
            }
            
            await DatabaseService.darAltaPaciente(
                paciente_id,
                tipo_alta,
                usuarioId,
                notas
            );
            
            res.json({
                success: true,
                message: 'Paciente dado de alta exitosamente'
            });
            
        } catch (error) {
            console.error('Error en darAltaPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al dar de alta paciente',
                error: error.message
            });
        }
    }
    
    static async actualizarCita(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            // Validar campos que se pueden actualizar
            const camposPermitidos = ['fecha', 'hora', 'tipo_consulta', 'estado', 'notas', 'motivo_cancelacion', 'psicologo_id', 'becario_id'];
            const updatesFiltrados = {};
            
            for (const campo of camposPermitidos) {
                if (updates[campo] !== undefined) {
                    updatesFiltrados[campo] = updates[campo];
                }
            }
            
            if (Object.keys(updatesFiltrados).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos válidos para actualizar'
                });
            }
            
            await DatabaseService.actualizarCita(
                parseInt(id),
                updatesFiltrados,
                usuarioId
            );
            
            res.json({
                success: true,
                message: 'Cita actualizada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en actualizarCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar cita',
                error: error.message
            });
        }
    }
    
    static async obtenerEstadisticas(req, res) {
        try {
            const { fecha_inicio, fecha_fin, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const estadisticas = await DatabaseService.obtenerEstadisticas(
                fecha_inicio,
                fecha_fin,
                psicologoId
            );
            
            res.json({
                success: true,
                data: estadisticas
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas',
                error: error.message
            });
        }
    }
}

module.exports = CitaController;

/src\controllers\dashboardController.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class DashboardController {
    
    static async obtenerDashboardCoordinador(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estadísticas generales
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = FALSE) as pacientes_inactivos,
                    (SELECT COUNT(*) FROM pacientes WHERE DATE(created_at) = CURDATE()) as pacientes_nuevos_hoy,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'cancelada') as citas_canceladas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 7 DAY) AND CURDATE()) as citas_semana,
                    
                    -- Profesionales
                    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'coordinador' AND activo = TRUE) as coordinadores_activos,
                    
                    -- Asignaciones
                    (SELECT COUNT(*) FROM asignaciones WHERE estado = 'activa') as asignaciones_activas,
                    (SELECT COUNT(*) FROM asignaciones WHERE estado = 'finalizada' AND fecha_fin >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as asignaciones_finalizadas_mes,
                    
                    -- Altas
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as altas_mes,
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta = CURDATE()) as altas_hoy
            `, { type: QueryTypes.SELECT });
            
            // Citas por día de la semana actual
            const citasPorDia = await sequelize.query(`
                SELECT 
                    DAYNAME(fecha) as dia,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas
                FROM citas
                WHERE YEARWEEK(fecha, 1) = YEARWEEK(CURDATE(), 1)
                GROUP BY DAYNAME(fecha), DAYOFWEEK(fecha)
                ORDER BY DAYOFWEEK(fecha)
            `, { type: QueryTypes.SELECT });
            
            // Top psicólogos por citas completadas
            const topPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as nombre_completo,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completadas
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
                WHERE u.rol = 'psicologo' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY citas_completadas DESC
                LIMIT 10
            `, { type: QueryTypes.SELECT });
            
            // Alertas y pendientes
            const alertas = await sequelize.query(`
                SELECT 
                    'citas_sin_confirmar' as tipo,
                    COUNT(*) as cantidad,
                    'Citas programadas sin confirmar' as descripcion
                FROM citas
                WHERE estado = 'programada' AND fecha = CURDATE()
                
                UNION ALL
                
                SELECT 
                    'observaciones_pendientes' as tipo,
                    COUNT(*) as cantidad,
                    'Observaciones de becarios pendientes de revisión' as descripcion
                FROM observaciones_becarios
                WHERE fecha_seguimiento <= CURDATE() AND fecha_seguimiento IS NOT NULL
                
                UNION ALL
                
                SELECT 
                    'altas_pendientes' as tipo,
                    COUNT(*) as cantidad,
                    'Pacientes pendientes de revisión para alta' as descripcion
                FROM pacientes p
                WHERE p.activo = TRUE 
                AND NOT EXISTS (SELECT 1 FROM altas a WHERE a.paciente_id = p.id)
                AND (SELECT COUNT(*) FROM citas c WHERE c.paciente_id = p.id AND c.estado = 'completada') >= 4
            `, { type: QueryTypes.SELECT });
            
            // Evolución mensual de pacientes
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha_alta, '%Y-%m') as mes,
                    COUNT(*) as altas,
                    SUM(CASE WHEN tipo_alta = 'terapeutica' THEN 1 ELSE 0 END) as altas_terapeuticas,
                    SUM(CASE WHEN tipo_alta = 'abandono' THEN 1 ELSE 0 END) as abandonos
                FROM altas
                WHERE fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
                GROUP BY DATE_FORMAT(fecha_alta, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    citas_por_dia: citasPorDia,
                    top_psicologos: topPsicologos,
                    alertas,
                    evolucion_mensual: evolucionMensual.reverse(), // Orden ascendente
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardCoordinador:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de coordinador'
            });
        }
    }
    
    static async obtenerDashboardPsicologo(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estadísticas del psicólogo
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes asignados
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE psicologo_id = ? AND estado = 'activa') as pacientes_asignados,
                    
                    -- Becarios supervisados
                    (SELECT COUNT(DISTINCT becario_id) FROM asignaciones WHERE psicologo_id = ? AND becario_id IS NOT NULL AND estado = 'activa') as becarios_supervisados,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 7 DAY) AND CURDATE()) as citas_semana,
                    
                    -- Sesiones registradas
                    (SELECT COUNT(*) FROM sesiones WHERE psicologo_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as sesiones_mes,
                    
                    -- Observaciones realizadas
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE supervisor_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as observaciones_mes,
                    
                    -- Altas realizadas
                    (SELECT COUNT(*) FROM altas WHERE usuario_id = ? AND fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as altas_mes
            `, {
                replacements: [usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Próximas citas
            const proximasCitas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    u_bec.nombre as becario_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.psicologo_id = ?
                AND c.fecha >= CURDATE()
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
                LIMIT 10
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Pacientes con seguimiento pendiente
            const pacientesSeguimiento = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    MAX(c.fecha) as ultima_sesion,
                    DATEDIFF(CURDATE(), MAX(c.fecha)) as dias_desde_ultima,
                    COUNT(c.id) as total_sesiones
                FROM asignaciones a
                JOIN pacientes p ON a.paciente_id = p.id
                LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
                WHERE a.psicologo_id = ?
                AND a.estado = 'activa'
                AND p.activo = TRUE
                GROUP BY p.id, p.nombre, p.apellido
                HAVING DATEDIFF(CURDATE(), MAX(c.fecha)) > 14 OR MAX(c.fecha) IS NULL
                ORDER BY dias_desde_ultima DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Observaciones recientes de becarios
            const observacionesRecientes = await sequelize.query(`
                SELECT 
                    ob.id,
                    ob.fecha,
                    ob.aspecto_evaluado,
                    ob.calificacion,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario,
                    ob.plan_accion,
                    ob.fecha_seguimiento
                FROM observaciones_becarios ob
                JOIN users u_bec ON ob.becario_id = u_bec.id
                WHERE ob.supervisor_id = ?
                ORDER BY ob.fecha DESC, ob.created_at DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Disponibilidad para la semana
            const disponibilidadSemana = await sequelize.query(`
                SELECT 
                    d.dia_semana,
                    TIME_FORMAT(d.hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(d.hora_fin, '%H:%i') as hora_fin,
                    COUNT(c.id) as citas_programadas
                FROM disponibilidades d
                LEFT JOIN citas c ON d.usuario_id = c.psicologo_id 
                    AND c.fecha BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY)
                    AND c.estado IN ('programada', 'confirmada')
                    AND DAYNAME(c.fecha) = d.dia_semana
                    AND TIME(c.hora) BETWEEN d.hora_inicio AND d.hora_fin
                WHERE d.usuario_id = ?
                AND d.activo = TRUE
                GROUP BY d.dia_semana, d.hora_inicio, d.hora_fin
                ORDER BY FIELD(d.dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo')
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    proximas_citas: proximasCitas,
                    pacientes_seguimiento: pacientesSeguimiento,
                    observaciones_recientes: observacionesRecientes,
                    disponibilidad_semana: disponibilidadSemana,
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardPsicologo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de psicólogo'
            });
        }
    }
    
    static async obtenerDashboardBecario(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estadísticas del becario
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes asignados
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE becario_id = ? AND estado = 'activa') as pacientes_asignados,
                    
                    -- Citas de hoy
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    
                    -- Citas totales
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND CURDATE()) as citas_mes,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND estado = 'completada') as citas_completadas_total,
                    
                    -- Observaciones recibidas
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE becario_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as observaciones_mes,
                    (SELECT AVG(calificacion) FROM observaciones_becarios WHERE becario_id = ?) as promedio_calificacion,
                    
                    -- Supervisor
                    (SELECT CONCAT(u.nombre, ' ', u.apellido) FROM asignaciones a 
                     JOIN users u ON a.psicologo_id = u.id 
                     WHERE a.becario_id = ? AND a.estado = 'activa' LIMIT 1) as supervisor
            `, {
                replacements: [usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Citas de hoy
            const citasHoy = await sequelize.query(`
                SELECT 
                    c.id,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    u_psi.nombre as psicologo_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
                WHERE c.becario_id = ?
                AND c.fecha = CURDATE()
                AND c.estado IN ('programada', 'confirmada', 'completada')
                ORDER BY c.hora
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Próximas citas
            const proximasCitas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.fecha > CURDATE()
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
                LIMIT 10
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Observaciones recientes
            const observacionesRecientes = await sequelize.query(`
                SELECT 
                    ob.id,
                    ob.fecha,
                    ob.aspecto_evaluado,
                    ob.calificacion,
                    ob.fortalezas,
                    ob.areas_mejora,
                    CONCAT(u_sup.nombre, ' ', u_sup.apellido) as supervisor,
                    ob.fecha_seguimiento
                FROM observaciones_becarios ob
                JOIN users u_sup ON ob.supervisor_id = u_sup.id
                WHERE ob.becario_id = ?
                ORDER BY ob.fecha DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Tareas pendientes (sesiones sin registro)
            const tareasPendientes = await sequelize.query(`
                SELECT 
                    c.id as cita_id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    DATEDIFF(CURDATE(), c.fecha) as dias_pasados
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.estado = 'completada'
                AND NOT EXISTS (SELECT 1 FROM sesiones s WHERE s.cita_id = c.id)
                AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
                ORDER BY c.fecha DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Disponibilidad
            const disponibilidad = await sequelize.query(`
                SELECT 
                    dia_semana,
                    TIME_FORMAT(hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(hora_fin, '%H:%i') as hora_fin
                FROM disponibilidades
                WHERE usuario_id = ?
                AND activo = TRUE
                ORDER BY FIELD(dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo')
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    citas_hoy,
                    proximas_citas,
                    observaciones_recientes,
                    tareas_pendientes,
                    disponibilidad,
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de becario'
            });
        }
    }
    
    static async obtenerMetricasGlobales(req, res) {
        try {
            const { periodo = 'mes' } = req.query; // mes, trimestre, semestre, año
            
            let intervalo;
            switch (periodo) {
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                case 'semestre':
                    intervalo = 'INTERVAL 180 DAY';
                    break;
                case 'año':
                    intervalo = 'INTERVAL 365 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            // Métricas principales
            const [metricas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    COUNT(DISTINCT p.id) as total_pacientes,
                    COUNT(DISTINCT CASE WHEN p.activo = TRUE THEN p.id END) as pacientes_activos,
                    COUNT(DISTINCT CASE WHEN p.activo = FALSE THEN p.id END) as pacientes_inactivos,
                    
                    -- Citas
                    COUNT(DISTINCT c.id) as total_citas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) as citas_completadas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'cancelada' THEN c.id END) as citas_canceladas,
                    
                    -- Sesiones
                    COUNT(DISTINCT s.id) as sesiones_registradas,
                    
                    -- Altas
                    COUNT(DISTINCT a.id) as altas_realizadas,
                    COUNT(DISTINCT CASE WHEN a.tipo_alta = 'terapeutica' THEN a.id END) as altas_terapeuticas,
                    
                    -- Tasa de completitud
                    ROUND(COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) * 100.0 / 
                          NULLIF(COUNT(DISTINCT c.id), 0), 2) as tasa_completitud_citas,
                    
                    -- Tasa de abandono
                    ROUND(COUNT(DISTINCT CASE WHEN a.tipo_alta = 'abandono' THEN a.id END) * 100.0 / 
                          NULLIF(COUNT(DISTINCT a.id), 0), 2) as tasa_abandono
                    
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN altas a ON p.id = a.paciente_id AND a.fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})
                WHERE p.created_at >= DATE_SUB(CURDATE(), ${intervalo})
            `, { type: QueryTypes.SELECT });
            
            // Evolución semanal
            const evolucionSemanal = await sequelize.query(`
                SELECT 
                    YEARWEEK(c.fecha, 1) as semana,
                    COUNT(DISTINCT c.id) as total_citas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) as citas_completadas,
                    COUNT(DISTINCT p.id) as pacientes_atendidos,
                    COUNT(DISTINCT a.id) as altas_realizadas
                FROM citas c
                LEFT JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN altas a ON p.id = a.paciente_id AND YEARWEEK(a.fecha_alta, 1) = YEARWEEK(c.fecha, 1)
                WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY YEARWEEK(c.fecha, 1)
                ORDER BY semana DESC
                LIMIT 12
            `, { type: QueryTypes.SELECT });
            
            // Distribución por tipo de consulta
            const distribucionConsulta = await sequelize.query(`
                SELECT 
                    c.tipo_consulta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM citas c
                WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY c.tipo_consulta
            `, { type: QueryTypes.SELECT });
            
            // Distribución por motivo de alta
            const distribucionAlta = await sequelize.query(`
                SELECT 
                    a.tipo_alta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM altas a
                WHERE a.fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY a.tipo_alta
            `, { type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    periodo,
                    metricas,
                    evolucion_semanal: evolucionSemanal.reverse(),
                    distribucion_consulta: distribucionConsulta,
                    distribucion_alta: distribucionAlta,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerMetricasGlobales:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener métricas globales'
            });
        }
    }
}

module.exports = DashboardController;

/src\controllers\disponibilidadController.js:
--------------------------------------------------------------------------------
const Disponibilidad = require('../models/disponibilidadModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class DisponibilidadController {
    
    static async crearDisponibilidad(req, res) {
        try {
            const { dia_semana, hora_inicio, hora_fin, tipo_disponibilidad, 
                    notas, max_citas_dia, intervalo_citas, fecha_fin_vigencia } = req.body;
            const usuarioId = req.user.id;
            
            // Validar que el usuario existe y es profesional (psicologo o becario)
            const usuario = await User.findByPk(usuarioId);
            if (!['psicologo', 'becario'].includes(usuario.rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo psicólogos y becarios pueden configurar disponibilidad'
                });
            }
            
            // Validar formato de hora
            if (!this.validarHora(hora_inicio) || !this.validarHora(hora_fin)) {
                return res.status(400).json({
                    success: false,
                    message: 'Formato de hora inválido. Use HH:MM'
                });
            }
            
            // Validar que hora_fin sea mayor que hora_inicio
            if (this.compararHoras(hora_fin, hora_inicio) <= 0) {
                return res.status(400).json({
                    success: false,
                    message: 'La hora de fin debe ser mayor que la hora de inicio'
                });
            }
            
            // Verificar que no se solape con otra disponibilidad en el mismo día
            const solapamiento = await Disponibilidad.findOne({
                where: {
                    usuario_id: usuarioId,
                    dia_semana,
                    activo: true,
                    [sequelize.Op.or]: [
                        {
                            hora_inicio: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                        },
                        {
                            hora_fin: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                        },
                        {
                            [sequelize.Op.and]: [
                                { hora_inicio: { [sequelize.Op.lte]: hora_inicio } },
                                { hora_fin: { [sequelize.Op.gte]: hora_fin } }
                            ]
                        }
                    ]
                }
            });
            
            if (solapamiento) {
                return res.status(400).json({
                    success: false,
                    message: 'La disponibilidad se solapa con otro horario configurado para este día'
                });
            }
            
            // Crear disponibilidad
            const disponibilidad = await Disponibilidad.create({
                usuario_id: usuarioId,
                dia_semana,
                hora_inicio,
                hora_fin,
                tipo_disponibilidad: tipo_disponibilidad || 'regular',
                notas,
                max_citas_dia: max_citas_dia || 8,
                intervalo_citas: intervalo_citas || 50,
                fecha_inicio_vigencia: new Date().toISOString().split('T')[0],
                fecha_fin_vigencia: fecha_fin_vigencia || null,
                activo: true
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'disponibilidad', 'Crear disponibilidad', ?, NOW())
            `, {
                replacements: [usuarioId, `Disponibilidad creada: ${dia_semana} ${hora_inicio}-${hora_fin}`]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad creada exitosamente',
                data: disponibilidad
            });
            
        } catch (error) {
            console.error('Error en crearDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear disponibilidad',
                error: error.message
            });
        }
    }
    
    static async obtenerMiDisponibilidad(req, res) {
        try {
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findAll({
                where: {
                    usuario_id: usuarioId,
                    activo: true,
                    [sequelize.Op.or]: [
                        { fecha_fin_vigencia: null },
                        { fecha_fin_vigencia: { [sequelize.Op.gte]: new Date().toISOString().split('T')[0] } }
                    ]
                },
                order: [
                    ['dia_semana', 'ASC'],
                    ['hora_inicio', 'ASC']
                ]
            });
            
            // Obtener citas programadas para los próximos 7 días
            const [citasProgramadas] = await sequelize.query(`
                SELECT 
                    fecha,
                    COUNT(*) as citas_count
                FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY)
                AND estado IN ('programada', 'confirmada')
                GROUP BY fecha
                ORDER BY fecha
            `, {
                replacements: [usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    disponibilidad,
                    proximas_citas: citasProgramadas || []
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerMiDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad'
            });
        }
    }
    
    static async obtenerDisponibilidadUsuario(req, res) {
        try {
            const { usuario_id } = req.params;
            const solicitanteId = req.user.id;
            const solicitanteRol = req.user.rol;
            
            // Verificar permisos (coordinador o psicólogo supervisor)
            const puedeVer = await this.verificarPermisoVerDisponibilidad(solicitanteId, solicitanteRol, usuario_id);
            
            if (!puedeVer) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver la disponibilidad de este usuario'
                });
            }
            
            const disponibilidad = await Disponibilidad.findAll({
                where: {
                    usuario_id,
                    activo: true
                },
                order: [
                    ['dia_semana', 'ASC'],
                    ['hora_inicio', 'ASC']
                ]
            });
            
            // Obtener información del usuario
            const usuario = await User.findByPk(usuario_id, {
                attributes: ['id', 'nombre', 'apellido', 'rol', 'especialidad']
            });
            
            res.json({
                success: true,
                data: {
                    usuario,
                    disponibilidad
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDisponibilidadUsuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad del usuario'
            });
        }
    }
    
    static async actualizarDisponibilidad(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findByPk(id);
            
            if (!disponibilidad) {
                return res.status(404).json({
                    success: false,
                    message: 'Disponibilidad no encontrada'
                });
            }
            
            // Verificar que el usuario es el dueño de la disponibilidad
            if (disponibilidad.usuario_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar esta disponibilidad'
                });
            }
            
            // Validar horas si se están actualizando
            if (updates.hora_inicio || updates.hora_fin) {
                const hora_inicio = updates.hora_inicio || disponibilidad.hora_inicio;
                const hora_fin = updates.hora_fin || disponibilidad.hora_fin;
                
                if (this.compararHoras(hora_fin, hora_inicio) <= 0) {
                    return res.status(400).json({
                        success: false,
                        message: 'La hora de fin debe ser mayor que la hora de inicio'
                    });
                }
                
                // Verificar solapamiento excluyendo el registro actual
                const solapamiento = await Disponibilidad.findOne({
                    where: {
                        usuario_id: disponibilidad.usuario_id,
                        dia_semana: updates.dia_semana || disponibilidad.dia_semana,
                        id: { [sequelize.Op.ne]: id },
                        activo: true,
                        [sequelize.Op.or]: [
                            {
                                hora_inicio: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                            },
                            {
                                hora_fin: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                            },
                            {
                                [sequelize.Op.and]: [
                                    { hora_inicio: { [sequelize.Op.lte]: hora_inicio } },
                                    { hora_fin: { [sequelize.Op.gte]: hora_fin } }
                                ]
                            }
                        ]
                    }
                });
                
                if (solapamiento) {
                    return res.status(400).json({
                        success: false,
                        message: 'La disponibilidad se solapa con otro horario configurado'
                    });
                }
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...disponibilidad.toJSON() };
            
            await disponibilidad.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'disponibilidad', 'Actualizar disponibilidad', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Disponibilidad actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(disponibilidad.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad actualizada exitosamente',
                data: disponibilidad
            });
            
        } catch (error) {
            console.error('Error en actualizarDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar disponibilidad'
            });
        }
    }
    
    static async desactivarDisponibilidad(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findByPk(id);
            
            if (!disponibilidad) {
                return res.status(404).json({
                    success: false,
                    message: 'Disponibilidad no encontrada'
                });
            }
            
            // Verificar que el usuario es el dueño de la disponibilidad
            if (disponibilidad.usuario_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para desactivar esta disponibilidad'
                });
            }
            
            // Verificar que no haya citas futuras en este horario
            const [citasFuturas] = await sequelize.query(`
                SELECT COUNT(*) as count FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha > CURDATE()
                AND estado IN ('programada', 'confirmada')
                AND DAYOFWEEK(fecha) = ?
                AND TIME(hora) BETWEEN ? AND ?
            `, {
                replacements: [
                    disponibilidad.usuario_id,
                    disponibilidad.usuario_id,
                    this.diaSemanaANumero(disponibilidad.dia_semana),
                    disponibilidad.hora_inicio,
                    disponibilidad.hora_fin
                ],
                type: QueryTypes.SELECT
            });
            
            if (citasFuturas.count > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se puede desactivar la disponibilidad porque hay citas programadas en este horario'
                });
            }
            
            await disponibilidad.update({ activo: false });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'modificacion', 'disponibilidad', 'Desactivar disponibilidad', ?, NOW())
            `, {
                replacements: [usuarioId, `Disponibilidad desactivada ID: ${id}`]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad desactivada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en desactivarDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar disponibilidad'
            });
        }
    }
    
    static async obtenerHorariosDisponibles(req, res) {
        try {
            const { usuario_id, fecha } = req.query;
            
            if (!usuario_id || !fecha) {
                return res.status(400).json({
                    success: false,
                    message: 'Los parámetros usuario_id y fecha son requeridos'
                });
            }
            
            // Obtener día de la semana de la fecha
            const fechaObj = new Date(fecha);
            const diaSemana = this.numeroADiaSemana(fechaObj.getDay());
            
            // Obtener disponibilidad del usuario para ese día
            const [disponibilidad] = await sequelize.query(`
                SELECT * FROM disponibilidades
                WHERE usuario_id = ?
                AND dia_semana = ?
                AND activo = TRUE
                AND (fecha_fin_vigencia IS NULL OR fecha_fin_vigencia >= ?)
                AND (fecha_inicio_vigencia <= ?)
            `, {
                replacements: [usuario_id, diaSemana, fecha, fecha],
                type: QueryTypes.SELECT
            });
            
            if (!disponibilidad) {
                return res.json({
                    success: true,
                    data: {
                        disponible: false,
                        horarios: [],
                        mensaje: 'El profesional no tiene disponibilidad para esta fecha'
                    }
                });
            }
            
            // Obtener citas ya programadas para esa fecha
            const [citasProgramadas] = await sequelize.query(`
                SELECT hora, duracion_minutos
                FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha = ?
                AND estado IN ('programada', 'confirmada')
                ORDER BY hora
            `, {
                replacements: [usuario_id, usuario_id, fecha],
                type: QueryTypes.SELECT
            });
            
            // Generar horarios disponibles
            const horariosDisponibles = this.generarHorariosDisponibles(
                disponibilidad.hora_inicio,
                disponibilidad.hora_fin,
                disponibilidad.intervalo_citas,
                citasProgramadas || [],
                disponibilidad.max_citas_dia
            );
            
            res.json({
                success: true,
                data: {
                    disponible: true,
                    horarios: horariosDisponibles,
                    intervalo_minutos: disponibilidad.intervalo_citas,
                    max_citas_dia: disponibilidad.max_citas_dia,
                    citas_actuales: (citasProgramadas || []).length
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerHorariosDisponibles:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener horarios disponibles'
            });
        }
    }
    
    // Métodos auxiliares
    static validarHora(hora) {
        const regex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
        return regex.test(hora);
    }
    
    static compararHoras(hora1, hora2) {
        const [h1, m1] = hora1.split(':').map(Number);
        const [h2, m2] = hora2.split(':').map(Number);
        
        if (h1 !== h2) return h1 - h2;
        return m1 - m2;
    }
    
    static diaSemanaANumero(diaSemana) {
        const dias = {
            'domingo': 1,
            'lunes': 2,
            'martes': 3,
            'miercoles': 4,
            'jueves': 5,
            'viernes': 6,
            'sabado': 7
        };
        return dias[diaSemana.toLowerCase()] || 1;
    }
    
    static numeroADiaSemana(numero) {
        const dias = [
            'domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'
        ];
        return dias[numero] || 'domingo';
    }
    
    static async verificarPermisoVerDisponibilidad(solicitanteId, solicitanteRol, usuarioId) {
        if (solicitanteRol === 'coordinador') return true;
        
        if (solicitanteId === parseInt(usuarioId)) return true;
        
        if (solicitanteRol === 'psicologo') {
            // Verificar si es supervisor del usuario
            const [relacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE becario_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [usuarioId, solicitanteId],
                type: QueryTypes.SELECT
            });
            
            return !!relacion;
        }
        
        return false;
    }
    
    static generarHorariosDisponibles(horaInicio, horaFin, intervalo, citasProgramadas, maxCitas) {
        const horarios = [];
        const citasPorHora = {};
        
        // Mapear citas existentes por hora
        citasProgramadas.forEach(cita => {
            const hora = cita.hora.substring(0, 5); // Formato HH:MM
            citasPorHora[hora] = true;
        });
        
        // Si ya alcanzó el máximo de citas, no hay horarios disponibles
        if (citasProgramadas.length >= maxCitas) {
            return horarios;
        }
        
        // Generar horarios cada X minutos
        let [hora, minuto] = horaInicio.split(':').map(Number);
        
        while (true) {
            const horaStr = `${hora.toString().padStart(2, '0')}:${minuto.toString().padStart(2, '0')}`;
            const horaFinCalculada = this.sumarMinutos(horaStr, intervalo);
            
            // Si pasa de la hora de fin, terminar
            if (this.compararHoras(horaFinCalculada, horaFin) > 0) {
                break;
            }
            
            // Si no hay cita en este horario, agregarlo
            if (!citasPorHora[horaStr]) {
                horarios.push({
                    hora: horaStr,
                    hora_fin: horaFinCalculada,
                    disponible: true
                });
            }
            
            // Avanzar intervalo
            minuto += intervalo;
            while (minuto >= 60) {
                hora += 1;
                minuto -= 60;
            }
        }
        
        return horarios;
    }
    
    static sumarMinutos(hora, minutos) {
        const [h, m] = hora.split(':').map(Number);
        let nuevaHora = h;
        let nuevosMinutos = m + minutos;
        
        while (nuevosMinutos >= 60) {
            nuevaHora += 1;
            nuevosMinutos -= 60;
        }
        
        return `${nuevaHora.toString().padStart(2, '0')}:${nuevosMinutos.toString().padStart(2, '0')}`;
    }
}

module.exports = DisponibilidadController;

/src\controllers\estadisticaController.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class EstadisticaController {
    
    static async obtenerEstadisticasGenerales(req, res) {
        try {
            const { fecha_inicio, fecha_fin } = req.query;
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'WHERE fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'WHERE fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'WHERE fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estadísticas de citas
            const [estadisticasCitas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                    SUM(CASE WHEN estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud,
                    ROUND(SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_cancelacion,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    ROUND(AVG(duracion_minutos), 1) as duracion_promedio
                FROM citas
                ${condicionesFecha}
            `, { replacements, type: QueryTypes.SELECT });
            
            // Estadísticas de pacientes
            const [estadisticasPacientes] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_pacientes,
                    SUM(CASE WHEN activo = TRUE THEN 1 ELSE 0 END) as pacientes_activos,
                    SUM(CASE WHEN activo = FALSE THEN 1 ELSE 0 END) as pacientes_inactivos,
                    COUNT(DISTINCT genero) as generos_unicos,
                    ROUND(AVG(YEAR(CURDATE()) - YEAR(fecha_nacimiento)), 1) as edad_promedio,
                    (SELECT COUNT(*) FROM altas ${condicionesFecha.replace('fecha', 'fecha_alta')}) as altas_totales
                FROM pacientes
            `, { replacements, type: QueryTypes.SELECT });
            
            // Distribución por género
            const distribucionGenero = await sequelize.query(`
                SELECT 
                    COALESCE(genero, 'no especificado') as genero,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM pacientes
                GROUP BY genero
                ORDER BY cantidad DESC
            `, { type: QueryTypes.SELECT });
            
            // Evolución mensual
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha, '%Y-%m') as mes,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos
                FROM citas
                ${condicionesFecha ? condicionesFecha.replace('fecha', 'fecha') : 'WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 12
            `, { replacements, type: QueryTypes.SELECT });
            
            // Top psicólogos por productividad
            const topPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    u.especialidad,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id ${condicionesFecha ? `AND ${condicionesFecha.replace('WHERE', '')}` : ''}
                WHERE u.rol = 'psicologo' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido, u.especialidad
                ORDER BY citas_completadas DESC
                LIMIT 10
            `, { replacements, type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    citas: estadisticasCitas,
                    pacientes: estadisticasPacientes,
                    distribucion_genero: distribucionGenero,
                    evolucion_mensual: evolucionMensual.reverse(),
                    top_psicologos: topPsicologos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasGenerales:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas generales'
            });
        }
    }
    
    static async obtenerEstadisticasPsicologo(req, res) {
        try {
            const { psicologo_id, fecha_inicio, fecha_fin } = req.query;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            let psicologoConsulta = psicologo_id;
            if (!psicologoConsulta && usuarioRol === 'psicologo') {
                psicologoConsulta = usuarioId;
            } else if (!psicologoConsulta) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere especificar un psicólogo'
                });
            }
            
            // Verificar que el psicólogo existe
            const [psicologo] = await sequelize.query(
                'SELECT id, nombre, apellido, especialidad FROM users WHERE id = ? AND rol = "psicologo"',
                { replacements: [psicologoConsulta], type: QueryTypes.SELECT }
            );
            
            if (!psicologo) {
                return res.status(404).json({
                    success: false,
                    message: 'Psicólogo no encontrado'
                });
            }
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [psicologoConsulta];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'AND c.fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'AND c.fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'AND c.fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estadísticas generales del psicólogo
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE psicologo_id = ? AND estado = 'activa') as pacientes_activos,
                    
                    -- Sesiones
                    COUNT(s.id) as sesiones_registradas,
                    ROUND(AVG(TIMESTAMPDIFF(MINUTE, s.hora_inicio, s.hora_fin)), 1) as duracion_promedio_sesiones,
                    
                    -- Becarios supervisados
                    COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                    
                    -- Observaciones
                    COUNT(ob.id) as observaciones_realizadas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion_observaciones,
                    
                    -- Altas
                    COUNT(al.id) as altas_realizadas,
                    SUM(CASE WHEN al.tipo_alta = 'terapeutica' THEN 1 ELSE 0 END) as altas_terapeuticas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id ${condicionesFecha}
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
                LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id
                LEFT JOIN altas al ON u.id = al.usuario_id ${condicionesFecha.replace('c.fecha', 'al.fecha_alta')}
                WHERE u.id = ?
                GROUP BY u.id
            `, { replacements, type: QueryTypes.SELECT });
            
            // Evolución mensual
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    COUNT(s.id) as sesiones_registradas,
                    COUNT(al.id) as altas_realizadas
                FROM citas c
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN altas al ON c.paciente_id = al.paciente_id AND DATE_FORMAT(al.fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')
                WHERE c.psicologo_id = ?
                ${condicionesFecha ? condicionesFecha : 'AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [psicologoConsulta, ...(condicionesFecha ? replacements.slice(1) : [])], type: QueryTypes.SELECT });
            
            // Distribución por tipo de consulta
            const distribucionConsulta = await sequelize.query(`
                SELECT 
                    c.tipo_consulta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM citas c
                WHERE c.psicologo_id = ?
                ${condicionesFecha}
                GROUP BY c.tipo_consulta
                ORDER BY cantidad DESC
            `, { replacements, type: QueryTypes.SELECT });
            
            // Pacientes con más sesiones
            const pacientesTop = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    COUNT(c.id) as total_sesiones,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    AVG(c.duracion_minutos) as duracion_promedio
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.psicologo_id = ?
                AND c.estado = 'completada'
                ${condicionesFecha}
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY total_sesiones DESC
                LIMIT 10
            `, { replacements, type: QueryTypes.SELECT });
            
            // Horarios más productivos
            const horariosProductivos = await sequelize.query(`
                SELECT 
                    HOUR(c.hora) as hora,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE c.psicologo_id = ?
                ${condicionesFecha}
                GROUP BY HOUR(c.hora)
                ORDER BY total_citas DESC
                LIMIT 8
            `, { replacements, type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    psicologo,
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    estadisticas: estadisticas || {},
                    evolucion_mensual: evolucionMensual.reverse(),
                    distribucion_consulta: distribucionConsulta,
                    pacientes_top: pacientesTop,
                    horarios_productivos: horariosProductivos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasPsicologo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas del psicólogo'
            });
        }
    }
    
    static async obtenerEstadisticasBecario(req, res) {
        try {
            const { becario_id, fecha_inicio, fecha_fin } = req.query;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            let becarioConsulta = becario_id;
            if (!becarioConsulta && usuarioRol === 'becario') {
                becarioConsulta = usuarioId;
            } else if (!becarioConsulta) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere especificar un becario'
                });
            }
            
            // Verificar que el becario existe
            const [becario] = await sequelize.query(
                'SELECT id, nombre, apellido FROM users WHERE id = ? AND rol = "becario"',
                { replacements: [becarioConsulta], type: QueryTypes.SELECT }
            );
            
            if (!becario) {
                return res.status(404).json({
                    success: false,
                    message: 'Becario no encontrado'
                });
            }
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [becarioConsulta];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'AND c.fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'AND c.fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'AND c.fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estadísticas generales del becario
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE becario_id = ? AND estado = 'activa') as pacientes_activos,
                    
                    -- Observaciones recibidas
                    COUNT(ob.id) as observaciones_recibidas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    
                    -- Supervisor
                    (SELECT CONCAT(u.nombre, ' ', u.apellido) FROM asignaciones a 
                     JOIN users u ON a.psicologo_id = u.id 
                     WHERE a.becario_id = ? AND a.estado = 'activa' LIMIT 1) as supervisor,
                    
                    -- Disponibilidad
                    (SELECT COUNT(*) FROM disponibilidades WHERE usuario_id = ? AND activo = TRUE) as horarios_configurados,
                    
                    -- Tiempo promedio entre citas
                    ROUND(AVG(DATEDIFF(
                        (SELECT MIN(c2.fecha) FROM citas c2 
                         WHERE c2.becario_id = c.becario_id 
                         AND c2.paciente_id = c.paciente_id 
                         AND c2.id > c.id),
                        c.fecha
                    )), 1) as dias_promedio_entre_citas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.becario_id ${condicionesFecha}
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                WHERE u.id = ?
                GROUP BY u.id
            `, { replacements: [...replacements, becarioConsulta, becarioConsulta], type: QueryTypes.SELECT });
            
            // Evolución de calificaciones
            const evolucionCalificaciones = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(ob.fecha, '%Y-%m') as mes,
                    COUNT(ob.id) as total_observaciones,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima
                FROM observaciones_becarios ob
                WHERE ob.becario_id = ?
                ${condicionesFecha ? condicionesFecha.replace('c.fecha', 'ob.fecha') : 'AND ob.fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(ob.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [becarioConsulta, ...(condicionesFecha ? replacements.slice(1) : [])], type: QueryTypes.SELECT });
            
            // Distribución por aspecto evaluado
            const distribucionAspectos = await sequelize.query(`
                SELECT 
                    ob.aspecto_evaluado,
                    COUNT(*) as cantidad,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM observaciones_becarios ob
                WHERE ob.becario_id = ?
                ${condicionesFecha ? condicionesFecha.replace('c.fecha', 'ob.fecha') : ''}
                GROUP BY ob.aspecto_evaluado
                ORDER BY cantidad DESC
            `, { replacements, type: QueryTypes.SELECT });
            
            // Citas por día de la semana
            const citasPorDia = await sequelize.query(`
                SELECT 
                    DAYNAME(c.fecha) as dia_semana,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE c.becario_id = ?
                ${condicionesFecha}
                GROUP BY DAYNAME(c.fecha), DAYOFWEEK(c.fecha)
                ORDER BY DAYOFWEEK(c.fecha)
            `, { replacements, type: QueryTypes.SELECT });
            
            // Pacientes atendidos
            const pacientesAtendidos = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    COUNT(c.id) as total_sesiones,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    (SELECT COUNT(*) FROM sesiones s 
                     JOIN citas c2 ON s.cita_id = c2.id 
                     WHERE c2.paciente_id = p.id AND c2.becario_id = ?) as sesiones_registradas
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.estado = 'completada'
                ${condicionesFecha}
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY total_sesiones DESC
                LIMIT 10
            `, { replacements: [becarioConsulta, ...replacements], type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    becario,
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    estadisticas: estadisticas || {},
                    evolucion_calificaciones: evolucionCalificaciones.reverse(),
                    distribucion_aspectos: distribucionAspectos,
                    citas_por_dia: citasPorDia,
                    pacientes_atendidos: pacientesAtendidos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas del becario'
            });
        }
    }
    
    static async obtenerEstadisticasPaciente(req, res) {
        try {
            const { paciente_id } = req.params;
            
            // Verificar que el paciente existe
            const [paciente] = await sequelize.query(
                'SELECT id, nombre, apellido, fecha_nacimiento, genero FROM pacientes WHERE id = ?',
                { replacements: [paciente_id], type: QueryTypes.SELECT }
            );
            
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Estadísticas del paciente
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_asistencia,
                    
                    -- Tiempo
                    MIN(c.fecha) as primera_cita,
                    MAX(c.fecha) as ultima_cita,
                    DATEDIFF(MAX(c.fecha), MIN(c.fecha)) as dias_tratamiento,
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                    
                    -- Profesionales
                    COUNT(DISTINCT c.psicologo_id) as psicologos_atendieron,
                    COUNT(DISTINCT c.becario_id) as becarios_atendieron,
                    
                    -- Sesiones registradas
                    COUNT(s.id) as sesiones_registradas,
                    
                    -- Asignaciones
                    COUNT(DISTINCT a.id) as total_asignaciones,
                    (SELECT COUNT(*) FROM asignaciones WHERE paciente_id = ? AND estado = 'activa') as asignaciones_activas,
                    
                    -- Altas
                    (SELECT tipo_alta FROM altas WHERE paciente_id = ? ORDER BY fecha_alta DESC LIMIT 1) as ultimo_tipo_alta
                    
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON p.id = a.paciente_id
                WHERE p.id = ?
                GROUP BY p.id
            `, { replacements: [paciente_id, paciente_id, paciente_id], type: QueryTypes.SELECT });
            
            // Evolución de citas
            const evolucionCitas = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    GROUP_CONCAT(
                        CONCAT(
                            DAY(c.fecha), ': ',
                            CASE c.estado 
                                WHEN 'completada' THEN '✓'
                                WHEN 'cancelada' THEN '✗'
                                ELSE '○'
                            END
                        ) 
                        ORDER BY c.fecha 
                        SEPARATOR ', '
                    ) as detalle_dias
                FROM citas c
                WHERE c.paciente_id = ?
                GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            // Distribución por psicólogo
            const distribucionPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    u.especialidad,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    MIN(c.fecha) as primera_cita,
                    MAX(c.fecha) as ultima_cita
                FROM citas c
                JOIN users u ON c.psicologo_id = u.id
                WHERE c.paciente_id = ?
                GROUP BY u.id, u.nombre, u.apellido, u.especialidad
                ORDER BY total_citas DESC
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            // Frecuencia de citas
            const frecuenciaCitas = await sequelize.query(`
                SELECT 
                    CONCAT(
                        CASE 
                            WHEN dias BETWEEN 0 AND 7 THEN '1 semana o menos'
                            WHEN dias BETWEEN 8 AND 14 THEN '2 semanas'
                            WHEN dias BETWEEN 15 AND 21 THEN '3 semanas'
                            WHEN dias BETWEEN 22 AND 30 THEN '4 semanas'
                            ELSE 'Más de 1 mes'
                        END
                    ) as intervalo,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM (
                    SELECT 
                        DATEDIFF(
                            c2.fecha,
                            (SELECT MAX(c3.fecha) FROM citas c3 
                             WHERE c3.paciente_id = c.paciente_id 
                             AND c3.id < c2.id)
                        ) as dias
                    FROM citas c2
                    WHERE c2.paciente_id = ?
                    AND c2.estado = 'completada'
                    ORDER BY c2.fecha
                ) as intervalos
                WHERE dias IS NOT NULL
                GROUP BY 
                    CASE 
                        WHEN dias BETWEEN 0 AND 7 THEN '1 semana o menos'
                        WHEN dias BETWEEN 8 AND 14 THEN '2 semanas'
                        WHEN dias BETWEEN 15 AND 21 THEN '3 semanas'
                        WHEN dias BETWEEN 22 AND 30 THEN '4 semanas'
                        ELSE 'Más de 1 mes'
                    END
                ORDER BY cantidad DESC
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    paciente,
                    estadisticas: estadisticas || {},
                    evolucion_citas: evolucionCitas.reverse(),
                    distribucion_psicologos: distribucionPsicologos,
                    frecuencia_citas: frecuenciaCitas,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estadísticas del paciente'
            });
        }
    }
    
    static async obtenerReporteComparativo(req, res) {
        try {
            const { periodo = 'mes', tipo_comparacion = 'psicologos' } = req.query;
            
            let intervalo;
            switch (periodo) {
                case 'semana':
                    intervalo = 'INTERVAL 7 DAY';
                    break;
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            let reporte;
            
            if (tipo_comparacion === 'psicologos') {
                reporte = await this.generarComparativoPsicologos(intervalo);
            } else if (tipo_comparacion === 'becarios') {
                reporte = await this.generarComparativoBecarios(intervalo);
            } else if (tipo_comparacion === 'meses') {
                reporte = await this.generarComparativoMeses(intervalo);
            } else {
                return res.status(400).json({
                    success: false,
                    message: 'Tipo de comparación no válido'
                });
            }
            
            res.json({
                success: true,
                data: {
                    tipo_comparacion,
                    periodo,
                    reporte,
                    fecha_generacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerReporteComparativo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte comparativo'
            });
        }
    }
    
    // Métodos auxiliares para comparativos
    static async generarComparativoPsicologos(intervalo) {
        return await sequelize.query(`
            SELECT 
                u.id,
                CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                u.especialidad,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                COUNT(s.id) as sesiones_registradas,
                COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                COUNT(ob.id) as observaciones_realizadas
            FROM users u
            LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            LEFT JOIN sesiones s ON c.id = s.cita_id
            LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
            LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id AND ob.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            WHERE u.rol = 'psicologo' AND u.activo = TRUE
            GROUP BY u.id, u.nombre, u.apellido, u.especialidad
            ORDER BY citas_completadas DESC
        `, { type: QueryTypes.SELECT });
    }
    
    static async generarComparativoBecarios(intervalo) {
        return await sequelize.query(`
            SELECT 
                u.id,
                CONCAT(u.nombre, ' ', u.apellido) as becario,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                COUNT(ob.id) as observaciones_recibidas,
                ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                (SELECT CONCAT(u2.nombre, ' ', u2.apellido) FROM asignaciones a 
                 JOIN users u2 ON a.psicologo_id = u2.id 
                 WHERE a.becario_id = u.id AND a.estado = 'activa' LIMIT 1) as supervisor
            FROM users u
            LEFT JOIN citas c ON u.id = c.becario_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id AND ob.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            WHERE u.rol = 'becario' AND u.activo = TRUE
            GROUP BY u.id, u.nombre, u.apellido
            ORDER BY citas_completadas DESC
        `, { type: QueryTypes.SELECT });
    }
    
    static async generarComparativoMeses(intervalo) {
        return await sequelize.query(`
            SELECT 
                DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                COUNT(DISTINCT c.psicologo_id) as psicologos_activos,
                COUNT(DISTINCT c.becario_id) as becarios_activos,
                COUNT(s.id) as sesiones_registradas,
                COUNT(a.id) as altas_realizadas
            FROM citas c
            LEFT JOIN sesiones s ON c.id = s.cita_id
            LEFT JOIN altas a ON c.paciente_id = a.paciente_id AND DATE_FORMAT(a.fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')
            WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
            ORDER BY mes DESC
        `, { type: QueryTypes.SELECT });
    }
}

module.exports = EstadisticaController;

/src\controllers\expedienteController.js:
--------------------------------------------------------------------------------
const Expediente = require('../models/expedienteModel');
const Paciente = require('../models/pacienteModel');
const Sesion = require('../models/sesionModel');
const Cita = require('../models/citaModel');
const Asignacion = require('../models/asignacionModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class ExpedienteController {
    
    static async obtenerExpedienteCompleto(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tieneAcceso = await this.verificarAccesoExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para acceder a este expediente'
                });
            }
            
            // Obtener información básica del paciente
            const paciente = await Paciente.findByPk(paciente_id, {
                attributes: { exclude: ['password'] }
            });
            
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Obtener expediente clínico
            const expediente = await Expediente.findOne({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    }
                ]
            });
            
            // Obtener asignación actual
            const asignacion = await Asignacion.findOne({
                where: {
                    paciente_id,
                    estado: 'activa'
                },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ]
            });
            
            // Obtener historial de sesiones
            const sesiones = await Sesion.findAll({
                where: { '$Cita.paciente_id$': paciente_id },
                include: [
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora', 'tipo_consulta']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha', 'DESC'], ['hora_inicio', 'DESC']],
                limit: 20
            });
            
            // Obtener citas futuras
            const citasFuturas = await Cita.findAll({
                where: {
                    paciente_id,
                    fecha: { [sequelize.Op.gte]: new Date().toISOString().split('T')[0] },
                    estado: { [sequelize.Op.in]: ['programada', 'confirmada'] }
                },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha', 'ASC'], ['hora', 'ASC']]
            });
            
            // Obtener estadísticas
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_sesiones,
                    COUNT(CASE WHEN c.estado = 'completada' THEN 1 END) as sesiones_completadas,
                    COUNT(CASE WHEN c.estado = 'cancelada' THEN 1 END) as sesiones_canceladas,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    AVG(TIMESTAMPDIFF(MINUTE, s.hora_inicio, s.hora_fin)) as duracion_promedio
                FROM citas c
                LEFT JOIN sesiones s ON c.id = s.cita_id
                WHERE c.paciente_id = ?
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Obtener historial de asignaciones
            const historialAsignaciones = await Asignacion.findAll({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            // Obtener altas si las hay
            const [altas] = await sequelize.query(`
                SELECT * FROM altas WHERE paciente_id = ? ORDER BY fecha_alta DESC LIMIT 1
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    paciente,
                    expediente: expediente || {},
                    asignacion_actual: asignacion || null,
                    sesiones,
                    citas_futuras: citasFuturas,
                    estadisticas: estadisticas || {},
                    historial_asignaciones: historialAsignaciones,
                    alta: altas || null
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerExpedienteCompleto:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener expediente completo'
            });
        }
    }
    
    static async crearExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const expedienteData = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el paciente existe
            const paciente = await Paciente.findByPk(paciente_id);
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Verificar que no exista ya un expediente
            const expedienteExistente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (expedienteExistente) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe un expediente para este paciente'
                });
            }
            
            // Crear expediente
            const expediente = await Expediente.create({
                paciente_id,
                ...expedienteData
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'expedientes', 'Crear expediente', ?, NOW())
            `, {
                replacements: [usuarioId, `Expediente creado para paciente ${paciente_id}`]
            });
            
            res.json({
                success: true,
                message: 'Expediente creado exitosamente',
                data: expediente
            });
            
        } catch (error) {
            console.error('Error en crearExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear expediente'
            });
        }
    }
    
    static async actualizarExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const puedeActualizar = await this.verificarPermisoActualizarExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!puedeActualizar) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar este expediente'
                });
            }
            
            const expediente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (!expediente) {
                return res.status(404).json({
                    success: false,
                    message: 'Expediente no encontrado'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...expediente.toJSON() };
            
            await expediente.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'expedientes', 'Actualizar expediente', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Expediente actualizado para paciente ${paciente_id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(expediente.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Expediente actualizado exitosamente',
                data: expediente
            });
            
        } catch (error) {
            console.error('Error en actualizarExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar expediente'
            });
        }
    }
    
    static async agregarNotaConfidencial(req, res) {
        try {
            const { paciente_id } = req.params;
            const { nota } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el usuario es psicólogo asignado
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [paciente_id, usuarioId],
                type: QueryTypes.SELECT
            });
            
            if (!asignacion && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'Solo el psicólogo asignado puede agregar notas confidenciales'
                });
            }
            
            const expediente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (!expediente) {
                return res.status(404).json({
                    success: false,
                    message: 'Expediente no encontrado'
                });
            }
            
            // Agregar nota con timestamp
            const fecha = new Date().toLocaleString('es-MX');
            const nuevaNota = `[${fecha}] ${usuarioId}: ${nota}\n\n`;
            const notasActuales = expediente.notas_confidenciales || '';
            
            await expediente.update({
                notas_confidenciales: nuevaNota + notasActuales
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'modificacion', 'expedientes', 'Agregar nota confidencial', ?, NOW())
            `, {
                replacements: [usuarioId, `Nota confidencial agregada para paciente ${paciente_id}`]
            });
            
            res.json({
                success: true,
                message: 'Nota confidencial agregada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en agregarNotaConfidencial:', error);
            res.status(500).json({
                success: false,
                message: 'Error al agregar nota confidencial'
            });
        }
    }
    
    static async obtenerResumenExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos básicos
            const tieneAcceso = await this.verificarAccesoExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para acceder a este expediente'
                });
            }
            
            const [resumen] = await sequelize.query(`
                SELECT 
                    p.id,
                    p.nombre,
                    p.apellido,
                    p.fecha_nacimiento,
                    p.genero,
                    p.telefono,
                    p.email,
                    p.estado,
                    e.motivo_consulta,
                    e.diagnostico_presuntivo,
                    e.riesgo_suicida,
                    a.psicologo_id,
                    u_psi.nombre as psicologo_nombre,
                    u_psi.apellido as psicologo_apellido,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'completada') as sesiones_completadas,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'programada' AND fecha >= CURDATE()) as citas_pendientes,
                    (SELECT MAX(fecha) FROM citas WHERE paciente_id = p.id AND estado = 'completada') as ultima_sesion
                FROM pacientes p
                LEFT JOIN expedientes e ON p.id = e.paciente_id
                LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
                LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
                WHERE p.id = ?
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            if (!resumen) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            res.json({
                success: true,
                data: resumen
            });
            
        } catch (error) {
            console.error('Error en obtenerResumenExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener resumen de expediente'
            });
        }
    }
    
    // Métodos auxiliares
    static async verificarAccesoExpediente(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        // Verificar si el usuario está asignado al paciente
        const [asignacion] = await sequelize.query(`
            SELECT 1 FROM asignaciones 
            WHERE paciente_id = ? 
            AND estado = 'activa'
            AND (psicologo_id = ? OR becario_id = ?)
        `, {
            replacements: [pacienteId, usuarioId, usuarioId],
            type: QueryTypes.SELECT
        });
        
        return !!asignacion;
    }
    
    static async verificarPermisoActualizarExpediente(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            // Verificar si es el psicólogo asignado
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
            `, {
                replacements: [pacienteId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!asignacion;
        }
        
        return false;
    }
}

module.exports = ExpedienteController;

/src\controllers\fundacionController.js:
--------------------------------------------------------------------------------
const Fundacion = require('../models/fundacionModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class FundacionController {
    
    static async crearFundacion(req, res) {
        try {
            const fundacionData = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.create(fundacionData);
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                 VALUES (?, 'creacion', 'fundaciones', 'Crear fundación', ?, NOW())`,
                { replacements: [usuarioId, `Nueva fundación: ${fundacion.nombre}`] }
            );
            
            res.json({
                success: true,
                message: 'Fundación creada exitosamente',
                data: fundacion
            });
            
        } catch (error) {
            console.error('Error en crearFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear fundación',
                error: error.message
            });
        }
    }
    
    static async obtenerFundaciones(req, res) {
        try {
            const { activo } = req.query;
            const whereClause = {};
            
            if (activo !== undefined) {
                whereClause.activo = activo === 'true';
            }
            
            const fundaciones = await Fundacion.findAll({
                where: whereClause,
                order: [['nombre', 'ASC']]
            });
            
            res.json({
                success: true,
                data: fundaciones,
                count: fundaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerFundaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener fundaciones'
            });
        }
    }
    
    static async obtenerFundacion(req, res) {
        try {
            const { id } = req.params;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundación no encontrada'
                });
            }
            
            // Obtener estadísticas de la fundación
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(DISTINCT p.id) AS total_pacientes,
                    COUNT(DISTINCT u.id) AS total_profesionales,
                    COUNT(DISTINCT c.id) AS citas_mes_actual,
                    (SELECT COUNT(*) FROM altas a 
                     JOIN pacientes p ON a.paciente_id = p.id 
                     WHERE p.fundacion_id = :fundacionId 
                     AND MONTH(a.fecha_alta) = MONTH(CURDATE())) AS altas_mes_actual
                FROM fundaciones f
                LEFT JOIN pacientes p ON f.id = p.fundacion_id AND p.activo = TRUE
                LEFT JOIN users u ON f.id = u.fundacion_id AND u.activo = TRUE
                LEFT JOIN citas c ON p.id = c.paciente_id 
                    AND MONTH(c.fecha) = MONTH(CURDATE())
                WHERE f.id = :fundacionId
                GROUP BY f.id
            `, {
                replacements: { fundacionId: id },
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    fundacion: fundacion,
                    estadisticas: estadisticas || {}
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener fundación'
            });
        }
    }
    
    static async actualizarFundacion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundación no encontrada'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...fundacion.toJSON() };
            
            await fundacion.update(updates);
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                 VALUES (?, 'modificacion', 'fundaciones', 'Actualizar fundación', ?, ?, ?, NOW())`,
                { 
                    replacements: [
                        usuarioId, 
                        `Fundación actualizada: ${fundacion.nombre}`,
                        JSON.stringify(datosAntes),
                        JSON.stringify(fundacion.toJSON())
                    ] 
                }
            );
            
            res.json({
                success: true,
                message: 'Fundación actualizada exitosamente',
                data: fundacion
            });
            
        } catch (error) {
            console.error('Error en actualizarFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar fundación'
            });
        }
    }
    
    static async desactivarFundacion(req, res) {
        try {
            const { id } = req.params;
            const { motivo } = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundación no encontrada'
                });
            }
            
            // Verificar que no haya pacientes activos
            const [pacientesActivos] = await sequelize.query(
                `SELECT COUNT(*) as count FROM pacientes WHERE fundacion_id = ? AND activo = TRUE`,
                { replacements: [id], type: QueryTypes.SELECT }
            );
            
            if (pacientesActivos.count > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se puede desactivar la fundación porque tiene pacientes activos'
                });
            }
            
            await fundacion.update({ activo: false });
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                 VALUES (?, 'modificacion', 'fundaciones', 'Desactivar fundación', ?, NOW())`,
                { 
                    replacements: [
                        usuarioId, 
                        `Fundación desactivada: ${fundacion.nombre}. Motivo: ${motivo}`
                    ] 
                }
            );
            
            res.json({
                success: true,
                message: 'Fundación desactivada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en desactivarFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar fundación'
            });
        }
    }
}

module.exports = FundacionController;

/src\controllers\notificacionController.js:
--------------------------------------------------------------------------------
const Notificacion = require('../models/notificacionModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class NotificacionController {
    
    static async obtenerMisNotificaciones(req, res) {
        try {
            const usuarioId = req.user.id;
            const { leido, limit = 50, offset = 0 } = req.query;
            
            const whereClause = { usuario_id: usuarioId };
            
            if (leido !== undefined) {
                whereClause.leido = leido === 'true';
            }
            
            const notificaciones = await Notificacion.findAll({
                where: whereClause,
                order: [['created_at', 'DESC']],
                limit: parseInt(limit),
                offset: parseInt(offset)
            });
            
            // Contar no leídas
            const countNoLeidas = await Notificacion.count({
                where: { usuario_id: usuarioId, leido: false }
            });
            
            res.json({
                success: true,
                data: notificaciones,
                count: notificaciones.length,
                countNoLeidas,
                total: await Notificacion.count({ where: { usuario_id: usuarioId } })
            });
            
        } catch (error) {
            console.error('Error en obtenerMisNotificaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener notificaciones'
            });
        }
    }
    
    static async marcarComoLeido(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const notificacion = await Notificacion.findOne({
                where: { id, usuario_id: usuarioId }
            });
            
            if (!notificacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Notificación no encontrada'
                });
            }
            
            await notificacion.update({
                leido: true,
                leido_at: new Date()
            });
            
            res.json({
                success: true,
                message: 'Notificación marcada como leída'
            });
            
        } catch (error) {
            console.error('Error en marcarComoLeido:', error);
            res.status(500).json({
                success: false,
                message: 'Error al marcar notificación como leída'
            });
        }
    }
    
    static async marcarTodasComoLeidas(req, res) {
        try {
            const usuarioId = req.user.id;
            
            await Notificacion.update(
                { leido: true, leido_at: new Date() },
                { where: { usuario_id: usuarioId, leido: false } }
            );
            
            res.json({
                success: true,
                message: 'Todas las notificaciones marcadas como leídas'
            });
            
        } catch (error) {
            console.error('Error en marcarTodasComoLeidas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al marcar notificaciones como leídas'
            });
        }
    }
    
    static async crearNotificacion(req, res) {
        try {
            const { usuario_id, tipo, titulo, mensaje, prioridad, datos_extra } = req.body;
            const creadorId = req.user.id;
            
            // Validar que el usuario receptor existe
            const [usuario] = await sequelize.query(
                'SELECT id FROM users WHERE id = ? AND activo = TRUE',
                { replacements: [usuario_id], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario receptor no encontrado o inactivo'
                });
            }
            
            const notificacion = await Notificacion.create({
                usuario_id,
                tipo,
                titulo,
                mensaje,
                prioridad: prioridad || 'media',
                datos_extra: datos_extra || null
            });
            
            res.json({
                success: true,
                message: 'Notificación creada exitosamente',
                data: notificacion
            });
            
        } catch (error) {
            console.error('Error en crearNotificacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear notificación'
            });
        }
    }
    
    static async eliminarNotificacion(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const notificacion = await Notificacion.findOne({
                where: { id, usuario_id: usuarioId }
            });
            
            if (!notificacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Notificación no encontrada'
                });
            }
            
            await notificacion.destroy();
            
            res.json({
                success: true,
                message: 'Notificación eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en eliminarNotificacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar notificación'
            });
        }
    }
    
    static async obtenerNotificacionesRecientes(req, res) {
        try {
            const usuarioId = req.user.id;
            const horas = parseInt(req.query.horas) || 24;
            
            const notificaciones = await Notificacion.findAll({
                where: {
                    usuario_id: usuarioId,
                    created_at: {
                        [sequelize.Op.gte]: new Date(Date.now() - horas * 60 * 60 * 1000)
                    }
                },
                order: [['created_at', 'DESC']],
                limit: 20
            });
            
            res.json({
                success: true,
                data: notificaciones,
                count: notificaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerNotificacionesRecientes:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener notificaciones recientes'
            });
        }
    }
    
    // Método para enviar notificación de sistema
    static async enviarNotificacionSistema(usuarioId, tipo, titulo, mensaje, datosExtra = null) {
        try {
            await Notificacion.create({
                usuario_id: usuarioId,
                tipo,
                titulo,
                mensaje,
                prioridad: 'media',
                datos_extra: datosExtra
            });
            
            return true;
        } catch (error) {
            console.error('Error al enviar notificación de sistema:', error);
            return false;
        }
    }
}

module.exports = NotificacionController;

/src\controllers\observacionController.js:
--------------------------------------------------------------------------------
const ObservacionBecario = require('../models/observacionBecarioModel');
const User = require('../models/userModel');
const Cita = require('../models/citaModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class ObservacionController {
    
    static async crearObservacion(req, res) {
        try {
            const { becario_id, cita_id, tipo_observacion, aspecto_evaluado, 
                    calificacion, fortalezas, areas_mejora, recomendaciones, 
                    plan_accion, fecha_seguimiento, privada } = req.body;
            const supervisorId = req.user.id;
            
            // Verificar que el supervisor es psicólogo o coordinador
            const supervisor = await User.findByPk(supervisorId);
            if (!['psicologo', 'coordinador'].includes(supervisor.rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo psicólogos y coordinadores pueden crear observaciones'
                });
            }
            
            // Verificar que el becario existe y es becario
            const becario = await User.findOne({
                where: { id: becario_id, rol: 'becario', activo: true }
            });
            
            if (!becario) {
                return res.status(404).json({
                    success: false,
                    message: 'Becario no encontrado o inactivo'
                });
            }
            
            // Verificar que la cita existe si se especifica
            if (cita_id) {
                const cita = await Cita.findByPk(cita_id);
                if (!cita) {
                    return res.status(404).json({
                        success: false,
                        message: 'Cita no encontrada'
                    });
                }
                
                // Verificar que el becario está asignado a la cita
                if (cita.becario_id !== parseInt(becario_id)) {
                    return res.status(400).json({
                        success: false,
                        message: 'El becario no está asignado a esta cita'
                    });
                }
            }
            
            // Crear observación
            const observacion = await ObservacionBecario.create({
                becario_id,
                supervisor_id: supervisorId,
                cita_id,
                fecha: new Date().toISOString().split('T')[0],
                tipo_observacion,
                aspecto_evaluado,
                calificacion,
                fortalezas,
                areas_mejora,
                recomendaciones,
                plan_accion,
                fecha_seguimiento,
                privada: privada || false
            });
            
            // Notificar al becario
            await sequelize.query(`
                INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                VALUES (?, 'observacion_nueva', 'Nueva observación', 
                'Tienes una nueva observación de tu supervisor. Revisa tu panel para más detalles.', NOW())
            `, { replacements: [becario_id] });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'observaciones', 'Crear observación', ?, NOW())
            `, {
                replacements: [supervisorId, `Observación creada para becario ${becario_id}`]
            });
            
            res.json({
                success: true,
                message: 'Observación creada exitosamente',
                data: observacion
            });
            
        } catch (error) {
            console.error('Error en crearObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear observación',
                error: error.message
            });
        }
    }
    
    static async obtenerObservacionesBecario(req, res) {
        try {
            const { becario_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tienePermisos = await this.verificarPermisosObservaciones(usuarioId, usuarioRol, becario_id);
            
            if (!tienePermisos) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver estas observaciones'
                });
            }
            
            const whereClause = { becario_id };
            
            // Si no es supervisor ni coordinador, solo mostrar no privadas o propias
            if (usuarioRol === 'becario' && parseInt(becario_id) !== usuarioId) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo puedes ver tus propias observaciones'
                });
            }
            
            // Si es becario viendo sus propias observaciones, filtrar privadas de otros
            if (usuarioRol === 'becario') {
                whereClause.privada = false;
            }
            
            const observaciones = await ObservacionBecario.findAll({
                where: whereClause,
                include: [
                    {
                        model: User,
                        as: 'Supervisor',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora'],
                        include: [{
                            model: require('../models/pacienteModel'),
                            attributes: ['id', 'nombre', 'apellido']
                        }]
                    }
                ],
                order: [['fecha', 'DESC'], ['created_at', 'DESC']]
            });
            
            // Calcular promedio de calificaciones
            const promedio = observaciones.length > 0 
                ? observaciones.reduce((sum, obs) => sum + obs.calificacion, 0) / observaciones.length
                : 0;
            
            res.json({
                success: true,
                data: {
                    observaciones,
                    estadisticas: {
                        total: observaciones.length,
                        promedio: promedio.toFixed(2),
                        porAspecto: this.agruparPorAspecto(observaciones)
                    }
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerObservacionesBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener observaciones'
            });
        }
    }
    
    static async obtenerObservacionesSupervisor(req, res) {
        try {
            const supervisorId = req.user.id;
            const { becario_id, fecha_inicio, fecha_fin } = req.query;
            
            const whereClause = { supervisor_id: supervisorId };
            
            if (becario_id) {
                whereClause.becario_id = becario_id;
            }
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [sequelize.Op.between]: [fecha_inicio, fecha_fin]
                };
            }
            
            const observaciones = await ObservacionBecario.findAll({
                where: whereClause,
                include: [
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    },
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora']
                    }
                ],
                order: [['fecha', 'DESC']]
            });
            
            // Agrupar por becario para estadísticas
            const estadisticasPorBecario = this.calcularEstadisticasPorBecario(observaciones);
            
            res.json({
                success: true,
                data: observaciones,
                estadisticas: estadisticasPorBecario
            });
            
        } catch (error) {
            console.error('Error en obtenerObservacionesSupervisor:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener observaciones'
            });
        }
    }
    
    static async actualizarObservacion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const observacion = await ObservacionBecario.findByPk(id);
            
            if (!observacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Observación no encontrada'
                });
            }
            
            // Verificar que es el supervisor creador
            if (observacion.supervisor_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'Solo el supervisor creador puede actualizar la observación'
                });
            }
            
            // Campos que no se pueden modificar
            const camposBloqueados = ['becario_id', 'supervisor_id', 'cita_id', 'fecha'];
            for (const campo of camposBloqueados) {
                if (updates[campo]) {
                    delete updates[campo];
                }
            }
            
            if (Object.keys(updates).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos válidos para actualizar'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...observacion.toJSON() };
            
            await observacion.update(updates);
            
            // Notificar al becario si hay cambios importantes
            if (updates.calificacion || updates.recomendaciones || updates.plan_accion) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'observacion_nueva', 'Observación actualizada', 
                    'Tu supervisor ha actualizado una observación. Revisa los cambios.', NOW())
                `, { replacements: [observacion.becario_id] });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'observaciones', 'Actualizar observación', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Observación actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(observacion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Observación actualizada exitosamente',
                data: observacion
            });
            
        } catch (error) {
            console.error('Error en actualizarObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar observación'
            });
        }
    }
    
    static async eliminarObservacion(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const observacion = await ObservacionBecario.findByPk(id);
            
            if (!observacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Observación no encontrada'
                });
            }
            
            // Solo coordinador o supervisor creador puede eliminar
            if (observacion.supervisor_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para eliminar esta observación'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...observacion.toJSON() };
            
            await observacion.destroy();
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, created_at)
                VALUES (?, 'eliminacion', 'observaciones', 'Eliminar observación', ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Observación eliminada ID: ${id}`,
                    JSON.stringify(datosAntes)
                ]
            });
            
            res.json({
                success: true,
                message: 'Observación eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en eliminarObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar observación'
            });
        }
    }
    
    // Métodos auxiliares
    static async verificarPermisosObservaciones(usuarioId, usuarioRol, becarioId) {
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            // Verificar si es supervisor del becario
            const [relacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE becario_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [becarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!relacion;
        }
        
        if (usuarioRol === 'becario') {
            return parseInt(becarioId) === usuarioId;
        }
        
        return false;
    }
    
    static agruparPorAspecto(observaciones) {
        const agrupado = {};
        
        observaciones.forEach(obs => {
            if (!agrupado[obs.aspecto_evaluado]) {
                agrupado[obs.aspecto_evaluado] = {
                    total: 0,
                    suma: 0,
                    promedio: 0
                };
            }
            
            agrupado[obs.aspecto_evaluado].total++;
            agrupado[obs.aspecto_evaluado].suma += obs.calificacion;
            agrupado[obs.aspecto_evaluado].promedio = 
                agrupado[obs.aspecto_evaluado].suma / agrupado[obs.aspecto_evaluado].total;
        });
        
        return agrupado;
    }
    
    static calcularEstadisticasPorBecario(observaciones) {
        const estadisticas = {};
        
        observaciones.forEach(obs => {
            if (!estadisticas[obs.becario_id]) {
                estadisticas[obs.becario_id] = {
                    becario_id: obs.becario_id,
                    becario_nombre: obs.Becario ? `${obs.Becario.nombre} ${obs.Becario.apellido}` : 'N/A',
                    total_observaciones: 0,
                    promedio_calificacion: 0,
                    suma_calificacion: 0,
                    aspectos_evaluados: new Set(),
                    ultima_observacion: null
                };
            }
            
            const stats = estadisticas[obs.becario_id];
            stats.total_observaciones++;
            stats.suma_calificacion += obs.calificacion;
            stats.promedio_calificacion = stats.suma_calificacion / stats.total_observaciones;
            stats.aspectos_evaluados.add(obs.aspecto_evaluado);
            
            if (!stats.ultima_observacion || new Date(obs.fecha) > new Date(stats.ultima_observacion)) {
                stats.ultima_observacion = obs.fecha;
            }
        });
        
        // Convertir Set a Array
        Object.keys(estadisticas).forEach(key => {
            estadisticas[key].aspectos_evaluados = Array.from(estadisticas[key].aspectos_evaluados);
        });
        
        return estadisticas;
    }
}

module.exports = ObservacionController;

/src\controllers\reporteController.js:
--------------------------------------------------------------------------------
// backend/src/controllers/reporteController.js - Añade este método
const { Parser } = require('json2csv');
const fs = require('fs');
const path = require('path');
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { Op } = require('sequelize');
const sequelize = require('../config/db');

class ReporteController {
    // Método para exportar agenda a CSV
    static async exportarAgendaCSV(req, res) {
        try {
            const { 
                fecha_inicio, 
                fecha_fin, 
                psicologo_id, 
                tipo_consulta 
            } = req.body;

            // Construir condiciones de filtro
            const whereClause = {};
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [Op.between]: [fecha_inicio, fecha_fin]
                };
            }
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (tipo_consulta) whereClause.tipo_consulta = tipo_consulta;

            // Obtener citas con información relacionada
            const citas = await Cita.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['nombre', 'apellido', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['nombre', 'apellido']
                    }
                ],
                order: [
                    ['fecha', 'ASC'],
                    ['hora', 'ASC']
                ]
            });

            // Preparar datos para CSV
            const datosCSV = citas.map(cita => ({
                Fecha: cita.fecha,
                Hora: cita.hora,
                'Duración (min)': cita.duracion,
                Paciente: cita.Paciente ? `${cita.Paciente.nombre} ${cita.Paciente.apellido}` : '',
                'Teléfono Paciente': cita.Paciente?.telefono || '',
                'Email Paciente': cita.Paciente?.email || '',
                Psicólogo: cita.Psicologo ? `${cita.Psicologo.nombre} ${cita.Psicologo.apellido}` : '',
                Especialidad: cita.Psicologo?.especialidad || '',
                Becario: cita.Becario ? `${cita.Becario.nombre} ${cita.Becario.apellido}` : '',
                'Tipo Consulta': cita.tipo_consulta === 'presencial' ? 'Presencial' : 'Virtual',
                Estado: cita.estado,
                Notas: cita.notas || '',
                'Motivo Cancelación': cita.motivo_cancelacion || ''
            }));

            // Convertir a CSV
            const json2csvParser = new Parser();
            const csv = json2csvParser.parse(datosCSV);

            // Crear nombre de archivo
            const fechaActual = new Date().toISOString().split('T')[0];
            const nombreArchivo = `agenda_${fecha_inicio || fechaActual}_a_${fecha_fin || fechaActual}.csv`;

            // Configurar headers para descarga
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="${nombreArchivo}"`);
            
            res.send(csv);

        } catch (error) {
            console.error('Error exportando agenda a CSV:', error);
            res.status(500).json({
                success: false,
                message: 'Error al exportar agenda',
                error: error.message
            });
        }
    }

    // Método para exportar disponibilidad a CSV
    static async exportarDisponibilidadCSV(req, res) {
        try {
            const { fecha } = req.body;
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            
            // Consulta de disponibilidad
            const disponibilidad = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    u.especialidad,
                    d.dia_semana,
                    TIME_FORMAT(d.hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(d.hora_fin, '%H:%i') as hora_fin,
                    d.max_citas_dia,
                    (SELECT COUNT(*) FROM citas c 
                     WHERE c.psicologo_id = u.id 
                     AND c.fecha = ? 
                     AND c.estado IN ('programada', 'confirmada')) as citas_programadas
                FROM users u
                LEFT JOIN disponibilidades d ON u.id = d.usuario_id 
                    AND d.activo = TRUE
                WHERE u.rol IN ('psicologo', 'becario')
                AND u.activo = TRUE
                ORDER BY u.rol, u.apellido, u.nombre, d.dia_semana
            `, {
                replacements: [fechaConsulta],
                type: QueryTypes.SELECT
            });

            // Preparar datos para CSV
            const datosCSV = disponibilidad.map(item => ({
                Profesional: item.profesional,
                Rol: item.rol,
                Especialidad: item.especialidad || '',
                'Día Semana': item.dia_semana || '',
                'Hora Inicio': item.hora_inicio || '',
                'Hora Fin': item.hora_fin || '',
                'Máx. Citas/Día': item.max_citas_dia || 8,
                'Citas Programadas': item.citas_programadas || 0,
                'Disponibilidad': item.citas_programadas >= (item.max_citas_dia || 8) ? 'Completo' : 'Disponible'
            }));

            // Convertir a CSV
            const json2csvParser = new Parser();
            const csv = json2csvParser.parse(datosCSV);

            // Configurar headers para descarga
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="disponibilidad_${fechaConsulta}.csv"`);
            
            res.send(csv);

        } catch (error) {
            console.error('Error exportando disponibilidad a CSV:', error);
            res.status(500).json({
                success: false,
                message: 'Error al exportar disponibilidad',
                error: error.message
            });
        }
    }
}

module.exports = ReporteController;

/src\controllers\roleController.js:
--------------------------------------------------------------------------------
const sequelize = require('../config/db');
const { QueryTypes } = require('sequelize');

class RoleController {
    
    static async getMyPermissions(req, res) {
        try {
            const userId = req.user.id;
            
            const query = `
                SELECT p.nombre, p.descripcion, p.categoria, up.concedido
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
            `;
            
            const permissions = await sequelize.query(query, {
                replacements: [userId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: permissions
            });
            
        } catch (error) {
            console.error('Error en getMyPermissions:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener permisos'
            });
        }
    }
    
    static async getUserRoleInfo(req, res) {
        try {
            const userId = req.user.id;
            
            const query = `
                SELECT 
                    u.id,
                    u.email,
                    u.nombre,
                    u.apellido,
                    u.rol,
                    u.especialidad,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = u.id AND fecha = CURDATE()) as citas_hoy,
                    (SELECT COUNT(*) FROM asignaciones WHERE becario_id = u.id AND fecha_fin IS NULL) as pacientes_asignados
                FROM users u
                WHERE u.id = ?
            `;
            
            const [userInfo] = await sequelize.query(query, {
                replacements: [userId],
                type: QueryTypes.SELECT
            });
            
            if (!userInfo) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Agregar estadísticas específicas por rol
            let estadisticas = {};
            
            switch (userInfo.rol) {
                case 'coordinador':
                    const [coordinadorStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                            (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                            (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                            (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy
                    `, { type: QueryTypes.SELECT });
                    estadisticas = coordinadorStats;
                    break;
                    
                case 'psicologo':
                    const [psicologoStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM asignaciones WHERE psicologo_id = ? AND fecha_fin IS NULL) as pacientes_asignados,
                            (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM asignaciones WHERE psicologo_id = ? AND becario_id IS NOT NULL AND fecha_fin IS NULL) as becarios_asignados
                    `, {
                        replacements: [userId, userId, userId],
                        type: QueryTypes.SELECT
                    });
                    estadisticas = psicologoStats;
                    break;
                    
                case 'becario':
                    const [becarioStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM asignaciones WHERE becario_id = ? AND fecha_fin IS NULL) as pacientes_asignados,
                            (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM observaciones_becarios WHERE becario_id = ? AND fecha = CURDATE()) as observaciones_hoy
                    `, {
                        replacements: [userId, userId, userId],
                        type: QueryTypes.SELECT
                    });
                    estadisticas = becarioStats;
                    break;
            }
            
            res.json({
                success: true,
                data: {
                    user: userInfo,
                    estadisticas: estadisticas
                }
            });
            
        } catch (error) {
            console.error('Error en getUserRoleInfo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener información del rol'
            });
        }
    }
    
    static async checkPermission(req, res) {
        try {
            const { permission } = req.params;
            const userId = req.user.id;
            
            const query = `
                SELECT EXISTS(
                    SELECT 1 FROM usuario_permisos up
                    JOIN permisos p ON up.permiso_id = p.id
                    WHERE up.usuario_id = ?
                    AND p.nombre = ?
                    AND up.concedido = TRUE
                ) as has_permission
            `;
            
            const [result] = await sequelize.query(query, {
                replacements: [userId, permission],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                hasPermission: result.has_permission === 1
            });
            
        } catch (error) {
            console.error('Error en checkPermission:', error);
            res.status(500).json({
                success: false,
                message: 'Error al verificar permiso'
            });
        }
    }
}

module.exports = RoleController;

/src\controllers\sesionController.js:
--------------------------------------------------------------------------------
const Sesion = require('../models/sesionModel');
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class SesionController {
    
    static async registrarSesion(req, res) {
        try {
            const { cita_id, desarrollo, conclusion, tareas_asignadas, 
                    emocion_predominante, riesgo_suicida, escalas_aplicadas, 
                    siguiente_cita, privado } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que la cita existe y está completada
            const cita = await Cita.findByPk(cita_id);
            
            if (!cita) {
                return res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
            }
            
            if (cita.estado !== 'completada') {
                return res.status(400).json({
                    success: false,
                    message: 'La cita debe estar en estado "completada" para registrar sesión'
                });
            }
            
            // Verificar que el usuario es el psicólogo asignado
            if (cita.psicologo_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para registrar esta sesión'
                });
            }
            
            // Verificar que no exista ya una sesión para esta cita
            const sesionExistente = await Sesion.findOne({
                where: { cita_id }
            });
            
            if (sesionExistente) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe una sesión registrada para esta cita'
                });
            }
            
            // Crear sesión
            const sesion = await Sesion.create({
                cita_id,
                psicologo_id: cita.psicologo_id,
                fecha: cita.fecha,
                hora_inicio: cita.hora,
                hora_fin: this.calcularHoraFin(cita.hora, cita.duracion),
                desarrollo,
                conclusion,
                tareas_asignadas,
                emocion_predominante,
                riesgo_suicida,
                escalas_aplicadas,
                siguiente_cita,
                privado: privado || false
            });
            
            // Actualizar expediente del paciente
            await this.actualizarExpediente(cita.paciente_id, {
                ultima_sesion: cita.fecha,
                psicologo_id: cita.psicologo_id,
                riesgo_suicida
            });
            
            // Notificar al becario si está asignado
            if (cita.becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'observacion_nueva', 'Sesión registrada', 
                    CONCAT('Se ha registrado la sesión del paciente: ', 
                    (SELECT CONCAT(nombre, ' ', apellido) FROM pacientes WHERE id = ?)), NOW())
                `, {
                    replacements: [cita.becario_id, cita.paciente_id]
                });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'sesiones', 'Registrar sesión', ?, NOW())
            `, {
                replacements: [usuarioId, `Sesión registrada para cita ${cita_id}`]
            });
            
            res.json({
                success: true,
                message: 'Sesión registrada exitosamente',
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en registrarSesion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al registrar sesión',
                error: error.message
            });
        }
    }
    
    static async obtenerSesionesPaciente(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tieneAcceso = await this.verificarAccesoSesiones(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver las sesiones de este paciente'
                });
            }
            
            const query = `
                SELECT 
                    s.*,
                    c.hora AS hora_cita,
                    c.tipo_consulta,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    u_bec.nombre AS becario_nombre,
                    u_bec.apellido AS becario_apellido
                FROM sesiones s
                JOIN citas c ON s.cita_id = c.id
                JOIN users u_psi ON s.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.paciente_id = ?
                ORDER BY s.fecha DESC, s.hora_inicio DESC
            `;
            
            const sesiones = await sequelize.query(query, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Filtrar sesiones privadas si no es el psicólogo
            const sesionesFiltradas = sesiones.filter(sesion => {
                if (sesion.privado && sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                    return false;
                }
                return true;
            });
            
            res.json({
                success: true,
                data: sesionesFiltradas,
                count: sesionesFiltradas.length
            });
            
        } catch (error) {
            console.error('Error en obtenerSesionesPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener sesiones del paciente'
            });
        }
    }
    
    static async obtenerSesionDetalle(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const query = `
                SELECT 
                    s.*,
                    c.paciente_id,
                    c.hora AS hora_cita,
                    c.tipo_consulta,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    u_bec.nombre AS becario_nombre,
                    u_bec.apellido AS becario_apellido
                FROM sesiones s
                JOIN citas c ON s.cita_id = c.id
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON s.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE s.id = ?
            `;
            
            const [sesion] = await sequelize.query(query, {
                replacements: [id],
                type: QueryTypes.SELECT
            });
            
            if (!sesion) {
                return res.status(404).json({
                    success: false,
                    message: 'Sesión no encontrada'
                });
            }
            
            // Verificar acceso a sesión privada
            if (sesion.privado && sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver esta sesión privada'
                });
            }
            
            // Verificar acceso general al paciente
            const tieneAcceso = await this.verificarAccesoSesiones(usuarioId, usuarioRol, sesion.paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver esta sesión'
                });
            }
            
            res.json({
                success: true,
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en obtenerSesionDetalle:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener detalle de sesión'
            });
        }
    }
    
    static async actualizarSesion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const sesion = await Sesion.findByPk(id);
            
            if (!sesion) {
                return res.status(404).json({
                    success: false,
                    message: 'Sesión no encontrada'
                });
            }
            
            // Verificar permisos (solo psicólogo asignado o coordinador)
            if (sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar esta sesión'
                });
            }
            
            // Campos que no se pueden modificar
            const camposBloqueados = ['cita_id', 'psicologo_id', 'fecha', 'hora_inicio', 'hora_fin'];
            for (const campo of camposBloqueados) {
                if (updates[campo]) {
                    delete updates[campo];
                }
            }
            
            if (Object.keys(updates).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos válidos para actualizar'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...sesion.toJSON() };
            
            await sesion.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'sesiones', 'Actualizar sesión', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Sesión actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(sesion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Sesión actualizada exitosamente',
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en actualizarSesion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar sesión'
            });
        }
    }
    
    // Métodos auxiliares
    static calcularHoraFin(horaInicio, duracionMinutos) {
        const [horas, minutos] = horaInicio.split(':').map(Number);
        const fecha = new Date();
        fecha.setHours(horas, minutos + duracionMinutos, 0, 0);
        return fecha.toTimeString().slice(0, 8);
    }
    
    static async verificarAccesoSesiones(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        const query = `
            SELECT 1 FROM asignaciones 
            WHERE paciente_id = ? 
            AND estado = 'activa'
            AND (psicologo_id = ? OR becario_id = ?)
        `;
        
        const [result] = await sequelize.query(query, {
            replacements: [pacienteId, usuarioId, usuarioId],
            type: QueryTypes.SELECT
        });
        
        return !!result;
    }
    
    static async actualizarExpediente(pacienteId, datos) {
        await sequelize.query(`
            UPDATE expedientes 
            SET riesgo_suicida = ?, 
                updated_at = NOW()
            WHERE paciente_id = ?
        `, {
            replacements: [datos.riesgo_suicida, pacienteId]
        });
    }
}

module.exports = SesionController;

/src\doc\swagger.json:
--------------------------------------------------------------------------------
{
  "swagger": "2.0",
  "info": {
    "version": "1.0.1",
    "title": "API Documentation con Auth",
    "description": "API documentation including Authentication endpoint"
  },
  "host": "localhost:3000",
  "basePath": "/",
  "schemes": [
    "http"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/": {
      "get": {
        "summary": "Root endpoint",
        "description": "Returns a basic message to confirm the server is running.",
        "responses": {
          "200": {
            "description": "Server is running"
          }
        }
      }
    },
    "/api/auth/login": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "User Login",
        "description": "Authenticate user with email and password to receive a JWT token.",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "User credentials",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LoginCredentials"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Login successful, token returned",
            "schema": {
              "$ref": "#/definitions/LoginResponse"
            }
          },
          "400": {
            "description": "Missing email or password"
          },
          "401": {
            "description": "Invalid credentials"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    }
  },
  "definitions": {
    "LoginCredentials": {
      "type": "object",
      "required": [
        "email",
        "password"
      ],
      "properties": {
        "email": {
          "type": "string",
          "example": "test@example.com"
        },
        "password": {
          "type": "string",
          "example": "123456"
        }
      }
    },
    "LoginResponse": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "example": "Login exitoso"
        },
        "token": {
          "type": "string",
          "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
        },
        "user": {
          "type": "object",
          "properties": {
            "id": { "type": "integer", "example": 1 },
            "email": { "type": "string", "example": "test@example.com" }
          }
        }
      }
    }
  }
}

/src\middlewares\authMiddleware.js:
--------------------------------------------------------------------------------


const jwt = require('jsonwebtoken');

const verifyToken = (req, res, next) => {
    // 1. Obtener el token del header "Authorization"
    // Se espera el formato: "Bearer <token_aqui>"
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Obtener la segunda parte

    if (!token) {
        return res.status(403).json({ message: 'Acceso denegado. Token no proporcionado.' });
    }

    try {
        // 2. Verificar el token usando la clave secreta
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // 3. Si es válido, guardamos los datos del usuario (payload) en la request
        // para que las siguientes rutas puedan usarlo (ej. req.user.id)
        req.user = decoded;
        
        // 4. Continuar con la siguiente función
        next();
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
             return res.status(401).json({ message: 'El token ha expirado.' });
        }
        return res.status(401).json({ message: 'Token inválido.' });
    }
};

module.exports = verifyToken;

/src\middlewares\logMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const logMiddleware = (tipoLog, modulo, accion) => {
    return async (req, res, next) => {
        const startTime = Date.now();
        
        // Guardar referencia a la función original de res.json
        const originalJson = res.json;
        
        // Sobrescribir res.json para capturar la respuesta
        res.json = function(data) {
            // Restaurar la función original
            res.json = originalJson;
            
            // Calcular tiempo de respuesta
            const responseTime = Date.now() - startTime;
            
            // Registrar el log en segundo plano (no bloquear la respuesta)
            registrarLogAsync({
                usuario_id: req.user?.id || null,
                tipo_log: tipoLog,
                modulo: modulo,
                accion: accion,
                descripcion: `${accion} - ${req.method} ${req.originalUrl}`,
                ip_address: req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress,
                user_agent: req.headers['user-agent'],
                datos_extra: {
                    method: req.method,
                    url: req.originalUrl,
                    query_params: req.query,
                    body_params: req.body,
                    response_status: res.statusCode,
                    response_time_ms: responseTime,
                    success: data?.success || false
                },
                severidad: res.statusCode >= 500 ? 'error' : 
                          res.statusCode >= 400 ? 'advertencia' : 'info'
            }).catch(console.error);
            
            // Llamar a la función original
            return originalJson.call(this, data);
        };
        
        next();
    };
};

// Función asíncrona para registrar logs
async function registrarLogAsync(logData) {
    try {
        await sequelize.query(`
            INSERT INTO logs_sistema (
                usuario_id, tipo_log, modulo, accion, descripcion,
                ip_address, user_agent, datos_extra, severidad, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
        `, {
            replacements: [
                logData.usuario_id,
                logData.tipo_log,
                logData.modulo,
                logData.accion,
                logData.descripcion,
                logData.ip_address,
                logData.user_agent,
                JSON.stringify(logData.datos_extra),
                logData.severidad
            ]
        });
    } catch (error) {
        console.error('Error al registrar log:', error);
    }
}

// Middleware para logs de autenticación
const logAuthMiddleware = logMiddleware('login', 'autenticacion', 'Login usuario');

// Middleware para logs de creación
const logCreacionMiddleware = (modulo) => logMiddleware('creacion', modulo, 'Crear registro');

// Middleware para logs de modificación
const logModificacionMiddleware = (modulo) => logMiddleware('modificacion', modulo, 'Modificar registro');

// Middleware para logs de eliminación
const logEliminacionMiddleware = (modulo) => logMiddleware('eliminacion', modulo, 'Eliminar registro');

// Middleware para logs de consulta
const logConsultaMiddleware = (modulo) => logMiddleware('consulta', modulo, 'Consultar registros');

// Middleware para logs de reportes
const logReporteMiddleware = logMiddleware('reporte', 'reportes', 'Generar reporte');

// Middleware para logs de errores
const logErrorMiddleware = (error, req, res, next) => {
    registrarLogAsync({
        usuario_id: req.user?.id || null,
        tipo_log: 'error',
        modulo: 'sistema',
        accion: 'Error en solicitud',
        descripcion: `Error: ${error.message}`,
        ip_address: req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress,
        user_agent: req.headers['user-agent'],
        datos_extra: {
            method: req.method,
            url: req.originalUrl,
            error_stack: error.stack,
            error_message: error.message
        },
        severidad: 'error'
    }).catch(console.error);
    
    next(error);
};

// Middleware para auditoría de datos sensibles
const auditoriaMiddleware = (modulo, camposSensibles = []) => {
    return async (req, res, next) => {
        // Guardar datos originales para comparación posterior
        if (req.method === 'PUT' || req.method === 'PATCH') {
            const datosOriginales = await obtenerDatosOriginales(req);
            req._datosOriginales = datosOriginales;
        }
        
        next();
    };
};

async function obtenerDatosOriginales(req) {
    // Esta función obtendría los datos originales de la base de datos
    // Implementación específica según el módulo
    return {};
}

module.exports = {
    logMiddleware,
    logAuthMiddleware,
    logCreacionMiddleware,
    logModificacionMiddleware,
    logEliminacionMiddleware,
    logConsultaMiddleware,
    logReporteMiddleware,
    logErrorMiddleware,
    auditoriaMiddleware,
    registrarLogAsync
};

/src\middlewares\permisoMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const permisoMiddleware = (permisoNombre) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar si el usuario tiene el permiso específico
            const query = `
                SELECT up.concedido 
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND p.nombre = ?
                AND up.concedido = TRUE
            `;
            
            const result = await sequelize.query(query, {
                replacements: [usuarioId, permisoNombre],
                type: QueryTypes.SELECT
            });
            
            if (result.length > 0) {
                return next();
            }
            
            // Si no tiene permiso específico, verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Permisos por defecto según rol
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            if (permisosPorRol[usuario.rol]?.includes(permisoNombre)) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: `No tiene el permiso necesario: ${permisoNombre}`
            });
            
        } catch (error) {
            console.error('Error en permisoMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

// Middleware para verificar múltiples permisos (al menos uno)
const algunPermisoMiddleware = (permisos) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar permisos del usuario
            const query = `
                SELECT p.nombre
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
                AND p.nombre IN (?)
            `;
            
            const resultados = await sequelize.query(query, {
                replacements: [usuarioId, permisos],
                type: QueryTypes.SELECT
            });
            
            if (resultados.length > 0) {
                return next();
            }
            
            // Verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            // Verificar si algún permiso requerido está en los permisos del rol
            const tieneAlgunPermiso = permisos.some(permiso => 
                permisosPorRol[usuario.rol]?.includes(permiso)
            );
            
            if (tieneAlgunPermiso) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene los permisos necesarios para esta acción'
            });
            
        } catch (error) {
            console.error('Error en algunPermisoMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

// Middleware para verificar todos los permisos
const todosPermisosMiddleware = (permisos) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar permisos del usuario
            const query = `
                SELECT p.nombre
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
                AND p.nombre IN (?)
            `;
            
            const resultados = await sequelize.query(query, {
                replacements: [usuarioId, permisos],
                type: QueryTypes.SELECT
            });
            
            const permisosObtenidos = resultados.map(r => r.nombre);
            
            // Verificar si tiene todos los permisos requeridos
            const tieneTodos = permisos.every(permiso => 
                permisosObtenidos.includes(permiso)
            );
            
            if (tieneTodos) {
                return next();
            }
            
            // Verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            // Verificar si todos los permisos requeridos están en los permisos del rol
            const tieneTodosPorRol = permisos.every(permiso => 
                permisosPorRol[usuario.rol]?.includes(permiso)
            );
            
            if (tieneTodosPorRol) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene todos los permisos necesarios para esta acción'
            });
            
        } catch (error) {
            console.error('Error en todosPermisosMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

module.exports = {
    permisoMiddleware,
    algunPermisoMiddleware,
    todosPermisosMiddleware
};

/src\middlewares\roleMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const checkPermission = (permisoNombre) => {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            // Consultar si el usuario tiene el permiso
            const query = `
                SELECT up.concedido 
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND p.nombre = ?
            `;
            
            const result = await sequelize.query(query, {
                replacements: [userId, permisoNombre],
                type: QueryTypes.SELECT
            });
            
            if (result.length > 0 && result[0].concedido) {
                return next();
            }
            
            // Si no tiene permiso específico, verificar por rol básico
            const user = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [userId], type: QueryTypes.SELECT }
            );
            
            const userRole = user[0]?.rol;
            
            // Permisos por rol (fallback)
            const rolePermissions = {
                'coordinador': [
                    'ver_panel_coordinacion', 'gestionar_usuarios', 'gestionar_pacientes',
                    'gestionar_asignaciones', 'ver_agenda_global', 'generar_reportes',
                    'gestionar_altas'
                ],
                'psicologo': [
                    'ver_panel_psicologo', 'ver_mis_pacientes', 'ver_expedientes',
                    'registrar_sesiones', 'gestionar_mis_citas', 'supervisar_becarios'
                ],
                'becario': [
                    'ver_panel_becario', 'ver_citas_dia', 'gestionar_citas_asignadas',
                    'ver_pacientes_asignados', 'registrar_observaciones', 'ver_notificaciones'
                ]
            };
            
            if (userRole && rolePermissions[userRole]?.includes(permisoNombre)) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene permisos para acceder a esta funcionalidad'
            });
            
        } catch (error) {
            console.error('Error en checkPermission:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

const requireRole = (roles) => {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            const user = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [userId], type: QueryTypes.SELECT }
            );
            
            if (user.length === 0 || !roles.includes(user[0].rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Acceso denegado para este rol'
                });
            }
            
            next();
        } catch (error) {
            console.error('Error en requireRole:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar rol'
            });
        }
    };
};

module.exports = { checkPermission, requireRole };

/src\middlewares\validacionMiddleware.js:
--------------------------------------------------------------------------------
const { body, param, query, validationResult } = require('express-validator');

// Validaciones comunes
const validacionesComunes = {
    email: body('email').isEmail().normalizeEmail(),
    telefono: body('telefono').optional().isMobilePhone('any-MX'),
    fecha: body('fecha').isDate().toDate(),
    hora: body('hora').matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/),
    numeroPositivo: body().custom((value, { path }) => {
        if (typeof value === 'number' && value > 0) return true;
        throw new Error(`${path} debe ser un número positivo`);
    })
};

// Validaciones para pacientes
const validarPaciente = [
    body('nombre').notEmpty().trim().isLength({ min: 2, max: 100 }),
    body('apellido').notEmpty().trim().isLength({ min: 2, max: 100 }),
    validacionesComunes.email.optional(),
    validacionesComunes.telefono,
    body('fecha_nacimiento').optional().isDate(),
    body('genero').optional().isIn(['masculino', 'femenino', 'otro', 'prefiero_no_decir']),
    body('direccion').optional().trim(),
    body('estado').optional().isIn(['activo', 'inactivo', 'pendiente']),
    body('activo').optional().isBoolean(),
    body('notas').optional().trim(),
    body('fundacion_id').optional().isInt()
];

// Validaciones para citas
const validarCita = [
    body('paciente_id').isInt(),
    body('psicologo_id').optional().isInt(),
    body('becario_id').optional().isInt(),
    validacionesComunes.fecha,
    validacionesComunes.hora,
    body('tipo_consulta').isIn(['presencial', 'virtual']),
    body('estado').optional().isIn(['programada', 'confirmada', 'completada', 'cancelada']),
    body('duracion').optional().isInt({ min: 15, max: 120 }),
    body('notas').optional().trim()
];

// Validaciones para sesiones
const validarSesion = [
    body('cita_id').isInt(),
    body('desarrollo').notEmpty().trim(),
    body('conclusion').optional().trim(),
    body('tareas_asignadas').optional().trim(),
    body('emocion_predominante').optional().trim(),
    body('riesgo_suicida').optional().isIn(['ninguno', 'bajo', 'moderado', 'alto']),
    body('escalas_aplicadas').optional().isJSON(),
    body('siguiente_cita').optional().isDate(),
    body('privado').optional().isBoolean()
];

// Validaciones para usuarios
const validarUsuario = [
    validacionesComunes.email,
    body('password').isLength({ min: 6 }),
    body('nombre').notEmpty().trim().isLength({ min: 2, max: 100 }),
    body('apellido').notEmpty().trim().isLength({ min: 2, max: 100 }),
    validacionesComunes.telefono.optional(),
    body('rol').isIn(['coordinador', 'psicologo', 'becario']),
    body('especialidad').optional().trim(),
    body('fundacion_id').optional().isInt(),
    body('activo').optional().isBoolean()
];

// Validaciones para observaciones de becarios
const validarObservacion = [
    body('becario_id').isInt(),
    body('cita_id').optional().isInt(),
    body('tipo_observacion').isIn(['sesion_observada', 'retroalimentacion', 'evaluacion_periodica', 'incidencia', 'reconocimiento']),
    body('aspecto_evaluado').isIn(['empatia', 'tecnicas', 'documentacion', 'puntualidad', 'profesionalismo', 'etica']),
    body('calificacion').isInt({ min: 1, max: 10 }),
    body('fortalezas').optional().trim(),
    body('areas_mejora').optional().trim(),
    body('recomendaciones').optional().trim(),
    body('plan_accion').optional().trim(),
    body('fecha_seguimiento').optional().isDate(),
    body('privada').optional().isBoolean()
];

// Validaciones para disponibilidad
const validarDisponibilidad = [
    body('dia_semana').isIn(['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo']),
    validacionesComunes.hora.custom((value, { req }) => {
        const horaInicio = value;
        const horaFin = req.body.hora_fin;
        
        if (!horaFin) return true;
        
        const [h1, m1] = horaInicio.split(':').map(Number);
        const [h2, m2] = horaFin.split(':').map(Number);
        
        if (h2 < h1 || (h2 === h1 && m2 <= m1)) {
            throw new Error('La hora de fin debe ser mayor que la hora de inicio');
        }
        
        return true;
    }),
    body('hora_fin').matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/),
    body('tipo_disponibilidad').optional().isIn(['regular', 'extraordinaria', 'limitada']),
    body('max_citas_dia').optional().isInt({ min: 1, max: 12 }),
    body('intervalo_citas').optional().isInt({ min: 15, max: 120 }),
    body('fecha_fin_vigencia').optional().isDate()
];

// Validaciones para altas
const validarAlta = [
    body('paciente_id').isInt(),
    body('tipo_alta').isIn(['terapeutica', 'abandono', 'traslado', 'graduacion', 'no_continua', 'otro']),
    body('motivo_detallado').optional().trim(),
    body('recomendaciones').optional().trim(),
    body('evaluacion_final').optional().isIn(['excelente', 'buena', 'regular', 'mala']),
    body('seguimiento_recomendado').optional().isBoolean(),
    body('fecha_seguimiento').optional().isDate()
];

// Validaciones para reportes
const validarReporte = [
    query('mes').optional().isInt({ min: 1, max: 12 }),
    query('anio').optional().isInt({ min: 2000, max: 2100 }),
    query('fecha_inicio').optional().isDate(),
    query('fecha_fin').optional().isDate(),
    query('formato').optional().isIn(['pdf', 'excel', 'csv', 'html']),
    query('tipo').optional().isIn(['citas', 'pacientes', 'sesiones', 'becarios'])
];

// Middleware de validación
const validarResultados = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            success: false,
            message: 'Errores de validación',
            errors: errors.array().map(err => ({
                campo: err.param,
                mensaje: err.msg,
                valor: err.value
            }))
        });
    }
    next();
};

// Validaciones de parámetros de ruta
const validarId = [
    param('id').isInt(),
    validarResultados
];

const validarPacienteId = [
    param('paciente_id').isInt(),
    validarResultados
];

const validarUsuarioId = [
    param('usuario_id').isInt(),
    validarResultados
];

// Exportar todas las validaciones
module.exports = {
    validacionesComunes,
    validarPaciente,
    validarCita,
    validarSesion,
    validarUsuario,
    validarObservacion,
    validarDisponibilidad,
    validarAlta,
    validarReporte,
    validarResultados,
    validarId,
    validarPacienteId,
    validarUsuarioId
};

/src\models\altaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Alta = sequelize.define('Alta', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_alta: {
        type: DataTypes.ENUM(
            'terapeutica',
            'abandono',
            'traslado',
            'graduacion',
            'no_continua',
            'otro'
        ),
        allowNull: false
    },
    fecha_alta: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    motivo_detallado: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    recomendaciones: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    sesiones_totales: {
        type: DataTypes.INTEGER,
        allowNull: true
    },
    evaluacion_final: {
        type: DataTypes.ENUM('excelente', 'buena', 'regular', 'mala'),
        allowNull: true
    },
    seguimiento_recomendado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    fecha_seguimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    }
}, {
    tableName: 'altas',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['paciente_id']
        },
        {
            fields: ['fecha_alta']
        },
        {
            fields: ['tipo_alta']
        }
    ]
});

Alta.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Alta.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Alta;

/src\models\asignacionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Asignacion = sequelize.define('Asignacion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    fecha_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    motivo_fin: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    estado: {
        type: DataTypes.ENUM('activa', 'finalizada', 'suspendida'),
        defaultValue: 'activa'
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    }
}, {
    tableName: 'asignaciones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['paciente_id', 'estado']
        },
        {
            fields: ['psicologo_id', 'estado']
        },
        {
            fields: ['becario_id']
        }
    ]
});

// Relaciones
Asignacion.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Asignacion.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });
Asignacion.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });

module.exports = Asignacion;

/src\models\citaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Cita = sequelize.define('Cita', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false
    },
    hora: {
        type: DataTypes.TIME,
        allowNull: false,
        get() {
            // Obtener la hora sin segundos
            const rawValue = this.getDataValue('hora');
            return rawValue ? rawValue.substring(0, 5) : null;
        }
    },
    tipo_consulta: {
        type: DataTypes.ENUM('presencial', 'virtual'),
        allowNull: false,
        defaultValue: 'presencial'
    },
    estado: {
        type: DataTypes.ENUM('programada', 'confirmada', 'completada', 'cancelada'),
        allowNull: false,
        defaultValue: 'programada'
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    motivo_cancelacion: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    duracion: {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 50,
        comment: 'Duración en minutos'
    },
    // Mantén compatibilidad con duracion_minutos
    duracion_minutos: {
        type: DataTypes.VIRTUAL,
        get() {
            return this.getDataValue('duracion');
        }
    }
}, {
    tableName: 'citas',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['fecha', 'estado']
        },
        {
            fields: ['psicologo_id', 'fecha']
        },
        {
            fields: ['becario_id']
        },
        {
            fields: ['paciente_id']
        }
    ]
});

// Relaciones
Cita.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Cita.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });
Cita.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });

module.exports = Cita;

/src\models\disponibilidadModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Disponibilidad = sequelize.define('Disponibilidad', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    dia_semana: {
        type: DataTypes.ENUM(
            'lunes',
            'martes',
            'miercoles',
            'jueves',
            'viernes',
            'sabado',
            'domingo'
        ),
        allowNull: false
    },
    hora_inicio: {
        type: DataTypes.TIME,
        allowNull: false
    },
    hora_fin: {
        type: DataTypes.TIME,
        allowNull: false
    },
    tipo_disponibilidad: {
        type: DataTypes.ENUM('regular', 'extraordinaria', 'limitada'),
        defaultValue: 'regular'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    },
    fecha_inicio_vigencia: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    fecha_fin_vigencia: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    max_citas_dia: {
        type: DataTypes.INTEGER,
        defaultValue: 8,
        validate: {
            min: 1,
            max: 12
        }
    },
    intervalo_citas: {
        type: DataTypes.INTEGER,
        defaultValue: 50,
        comment: 'Duración estándar en minutos'
    }
}, {
    tableName: 'disponibilidades',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['usuario_id', 'dia_semana', 'activo']
        },
        {
            fields: ['fecha_inicio_vigencia', 'fecha_fin_vigencia']
        }
    ]
});

Disponibilidad.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Disponibilidad;

/src\models\expedienteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Expediente = sequelize.define('Expediente', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        },
        unique: true
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    motivo_consulta: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    historia_personal: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    historia_familiar: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    antecedentes_medicos: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    antecedentes_psiquiatricos: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    diagnostico_presuntivo: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    diagnostico_definitivo: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    tratamiento_actual: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    medicamentos: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con medicamentos y dosis'
    },
    alergias: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    factores_riesgo: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con factores de riesgo identificados'
    },
    redes_apoyo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    emergencia_contacto: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    emergencia_telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    consentimiento_informado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    fecha_consentimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    restricciones_acceso: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con IDs de usuarios con acceso restringido'
    },
    notas_confidenciales: {
        type: DataTypes.TEXT,
        allowNull: true,
        comment: 'Solo visible para psicólogo asignado'
    }
}, {
    tableName: 'expedientes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

Expediente.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Expediente.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });

module.exports = Expediente;

/src\models\fundacionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const Fundacion = sequelize.define('Fundacion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: true
    },
    direccion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: true,
        validate: {
            isEmail: true
        }
    },
    responsable: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    },
    convenio_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    convenio_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    }
}, {
    tableName: 'fundaciones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

module.exports = Fundacion;

/src\models\logSistemaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const LogSistema = sequelize.define('LogSistema', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_log: {
        type: DataTypes.ENUM(
            'login',
            'logout',
            'creacion',
            'modificacion',
            'eliminacion',
            'error',
            'seguridad',
            'backup',
            'reporte',
            'sistema'
        ),
        allowNull: false
    },
    modulo: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    accion: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    datos_antes: {
        type: DataTypes.JSON,
        allowNull: true
    },
    datos_despues: {
        type: DataTypes.JSON,
        allowNull: true
    },
    ip_address: {
        type: DataTypes.STRING(45),
        allowNull: true
    },
    user_agent: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    severidad: {
        type: DataTypes.ENUM('info', 'advertencia', 'error', 'critico'),
        defaultValue: 'info'
    },
    resuelto: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    }
}, {
    tableName: 'logs_sistema',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['tipo_log', 'created_at']
        },
        {
            fields: ['usuario_id']
        },
        {
            fields: ['modulo']
        },
        {
            fields: ['severidad', 'resuelto']
        }
    ]
});

LogSistema.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = LogSistema;

/src\models\notificacionModel.js:
--------------------------------------------------------------------------------


/src\models\observacionBecarioModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');
const Cita = require('./citaModel');

const ObservacionBecario = sequelize.define('ObservacionBecario', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    supervisor_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    cita_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: Cita,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    tipo_observacion: {
        type: DataTypes.ENUM(
            'sesion_observada',
            'retroalimentacion',
            'evaluacion_periodica',
            'incidencia',
            'reconocimiento'
        ),
        defaultValue: 'sesion_observada'
    },
    aspecto_evaluado: {
        type: DataTypes.ENUM(
            'empatia',
            'tecnicas',
            'documentacion',
            'puntualidad',
            'profesionalismo',
            'etica'
        ),
        allowNull: false
    },
    calificacion: {
        type: DataTypes.INTEGER,
        allowNull: false,
        validate: {
            min: 1,
            max: 10
        }
    },
    fortalezas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    areas_mejora: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    recomendaciones: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    plan_accion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    fecha_seguimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    privada: {
        type: DataTypes.BOOLEAN,
        defaultValue: false,
        comment: 'Solo visible para supervisor y becario'
    }
}, {
    tableName: 'observaciones_becarios',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['becario_id', 'fecha']
        },
        {
            fields: ['supervisor_id']
        },
        {
            fields: ['tipo_observacion']
        }
    ]
});

ObservacionBecario.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });
ObservacionBecario.belongsTo(User, { as: 'Supervisor', foreignKey: 'supervisor_id' });
ObservacionBecario.belongsTo(Cita, { foreignKey: 'cita_id' });

module.exports = ObservacionBecario;

/src\models\pacienteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const Paciente = sequelize.define('Paciente', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: true,
        validate: {
            isEmail: true
        }
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    fecha_nacimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    genero: {
        type: DataTypes.ENUM('masculino', 'femenino', 'otro', 'prefiero_no_decir'),
        allowNull: true
    },
    direccion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    estado: {
        type: DataTypes.STRING(50),
        allowNull: false,
        defaultValue: 'activo'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    }
}, {
    tableName: 'pacientes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['activo']
        },
        {
            fields: ['apellido', 'nombre']
        }
    ]
});

module.exports = Paciente;

/src\models\permisoModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Permiso = sequelize.define('Permiso', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false,
        unique: true
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    categoria: {
        type: DataTypes.ENUM(
            'administracion',
            'pacientes',
            'citas',
            'reportes',
            'configuracion',
            'usuarios'
        ),
        allowNull: false
    },
    nivel_requerido: {
        type: DataTypes.ENUM('basico', 'intermedio', 'avanzado', 'administrador'),
        defaultValue: 'basico'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    }
}, {
    tableName: 'permisos',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

const UsuarioPermiso = sequelize.define('UsuarioPermiso', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    permiso_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Permiso,
            key: 'id'
        }
    },
    concedido: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    concedido_por: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha_concesion: {
        type: DataTypes.DATE,
        allowNull: true
    },
    fecha_expiracion: {
        type: DataTypes.DATE,
        allowNull: true
    },
    motivo: {
        type: DataTypes.TEXT,
        allowNull: true
    }
}, {
    tableName: 'usuario_permisos',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            unique: true,
            fields: ['usuario_id', 'permiso_id']
        }
    ]
});

// Relaciones
UsuarioPermiso.belongsTo(User, { as: 'Usuario', foreignKey: 'usuario_id' });
UsuarioPermiso.belongsTo(User, { as: 'ConcedidoPor', foreignKey: 'concedido_por' });
UsuarioPermiso.belongsTo(Permiso, { foreignKey: 'permiso_id' });

module.exports = { Permiso, UsuarioPermiso };

/src\models\reporteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Reporte = sequelize.define('Reporte', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_reporte: {
        type: DataTypes.ENUM(
            'mensual',
            'trimestral',
            'semestral',
            'anual',
            'personalizado',
            'paciente',
            'becario',
            'psicologo'
        ),
        allowNull: false
    },
    nombre: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    parametros: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con parámetros del reporte'
    },
    fecha_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    fecha_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    formato: {
        type: DataTypes.ENUM('pdf', 'excel', 'csv', 'html'),
        defaultValue: 'pdf'
    },
    archivo_url: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    archivo_tamano: {
        type: DataTypes.INTEGER,
        allowNull: true,
        comment: 'Tamaño en bytes'
    },
    estado: {
        type: DataTypes.ENUM('pendiente', 'generando', 'completado', 'error'),
        defaultValue: 'pendiente'
    },
    compartido_con: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con IDs de usuarios con acceso'
    }
}, {
    tableName: 'reportes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['usuario_id']
        },
        {
            fields: ['tipo_reporte', 'estado']
        },
        {
            fields: ['created_at']
        }
    ]
});

Reporte.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Reporte;

/src\models\sesionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Cita = require('./citaModel');
const User = require('./userModel');

const Sesion = sequelize.define('Sesion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    cita_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Cita,
            key: 'id'
        },
        unique: true
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false
    },
    hora_inicio: {
        type: DataTypes.TIME,
        allowNull: false
    },
    hora_fin: {
        type: DataTypes.TIME,
        allowNull: false
    },
    tipo_sesion: {
        type: DataTypes.ENUM('evaluacion', 'terapia', 'seguimiento', 'crisis'),
        defaultValue: 'terapia'
    },
    objetivo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    desarrollo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    conclusion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    tareas_asignadas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    emocion_predominante: {
        type: DataTypes.STRING(100),
        allowNull: true
    },
    riesgo_suicida: {
        type: DataTypes.ENUM('ninguno', 'bajo', 'moderado', 'alto'),
        defaultValue: 'ninguno'
    },
    escalas_aplicadas: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con escalas aplicadas y puntajes'
    },
    siguiente_cita: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    privado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false,
        comment: 'Si solo psicólogo puede ver'
    }
}, {
    tableName: 'sesiones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['cita_id']
        },
        {
            fields: ['psicologo_id', 'fecha']
        },
        {
            fields: ['fecha']
        }
    ]
});

// Relaciones
Sesion.belongsTo(Cita, { foreignKey: 'cita_id' });
Sesion.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });

module.exports = Sesion;

/src\models\userModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const User = sequelize.define('User', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: {
            msg: 'El correo electrónico ya está registrado'
        },
        validate: {
            isEmail: {
                msg: 'Debe proporcionar un correo electrónico válido'
            },
            notEmpty: true
        }
    },
    password: {
        type: DataTypes.STRING(255),
        allowNull: false,
        validate: {
            notEmpty: true
        }
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    rol: {
        type: DataTypes.ENUM('coordinador', 'psicologo', 'becario'),
        allowNull: false,
        defaultValue: 'becario'
    },
    especialidad: {
        type: DataTypes.STRING(100),
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    }
}, {
    tableName: 'users',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

module.exports = User;

/src\routes\agendaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AgendaController = require('../controllers/agendaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Obtener agendas
router.get('/global', AgendaController.obtenerAgendaGlobal);
router.get('/diaria', AgendaController.obtenerAgendaDiaria);
router.get('/mensual', AgendaController.obtenerCalendarioMensual);
router.get('/disponibilidad-profesionales', AgendaController.obtenerDisponibilidadProfesionales);

// Reprogramar citas
router.put('/cita/:id/reprogramar', requireRole(['psicologo', 'becario', 'coordinador']), AgendaController.reprogramarCita);

module.exports = router;

/src\routes\altaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AltaController = require('../controllers/altaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Dar de alta paciente
router.post('/', requireRole(['psicologo', 'coordinador']), AltaController.darAltaPaciente);

// Obtener altas
router.get('/', requireRole(['coordinador', 'psicologo']), AltaController.obtenerAltas);
router.get('/estadisticas', requireRole(['coordinador']), AltaController.obtenerEstadisticasAltas);
router.get('/:id', requireRole(['coordinador', 'psicologo']), AltaController.obtenerAltaDetalle);

module.exports = router;

/src\routes\asignacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AsignacionController = require('../controllers/asignacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Rutas para coordinadores
router.post('/', requireRole(['coordinador']), AsignacionController.crearAsignacion);
router.get('/', requireRole(['coordinador']), AsignacionController.obtenerAsignacionesActivas);
router.put('/:id/finalizar', requireRole(['coordinador', 'psicologo']), AsignacionController.finalizarAsignacion);
router.get('/paciente/:paciente_id/historial', requireRole(['coordinador', 'psicologo']), AsignacionController.obtenerHistorialAsignaciones);

// Rutas para psicólogos y becarios
router.get('/mis-pacientes', requireRole(['psicologo', 'becario']), AsignacionController.obtenerMisPacientes);

module.exports = router;

/src\routes\authRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AuthController = require('../controllers/authController');
const verifyToken = require('../middlewares/authMiddleware');

router.post('/login', AuthController.login);
router.get('/me', verifyToken, AuthController.getMe);

module.exports = router;

/src\routes\citaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const CitaController = require('../controllers/citaController');
const verifyToken = require('../middlewares/authMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Rutas de consulta
router.get('/citas-por-fecha', CitaController.obtenerCitasPorFecha);
router.get('/reporte-mensual', CitaController.generarReporteMensual);
router.get('/estadisticas', CitaController.obtenerEstadisticas);

// Rutas de modificación
router.post('/alta-paciente', CitaController.darAltaPaciente);
router.put('/cita/:id', CitaController.actualizarCita);
router.post('/nueva', CitaController.crearNuevaCita);

module.exports = router;

/src\routes\dashboardRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const DashboardController = require('../controllers/dashboardController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Dashboards por rol
router.get('/coordinador', requireRole(['coordinador']), DashboardController.obtenerDashboardCoordinador);
router.get('/psicologo', requireRole(['psicologo']), DashboardController.obtenerDashboardPsicologo);
router.get('/becario', requireRole(['becario']), DashboardController.obtenerDashboardBecario);

// Métricas globales
router.get('/metricas-globales', requireRole(['coordinador']), DashboardController.obtenerMetricasGlobales);

module.exports = router;

/src\routes\disponibilidadRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const DisponibilidadController = require('../controllers/disponibilidadController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Gestión de disponibilidad personal
router.post('/', requireRole(['psicologo', 'becario']), DisponibilidadController.crearDisponibilidad);
router.get('/mi-disponibilidad', requireRole(['psicologo', 'becario']), DisponibilidadController.obtenerMiDisponibilidad);
router.put('/:id', requireRole(['psicologo', 'becario']), DisponibilidadController.actualizarDisponibilidad);
router.put('/:id/desactivar', requireRole(['psicologo', 'becario']), DisponibilidadController.desactivarDisponibilidad);

// Consulta de disponibilidad
router.get('/usuario/:usuario_id', requireRole(['coordinador', 'psicologo']), DisponibilidadController.obtenerDisponibilidadUsuario);
router.get('/horarios-disponibles', requireRole(['coordinador', 'psicologo', 'becario']), DisponibilidadController.obtenerHorariosDisponibles);

module.exports = router;

/src\routes\estadisticaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const EstadisticaController = require('../controllers/estadisticaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Estadísticas generales
router.get('/generales', requireRole(['coordinador']), EstadisticaController.obtenerEstadisticasGenerales);
router.get('/reporte-comparativo', requireRole(['coordinador']), EstadisticaController.obtenerReporteComparativo);

// Estadísticas por rol/profesional
router.get('/psicologo', requireRole(['coordinador', 'psicologo']), EstadisticaController.obtenerEstadisticasPsicologo);
router.get('/becario', requireRole(['coordinador', 'psicologo', 'becario']), EstadisticaController.obtenerEstadisticasBecario);
router.get('/paciente/:paciente_id', requireRole(['coordinador', 'psicologo']), EstadisticaController.obtenerEstadisticasPaciente);

module.exports = router;

/src\routes\expedienteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ExpedienteController = require('../controllers/expedienteController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Obtener expedientes
router.get('/paciente/:paciente_id/completo', requireRole(['psicologo', 'becario', 'coordinador']), ExpedienteController.obtenerExpedienteCompleto);
router.get('/paciente/:paciente_id/resumen', requireRole(['psicologo', 'becario', 'coordinador']), ExpedienteController.obtenerResumenExpediente);

// Crear y actualizar expedientes
router.post('/paciente/:paciente_id', requireRole(['psicologo', 'coordinador']), ExpedienteController.crearExpediente);
router.put('/paciente/:paciente_id', requireRole(['psicologo', 'coordinador']), ExpedienteController.actualizarExpediente);

// Notas confidenciales
router.post('/paciente/:paciente_id/nota-confidencial', requireRole(['psicologo', 'coordinador']), ExpedienteController.agregarNotaConfidencial);

module.exports = router;

/src\routes\fundacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const FundacionController = require('../controllers/fundacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Rutas para coordinadores
router.post('/', requireRole(['coordinador']), FundacionController.crearFundacion);
router.get('/', requireRole(['coordinador', 'psicologo']), FundacionController.obtenerFundaciones);
router.get('/:id', requireRole(['coordinador', 'psicologo']), FundacionController.obtenerFundacion);
router.put('/:id', requireRole(['coordinador']), FundacionController.actualizarFundacion);
router.put('/:id/desactivar', requireRole(['coordinador']), FundacionController.desactivarFundacion);

module.exports = router;

/src\routes\notificacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const NotificacionController = require('../controllers/notificacionController');
const verifyToken = require('../middlewares/authMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Obtener notificaciones del usuario
router.get('/', NotificacionController.obtenerMisNotificaciones);
router.get('/recientes', NotificacionController.obtenerNotificacionesRecientes);

// Marcar notificaciones como leídas
router.put('/:id/leer', NotificacionController.marcarComoLeido);
router.put('/leer-todas', NotificacionController.marcarTodasComoLeidas);

// Crear notificación (solo coordinadores)
router.post('/', verifyToken, NotificacionController.crearNotificacion);

// Eliminar notificación
router.delete('/:id', NotificacionController.eliminarNotificacion);

module.exports = router;

/src\routes\observacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ObservacionController = require('../controllers/observacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Crear observación (solo psicólogos y coordinadores)
router.post('/', requireRole(['psicologo', 'coordinador']), ObservacionController.crearObservacion);

// Obtener observaciones
router.get('/becario/:becario_id', requireRole(['psicologo', 'becario', 'coordinador']), ObservacionController.obtenerObservacionesBecario);
router.get('/supervisor', requireRole(['psicologo', 'coordinador']), ObservacionController.obtenerObservacionesSupervisor);

// Actualizar y eliminar observaciones
router.put('/:id', requireRole(['psicologo', 'coordinador']), ObservacionController.actualizarObservacion);
router.delete('/:id', requireRole(['psicologo', 'coordinador']), ObservacionController.eliminarObservacion);

module.exports = router;

/src\routes\pacienteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');
const Paciente = require('../models/pacienteModel');

// Listar pacientes (solo coordinadores)
router.get('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const pacientes = await Paciente.findAll({
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });

    const mapped = pacientes.map(p => ({
      id: p.id,
      nombre: p.nombre,
      apellido: p.apellido,
      email: p.email,
      telefono: p.telefono,
      fecha_nacimiento: p.fecha_nacimiento,
      genero: p.genero,
      direccion: p.direccion,
      estado: p.estado,
      activo: p.activo,
      notas: p.notas,
      fundacion_id: p.fundacion_id,
      fecha_ingreso: p.created_at,
      fecha_alta: p.deleted_at || null // placeholder if needed
    }));

    res.json(mapped);
  } catch (error) {
    console.error('Error al listar pacientes:', error);
    res.status(500).json({ message: 'Error al obtener pacientes' });
  }
});

// Crear paciente (solo coordinadores)
router.post('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const data = req.body;
    if (!data.nombre || !data.apellido || !data.motivo_consulta) {
      return res.status(400).json({ message: 'Faltan datos requeridos' });
    }

    const paciente = await Paciente.create({
      nombre: data.nombre,
      apellido: data.apellido,
      email: data.email || null,
      telefono: data.telefono || null,
      fecha_nacimiento: data.fecha_nacimiento || null,
      genero: data.genero || null,
      direccion: data.direccion || null,
      estado: data.estado || 'activo',
      activo: typeof data.activo === 'boolean' ? data.activo : true,
      notas: data.antecedentes || null,
      fundacion_id: data.fundacion_id || null
    });

    res.status(201).json({
      id: paciente.id,
      nombre: paciente.nombre,
      apellido: paciente.apellido,
      email: paciente.email,
      telefono: paciente.telefono,
      fecha_nacimiento: paciente.fecha_nacimiento,
      genero: paciente.genero,
      direccion: paciente.direccion,
      estado: paciente.estado,
      activo: paciente.activo,
      fecha_ingreso: paciente.created_at,
      sesiones_completadas: 0
    });
  } catch (error) {
    console.error('Error al crear paciente:', error);
    res.status(500).json({ message: 'Error al crear paciente' });
  }
});

// Actualizar paciente (solo coordinadores)
router.put('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const paciente = await Paciente.findByPk(id);
    if (!paciente) return res.status(404).json({ message: 'Paciente no encontrado' });

    const data = req.body;
    const updated = await paciente.update({
      nombre: data.nombre ?? paciente.nombre,
      apellido: data.apellido ?? paciente.apellido,
      email: data.email ?? paciente.email,
      telefono: data.telefono ?? paciente.telefono,
      fecha_nacimiento: data.fecha_nacimiento ?? paciente.fecha_nacimiento,
      genero: data.genero ?? paciente.genero,
      direccion: data.direccion ?? paciente.direccion,
      estado: data.estado ?? paciente.estado,
      activo: typeof data.activo === 'boolean' ? data.activo : paciente.activo,
      notas: data.antecedentes ?? paciente.notas,
      fundacion_id: data.fundacion_id ?? paciente.fundacion_id
    });

    res.json({
      id: updated.id,
      nombre: updated.nombre,
      apellido: updated.apellido,
      email: updated.email,
      telefono: updated.telefono,
      fecha_nacimiento: updated.fecha_nacimiento,
      genero: updated.genero,
      direccion: updated.direccion,
      estado: updated.estado,
      activo: updated.activo,
      fecha_ingreso: updated.created_at
    });
  } catch (error) {
    console.error('Error al actualizar paciente:', error);
    res.status(500).json({ message: 'Error al actualizar paciente' });
  }
});

// Eliminar paciente (soft-delete) (solo coordinadores)
router.delete('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const paciente = await Paciente.findByPk(id);
    if (!paciente) return res.status(404).json({ message: 'Paciente no encontrado' });

    await paciente.update({ activo: false, estado: 'alta_terapeutica' });

    res.json({ message: 'Paciente inactivado correctamente', id: paciente.id });
  } catch (error) {
    console.error('Error al eliminar paciente:', error);
    res.status(500).json({ message: 'Error al eliminar paciente' });
  }
});

module.exports = router;

/src\routes\reporteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ReporteController = require('../controllers/reporteController');

// Exportar agenda a CSV
router.post('/exportar-agenda-csv', ReporteController.exportarAgendaCSV);

// Exportar disponibilidad a CSV
router.post('/exportar-disponibilidad-csv', ReporteController.exportarDisponibilidadCSV);

// Generar reporte de conflictos
router.post('/reporte-conflictos', ReporteController.generarReporteConflictos);

module.exports = router;

/src\routes\roleRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const RoleController = require('../controllers/roleController');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Obtener permisos del usuario actual
router.get('/my-permissions', RoleController.getMyPermissions);

// Obtener información específica del rol
router.get('/my-role-info', RoleController.getUserRoleInfo);

// Verificar permiso específico
router.get('/check-permission/:permission', RoleController.checkPermission);

module.exports = router;

/src\routes\sesionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const SesionController = require('../controllers/sesionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Registrar sesión (solo psicólogos y coordinadores)
router.post('/', requireRole(['psicologo', 'coordinador']), SesionController.registrarSesion);

// Obtener sesiones
router.get('/paciente/:paciente_id', requireRole(['psicologo', 'becario', 'coordinador']), SesionController.obtenerSesionesPaciente);
router.get('/:id', requireRole(['psicologo', 'becario', 'coordinador']), SesionController.obtenerSesionDetalle);

// Actualizar sesión (solo psicólogo creador o coordinador)
router.put('/:id', requireRole(['psicologo', 'coordinador']), SesionController.actualizarSesion);

module.exports = router;

/src\routes\userRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');
const bcrypt = require('bcryptjs');
const User = require('../models/userModel');

// Obtener todos los becarios
router.get('/becarios', verifyToken, async (req, res) => {
  try {
    const becarios = await User.findAll({
      where: { rol: 'becario', activo: true },
      attributes: ['id', 'nombre', 'apellido', 'email'],
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });
    
    res.json(becarios);
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener becarios' });
  }
});

// Obtener todos los usuarios (coordinadores pueden acceder)
router.get('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: ['id', 'nombre', 'apellido', 'email', 'telefono', 'rol', 'especialidad', 'fundacion_id', 'activo', 'created_at'],
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });

    // Mapear created_at a fecha_registro para compatibilidad con frontend
    const mapped = users.map(u => ({
      id: u.id,
      nombre: u.nombre,
      apellido: u.apellido,
      email: u.email,
      telefono: u.telefono,
      rol: u.rol,
      especialidad: u.especialidad,
      fundacion_id: u.fundacion_id,
      activo: u.activo,
      fecha_registro: u.created_at
    }));

    res.json(mapped);
  } catch (error) {
    console.error('Error al listar usuarios:', error);
    res.status(500).json({ message: 'Error al obtener usuarios' });
  }
});

// Crear nuevo usuario (solo coordinadores)
router.post('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const { nombre, apellido, email, telefono, rol, especialidad, fundacion_id, activo, password } = req.body;

    if (!nombre || !apellido || !email || !password) {
      return res.status(400).json({ message: 'Faltan datos requeridos' });
    }

    // Hashear contraseña
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(password, salt);

    const newUser = await User.create({
      nombre,
      apellido,
      email,
      telefono,
      rol: rol || 'becario',
      especialidad,
      fundacion_id: fundacion_id || null,
      activo: typeof activo === 'boolean' ? activo : true,
      password: hashed
    });

    res.status(201).json({
      id: newUser.id,
      nombre: newUser.nombre,
      apellido: newUser.apellido,
      email: newUser.email,
      telefono: newUser.telefono,
      rol: newUser.rol,
      especialidad: newUser.especialidad,
      fundacion_id: newUser.fundacion_id,
      activo: newUser.activo,
      fecha_registro: newUser.created_at
    });

  } catch (error) {
    console.error('Error al crear usuario:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: 'El correo ya está registrado' });
    }
    res.status(500).json({ message: 'Error al crear usuario' });
  }
});

// Actualizar usuario (solo coordinadores)
router.put('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const { nombre, apellido, email, telefono, rol, especialidad, fundacion_id, activo, password } = req.body;

    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: 'Usuario no encontrado' });
    }

    const updatedFields = {
      nombre: nombre ?? user.nombre,
      apellido: apellido ?? user.apellido,
      email: email ?? user.email,
      telefono: telefono ?? user.telefono,
      rol: rol ?? user.rol,
      especialidad: especialidad ?? user.especialidad,
      fundacion_id: fundacion_id ?? user.fundacion_id,
      activo: typeof activo === 'boolean' ? activo : user.activo
    };

    // Si envían password, hashearla
    if (password) {
      const salt = await bcrypt.genSalt(10);
      updatedFields.password = await bcrypt.hash(password, salt);
    }

    await user.update(updatedFields);

    res.json({
      id: user.id,
      nombre: user.nombre,
      apellido: user.apellido,
      email: user.email,
      telefono: user.telefono,
      rol: user.rol,
      especialidad: user.especialidad,
      fundacion_id: user.fundacion_id,
      activo: user.activo,
      fecha_registro: user.created_at
    });
  } catch (error) {
    console.error('Error al actualizar usuario:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: 'El correo ya está registrado' });
    }
    res.status(500).json({ message: 'Error al actualizar usuario' });
  }
});

// Eliminar usuario (soft-delete colocando activo=false) (solo coordinadores)
router.delete('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: 'Usuario no encontrado' });
    }

    // Soft-delete
    await user.update({ activo: false });

    res.json({ message: 'Usuario eliminado (inactivado) correctamente', id: user.id });
  } catch (error) {
    console.error('Error al eliminar usuario:', error);
    res.status(500).json({ message: 'Error al eliminar usuario' });
  }
});

module.exports = router;

/src\services\api.js:
--------------------------------------------------------------------------------
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  static async get(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async post(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async put(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async delete(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async handleResponse(response) {
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Error en la petición');
    }
    return response.json();
  }
  static async getDashboardCoordinador() {
    return this.get('/dashboard/coordinador');
  }

  static async getMetricasGlobales(periodo = 'mes') {
    return this.get(`/dashboard/metricas-globales?periodo=${periodo}`);
  }

  static async getEstadisticas() {
    return this.get('/estadisticas/generales');
  }
}

export default ApiService;

/src\services\backupService.js:
--------------------------------------------------------------------------------
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class BackupService {
    
    static async realizarBackupCompleto() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupDir = path.join(__dirname, '..', '..', 'backups', timestamp);
            
            // Crear directorio de backup
            await fs.mkdir(backupDir, { recursive: true });
            
            console.log(`🔄 Iniciando backup completo: ${timestamp}`);
            
            // 1. Backup de base de datos
            const dbBackup = await this.realizarBackupBaseDatos(backupDir);
            
            // 2. Backup de archivos subidos
            const filesBackup = await this.realizarBackupArchivos(backupDir);
            
            // 3. Backup de configuración
            const configBackup = await this.realizarBackupConfiguracion(backupDir);
            
            // 4. Generar archivo de metadatos
            await this.generarMetadataBackup(backupDir, {
                timestamp,
                dbBackup,
                filesBackup,
                configBackup,
                sistema: 'PsicoGestión',
                version: '1.0.0'
            });
            
            // 5. Comprimir backup
            const compressedPath = await this.comprimirBackup(backupDir);
            
            // 6. Limpiar backup sin comprimir
            await fs.rm(backupDir, { recursive: true, force: true });
            
            // 7. Registrar en base de datos
            await this.registrarBackupEnBD({
                tipo: 'completo',
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size,
                estado: 'completado'
            });
            
            console.log(`✅ Backup completado: ${compressedPath}`);
            return {
                success: true,
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size
            };
            
        } catch (error) {
            console.error('❌ Error en backup completo:', error);
            throw error;
        }
    }
    
    static async realizarBackupBaseDatos(backupDir) {
        try {
            const dbConfig = {
                host: process.env.DB_HOST,
                user: process.env.DB_USER,
                password: process.env.DB_PASSWORD,
                database: process.env.DB_NAME
            };
            
            const dumpFile = path.join(backupDir, 'database.sql');
            
            // Comando mysqldump
            const command = `mysqldump --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} > "${dumpFile}"`;
            
            await execPromise(command);
            
            // Verificar que el archivo se creó
            const stats = await fs.stat(dumpFile);
            
            console.log(`✅ Backup de base de datos creado: ${dumpFile} (${stats.size} bytes)`);
            
            return {
                archivo: dumpFile,
                tamano: stats.size,
                tablas: await this.obtenerInfoTablas()
            };
            
        } catch (error) {
            console.error('❌ Error en backup de base de datos:', error);
            throw error;
        }
    }
    
    static async realizarBackupArchivos(backupDir) {
        try {
            const archivosDir = path.join(__dirname, '..', '..', 'uploads');
            const backupArchivosDir = path.join(backupDir, 'archivos');
            
            // Verificar si existe el directorio de archivos
            try {
                await fs.access(archivosDir);
            } catch {
                console.log('⚠️  No hay archivos subidos para backup');
                return { archivos: 0, tamano: 0 };
            }
            
            // Copiar archivos recursivamente
            await this.copiarDirectorioRecursivo(archivosDir, backupArchivosDir);
            
            // Calcular estadísticas
            const { totalArchivos, totalTamano } = await this.calcularEstadisticasArchivos(backupArchivosDir);
            
            console.log(`✅ Backup de archivos creado: ${totalArchivos} archivos (${totalTamano} bytes)`);
            
            return {
                directorio: backupArchivosDir,
                archivos: totalArchivos,
                tamano: totalTamano
            };
            
        } catch (error) {
            console.error('❌ Error en backup de archivos:', error);
            throw error;
        }
    }
    
    static async realizarBackupConfiguracion(backupDir) {
        try {
            const configDir = path.join(backupDir, 'configuracion');
            await fs.mkdir(configDir, { recursive: true });
            
            // Archivos de configuración importantes
            const archivosConfig = [
                '.env',
                'package.json',
                'package-lock.json',
                'server.js'
            ];
            
            let archivosCopiados = 0;
            
            for (const archivo of archivosConfig) {
                const sourcePath = path.join(__dirname, '..', '..', archivo);
                const destPath = path.join(configDir, archivo);
                
                try {
                    await fs.copyFile(sourcePath, destPath);
                    archivosCopiados++;
                } catch (error) {
                    console.warn(`⚠️  No se pudo copiar ${archivo}: ${error.message}`);
                }
            }
            
            // Crear archivo con información del sistema
            const systemInfo = {
                node_version: process.version,
                platform: process.platform,
                arch: process.arch,
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                fecha: new Date().toISOString()
            };
            
            await fs.writeFile(
                path.join(configDir, 'system-info.json'),
                JSON.stringify(systemInfo, null, 2)
            );
            
            console.log(`✅ Backup de configuración creado: ${archivosCopiados} archivos`);
            
            return {
                directorio: configDir,
                archivos: archivosCopiados + 1, // +1 por system-info.json
                tamano: await this.calcularTamanoDirectorio(configDir)
            };
            
        } catch (error) {
            console.error('❌ Error en backup de configuración:', error);
            throw error;
        }
    }
    
    static async realizarBackupIncremental() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupDir = path.join(__dirname, '..', '..', 'backups', `incremental-${timestamp}`);
            
            await fs.mkdir(backupDir, { recursive: true });
            
            console.log(`🔄 Iniciando backup incremental: ${timestamp}`);
            
            // Obtener último backup completo
            const ultimoBackup = await this.obtenerUltimoBackup('completo');
            
            // Backup solo de cambios desde el último backup completo
            const cambios = await this.obtenerCambiosDesdeUltimoBackup(ultimoBackup?.fecha);
            
            // Guardar cambios
            const cambiosFile = path.join(backupDir, 'cambios.json');
            await fs.writeFile(cambiosFile, JSON.stringify(cambios, null, 2));
            
            // Backup de nuevos archivos
            const nuevosArchivos = await this.realizarBackupArchivosNuevos(backupDir, cambios.archivos_nuevos);
            
            // Comprimir backup incremental
            const compressedPath = await this.comprimirBackup(backupDir);
            
            // Limpiar
            await fs.rm(backupDir, { recursive: true, force: true });
            
            // Registrar en BD
            await this.registrarBackupEnBD({
                tipo: 'incremental',
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size,
                base_backup_id: ultimoBackup?.id,
                cambios: cambios.cantidad_cambios,
                estado: 'completado'
            });
            
            console.log(`✅ Backup incremental completado: ${compressedPath}`);
            return {
                success: true,
                ruta: compressedPath,
                cambios: cambios.cantidad_cambios
            };
            
        } catch (error) {
            console.error('❌ Error en backup incremental:', error);
            throw error;
        }
    }
    
    static async restaurarBackup(backupId) {
        try {
            // Obtener información del backup
            const [backupInfo] = await sequelize.query(
                'SELECT * FROM backups WHERE id = ? AND estado = "completado"',
                { replacements: [backupId], type: QueryTypes.SELECT }
            );
            
            if (!backupInfo) {
                throw new Error('Backup no encontrado o incompleto');
            }
            
            console.log(`🔄 Iniciando restauración del backup: ${backupInfo.ruta}`);
            
            // 1. Descomprimir backup
            const tempDir = await this.descomprimirBackup(backupInfo.ruta);
            
            // 2. Verificar integridad
            await this.verificarIntegridadBackup(tempDir);
            
            // 3. Restaurar base de datos
            if (backupInfo.tipo === 'completo') {
                await this.restaurarBaseDatosCompleta(tempDir);
                await this.restaurarArchivosCompletos(tempDir);
                await this.restaurarConfiguracion(tempDir);
            } else {
                // Restaurar incremental sobre último backup completo
                await this.restaurarBackupIncremental(tempDir, backupInfo.base_backup_id);
            }
            
            // 4. Limpiar directorio temporal
            await fs.rm(tempDir, { recursive: true, force: true });
            
            // 5. Actualizar estado del backup
            await sequelize.query(
                'UPDATE backups SET ultima_restauracion = NOW() WHERE id = ?',
                { replacements: [backupId] }
            );
            
            console.log('✅ Restauración completada exitosamente');
            return { success: true };
            
        } catch (error) {
            console.error('❌ Error en restauración:', error);
            throw error;
        }
    }
    
    static async verificarBackups() {
        try {
            const backupsDir = path.join(__dirname, '..', '..', 'backups');
            
            // Verificar que exista el directorio
            await fs.access(backupsDir);
            
            // Obtener lista de backups
            const archivos = await fs.readdir(backupsDir);
            const backups = archivos.filter(archivo => archivo.endsWith('.zip'));
            
            // Verificar integridad de cada backup
            const resultados = [];
            
            for (const backup of backups) {
                const backupPath = path.join(backupsDir, backup);
                const stats = await fs.stat(backupPath);
                
                const resultado = {
                    archivo: backup,
                    tamano: stats.size,
                    modificado: stats.mtime,
                    valido: await this.verificarIntegridadArchivo(backupPath)
                };
                
                resultados.push(resultado);
            }
            
            // Verificar en base de datos
            const [backupsDB] = await sequelize.query(
                'SELECT COUNT(*) as total, SUM(tamano) as total_tamano FROM backups WHERE estado = "completado"',
                { type: QueryTypes.SELECT }
            );
            
            return {
                backups_fs: resultados,
                backups_db: backupsDB,
                espacio_total: await this.calcularEspacioDisco(backupsDir),
                recomendaciones: this.generarRecomendacionesBackup(resultados)
            };
            
        } catch (error) {
            console.error('❌ Error al verificar backups:', error);
            throw error;
        }
    }
    
    static async limpiarBackupsAntiguos(dias = 30) {
        try {
            const backupsDir = path.join(__dirname, '..', '..', 'backups');
            const fechaLimite = new Date(Date.now() - dias * 24 * 60 * 60 * 1000);
            
            const archivos = await fs.readdir(backupsDir);
            let eliminados = 0;
            let espacioLiberado = 0;
            
            for (const archivo of archivos) {
                if (archivo.endsWith('.zip')) {
                    const archivoPath = path.join(backupsDir, archivo);
                    const stats = await fs.stat(archivoPath);
                    
                    if (stats.mtime < fechaLimite) {
                        await fs.unlink(archivoPath);
                        eliminados++;
                        espacioLiberado += stats.size;
                        
                        // Actualizar estado en BD
                        await sequelize.query(
                            'UPDATE backups SET estado = "eliminado" WHERE ruta LIKE ?',
                            { replacements: [`%${archivo}%`] }
                        );
                    }
                }
            }
            
            console.log(`🧹 Limpieza de backups: ${eliminados} eliminados, ${this.formatearBytes(espacioLiberado)} liberados`);
            
            return {
                eliminados,
                espacio_liberado: espacioLiberado,
                espacio_formateado: this.formatearBytes(espacioLiberado)
            };
            
        } catch (error) {
            console.error('❌ Error al limpiar backups antiguos:', error);
            throw error;
        }
    }
    
    // Métodos auxiliares
    static async obtenerInfoTablas() {
        const [tablas] = await sequelize.query(`
            SELECT 
                TABLE_NAME as tabla,
                TABLE_ROWS as filas,
                DATA_LENGTH as tamano_datos,
                INDEX_LENGTH as tamano_indices,
                CREATE_TIME as creada,
                UPDATE_TIME as actualizada
            FROM information_schema.TABLES
            WHERE TABLE_SCHEMA = ?
            ORDER BY TABLE_NAME
        `, {
            replacements: [process.env.DB_NAME],
            type: QueryTypes.SELECT
        });
        
        return tablas;
    }
    
    static async copiarDirectorioRecursivo(origen, destino) {
        await fs.mkdir(destino, { recursive: true });
        
        const elementos = await fs.readdir(origen, { withFileTypes: true });
        
        for (const elemento of elementos) {
            const sourcePath = path.join(origen, elemento.name);
            const destPath = path.join(destino, elemento.name);
            
            if (elemento.isDirectory()) {
                await this.copiarDirectorioRecursivo(sourcePath, destPath);
            } else {
                await fs.copyFile(sourcePath, destPath);
            }
        }
    }
    
    static async calcularEstadisticasArchivos(directorio) {
        let totalArchivos = 0;
        let totalTamano = 0;
        
        async function calcularRecursivo(dir) {
            const elementos = await fs.readdir(dir, { withFileTypes: true });
            
            for (const elemento of elementos) {
                const elementoPath = path.join(dir, elemento.name);
                
                if (elemento.isDirectory()) {
                    await calcularRecursivo(elementoPath);
                } else {
                    const stats = await fs.stat(elementoPath);
                    totalArchivos++;
                    totalTamano += stats.size;
                }
            }
        }
        
        await calcularRecursivo(directorio);
        return { totalArchivos, totalTamano };
    }
    
    static async calcularTamanoDirectorio(directorio) {
        const { totalTamano } = await this.calcularEstadisticasArchivos(directorio);
        return totalTamano;
    }
    
    static async generarMetadataBackup(backupDir, metadata) {
        const metadataFile = path.join(backupDir, 'metadata.json');
        await fs.writeFile(metadataFile, JSON.stringify(metadata, null, 2));
    }
    
    static async comprimirBackup(directorio) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const zipFile = path.join(path.dirname(directorio), `backup-${timestamp}.zip`);
        
        const command = `cd "${path.dirname(directorio)}" && zip -r "${zipFile}" "${path.basename(directorio)}"`;
        
        await execPromise(command);
        return zipFile;
    }
    
    static async registrarBackupEnBD(datos) {
        await sequelize.query(`
            INSERT INTO backups (tipo, ruta, tamano, base_backup_id, cambios, estado, created_at)
            VALUES (?, ?, ?, ?, ?, ?, NOW())
        `, {
            replacements: [
                datos.tipo,
                datos.ruta,
                datos.tamano,
                datos.base_backup_id || null,
                datos.cambios || 0,
                datos.estado
            ]
        });
    }
    
    static async obtenerUltimoBackup(tipo) {
        const [backup] = await sequelize.query(`
            SELECT * FROM backups 
            WHERE tipo = ? AND estado = 'completado'
            ORDER BY created_at DESC 
            LIMIT 1
        `, {
            replacements: [tipo],
            type: QueryTypes.SELECT
        });
        
        return backup;
    }
    
    static async obtenerCambiosDesdeUltimoBackup(fechaUltimoBackup) {
        if (!fechaUltimoBackup) {
            return { cantidad_cambios: 0, archivos_nuevos: [] };
        }
        
        // Obtener citas nuevas/modificadas
        const [citasCambiadas] = await sequelize.query(`
            SELECT COUNT(*) as cantidad FROM citas 
            WHERE created_at > ? OR updated_at > ?
        `, {
            replacements: [fechaUltimoBackup, fechaUltimoBackup],
            type: QueryTypes.SELECT
        });
        
        // Obtener pacientes nuevos/modificados
        const [pacientesCambiados] = await sequelize.query(`
            SELECT COUNT(*) as cantidad FROM pacientes 
            WHERE created_at > ? OR updated_at > ?
        `, {
            replacements: [fechaUltimoBackup, fechaUltimoBackup],
            type: QueryTypes.SELECT
        });
        
        // Obtener archivos nuevos (simplificado)
        const archivosNuevos = await this.obtenerArchivosNuevosDesde(fechaUltimoBackup);
        
        return {
            cantidad_cambios: (citasCambiadas?.cantidad || 0) + (pacientesCambiados?.cantidad || 0),
            citas_nuevas: citasCambiadas?.cantidad || 0,
            pacientes_nuevos: pacientesCambiados?.cantidad || 0,
            archivos_nuevos: archivosNuevos
        };
    }
    
    static async obtenerArchivosNuevosDesde(fecha) {
        // Esta función necesitaría un sistema de tracking de archivos
        // Por ahora retorna array vacío
        return [];
    }
    
    static async realizarBackupArchivosNuevos(backupDir, archivosNuevos) {
        if (!archivosNuevos || archivosNuevos.length === 0) {
            return { archivos: 0, tamano: 0 };
        }
        
        const archivosDir = path.join(backupDir, 'archivos_nuevos');
        await fs.mkdir(archivosDir, { recursive: true });
        
        let totalCopiados = 0;
        
        for (const archivo of archivosNuevos) {
            try {
                const sourcePath = path.join(__dirname, '..', '..', 'uploads', archivo);
                const destPath = path.join(archivosDir, archivo);
                
                await fs.copyFile(sourcePath, destPath);
                totalCopiados++;
            } catch (error) {
                console.warn(`⚠️  No se pudo copiar archivo ${archivo}: ${error.message}`);
            }
        }
        
        return {
            directorio: archivosDir,
            archivos: totalCopiados,
            tamano: await this.calcularTamanoDirectorio(archivosDir)
        };
    }
    
    static async descomprimirBackup(backupPath) {
        const tempDir = path.join(__dirname, '..', '..', 'temp-restore', Date.now().toString());
        await fs.mkdir(tempDir, { recursive: true });
        
        const command = `unzip "${backupPath}" -d "${tempDir}"`;
        await execPromise(command);
        
        // Buscar el directorio descomprimido
        const elementos = await fs.readdir(tempDir, { withFileTypes: true });
        const directorioDescomprimido = elementos.find(e => e.isDirectory())?.name;
        
        if (!directorioDescomprimido) {
            throw new Error('No se encontró directorio descomprimido');
        }
        
        return path.join(tempDir, directorioDescomprimido);
    }
    
    static async verificarIntegridadBackup(directorio) {
        // Verificar archivos esenciales
        const archivosEsenciales = ['database.sql', 'metadata.json'];
        
        for (const archivo of archivosEsenciales) {
            const archivoPath = path.join(directorio, archivo);
            try {
                await fs.access(archivoPath);
            } catch {
                throw new Error(`Archivo esencial faltante: ${archivo}`);
            }
        }
        
        // Verificar metadata
        const metadataPath = path.join(directorio, 'metadata.json');
        const metadataContent = await fs.readFile(metadataPath, 'utf8');
        const metadata = JSON.parse(metadataContent);
        
        if (!metadata.sistema || !metadata.version) {
            throw new Error('Metadata inválida');
        }
        
        console.log('✅ Integridad del backup verificada');
        return true;
    }
    
    static async verificarIntegridadArchivo(backupPath) {
        try {
            // Verificar que el archivo existe y es legible
            await fs.access(backupPath);
            
            // Verificar estructura ZIP básica
            const command = `unzip -t "${backupPath}"`;
            await execPromise(command);
            
            return true;
        } catch (error) {
            return false;
        }
    }
    
    static async restaurarBaseDatosCompleta(directorioBackup) {
        const dbFile = path.join(directorioBackup, 'database.sql');
        
        if (!await fs.access(dbFile).then(() => true).catch(() => false)) {
            throw new Error('Archivo de base de datos no encontrado en backup');
        }
        
        const dbConfig = {
            host: process.env.DB_HOST,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME
        };
        
        // Primero crear una copia de seguridad actual (por si acaso)
        const backupActual = await this.realizarBackupBaseDatos(path.join(__dirname, '..', '..', 'temp'));
        
        try {
            // Restaurar base de datos
            const command = `mysql --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} < "${dbFile}"`;
            await execPromise(command);
            
            console.log('✅ Base de datos restaurada');
        } catch (error) {
            // Restaurar backup actual en caso de error
            console.error('❌ Error al restaurar base de datos, restaurando backup anterior...');
            const restoreCommand = `mysql --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} < "${backupActual.archivo}"`;
            await execPromise(restoreCommand);
            throw error;
        }
    }
    
    static async restaurarArchivosCompletos(directorioBackup) {
        const archivosDir = path.join(directorioBackup, 'archivos');
        
        if (await fs.access(archivosDir).then(() => true).catch(() => false)) {
            const uploadsDir = path.join(__dirname, '..', '..', 'uploads');
            
            // Crear backup de archivos actuales
            await fs.rename(uploadsDir, `${uploadsDir}.backup.${Date.now()}`);
            
            // Restaurar archivos del backup
            await this.copiarDirectorioRecursivo(archivosDir, uploadsDir);
            
            console.log('✅ Archivos restaurados');
        }
    }
    
    static async restaurarConfiguracion(directorioBackup) {
        const configDir = path.join(directorioBackup, 'configuracion');
        
        if (await fs.access(configDir).then(() => true).catch(() => false)) {
            // Solo restaurar archivos específicos si es necesario
            console.log('⚠️  Configuración disponible para restauración manual');
        }
    }
    
    static async restaurarBackupIncremental(directorioBackup, baseBackupId) {
        // Implementación de restauración incremental
        // Requiere lógica más compleja de aplicación de cambios
        console.log('🔄 Restaurando backup incremental...');
        // Por ahora, solo log
    }
    
    static async calcularEspacioDisco(directorio) {
        const command = `df -h "${directorio}" | tail -1 | awk '{print $4}'`;
        try {
            const { stdout } = await execPromise(command);
            return stdout.trim();
        } catch {
            return 'Desconocido';
        }
    }
    
    static generarRecomendacionesBackup(backups) {
        const recomendaciones = [];
        
        if (backups.length === 0) {
            recomendaciones.push('No hay backups existentes. Se recomienda crear un backup completo inmediatamente.');
        }
        
        if (backups.length > 10) {
            recomendaciones.push('Muchos backups almacenados. Considere eliminar los más antiguos.');
        }
        
        const backupsInvalidos = backups.filter(b => !b.valido);
        if (backupsInvalidos.length > 0) {
            recomendaciones.push(`Hay ${backupsInvalidos.length} backups inválidos. Considere eliminarlos.`);
        }
        
        return recomendaciones;
    }
    
    static formatearBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

module.exports = BackupService;

/src\services\calendarioService.js:
--------------------------------------------------------------------------------
const { google } = require('googleapis');
const { OAuth2 } = google.auth;
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class CalendarioService {
    
    static oAuth2Client = null;
    static calendar = null;
    
    static async inicializar() {
        try {
            if (!process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET || !process.env.GOOGLE_REDIRECT_URI) {
                console.warn('Credenciales de Google Calendar no configuradas');
                return false;
            }
            
            this.oAuth2Client = new OAuth2(
                process.env.GOOGLE_CLIENT_ID,
                process.env.GOOGLE_CLIENT_SECRET,
                process.env.GOOGLE_REDIRECT_URI
            );
            
            // Configurar tokens si existen
            if (process.env.GOOGLE_ACCESS_TOKEN && process.env.GOOGLE_REFRESH_TOKEN) {
                this.oAuth2Client.setCredentials({
                    access_token: process.env.GOOGLE_ACCESS_TOKEN,
                    refresh_token: process.env.GOOGLE_REFRESH_TOKEN
                });
            }
            
            this.calendar = google.calendar({ version: 'v3', auth: this.oAuth2Client });
            
            console.log('✅ Servicio de Google Calendar inicializado');
            return true;
            
        } catch (error) {
            console.error('❌ Error al inicializar Google Calendar:', error);
            return false;
        }
    }
    
    static async sincronizarCitaConGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no está inicializado');
                return false;
            }
            
            // Obtener datos de la cita
            const [cita] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                    u_psi.email as psicologo_email,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                    u_bec.email as becario_email
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = ?
            `, {
                replacements: [citaId],
                type: QueryTypes.SELECT
            });
            
            if (!cita) {
                throw new Error('Cita no encontrada');
            }
            
            // Crear evento en Google Calendar
            const evento = {
                summary: `Sesión psicológica - ${cita.paciente_nombre}`,
                description: this.generarDescripcionEvento(cita),
                start: {
                    dateTime: `${cita.fecha}T${cita.hora}:00`,
                    timeZone: 'America/Mexico_City'
                },
                end: {
                    dateTime: this.calcularHoraFin(cita.fecha, cita.hora, cita.duracion_minutos || 50),
                    timeZone: 'America/Mexico_City'
                },
                attendees: this.obtenerAsistentes(cita),
                reminders: {
                    useDefault: false,
                    overrides: [
                        { method: 'email', minutes: 24 * 60 }, // 1 día antes
                        { method: 'popup', minutes: 30 } // 30 minutos antes
                    ]
                },
                colorId: cita.tipo_consulta === 'virtual' ? '5' : '2' // Color diferente para virtual
            };
            
            const response = await this.calendar.events.insert({
                calendarId: 'primary',
                resource: evento,
                sendUpdates: 'all'
            });
            
            // Guardar ID del evento en la cita
            await sequelize.query(
                'UPDATE citas SET google_calendar_event_id = ? WHERE id = ?',
                { replacements: [response.data.id, citaId] }
            );
            
            console.log(`✅ Cita ${citaId} sincronizada con Google Calendar: ${response.data.htmlLink}`);
            return response.data;
            
        } catch (error) {
            console.error('❌ Error al sincronizar cita con Google Calendar:', error);
            throw error;
        }
    }
    
    static async actualizarEventoGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no está inicializado');
                return false;
            }
            
            // Obtener cita con ID del evento
            const [cita] = await sequelize.query(
                'SELECT google_calendar_event_id FROM citas WHERE id = ?',
                { replacements: [citaId], type: QueryTypes.SELECT }
            );
            
            if (!cita || !cita.google_calendar_event_id) {
                // Si no tiene evento, crear uno nuevo
                return await this.sincronizarCitaConGoogleCalendar(citaId);
            }
            
            // Obtener datos actualizados de la cita
            const [citaActualizada] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                    u_psi.email as psicologo_email,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                    u_bec.email as becario_email
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = ?
            `, {
                replacements: [citaId],
                type: QueryTypes.SELECT
            });
            
            // Actualizar evento
            const evento = {
                summary: `Sesión psicológica - ${citaActualizada.paciente_nombre}`,
                description: this.generarDescripcionEvento(citaActualizada),
                start: {
                    dateTime: `${citaActualizada.fecha}T${citaActualizada.hora}:00`,
                    timeZone: 'America/Mexico_City'
                },
                end: {
                    dateTime: this.calcularHoraFin(citaActualizada.fecha, citaActualizada.hora, citaActualizada.duracion_minutos || 50),
                    timeZone: 'America/Mexico_City'
                },
                attendees: this.obtenerAsistentes(citaActualizada),
                colorId: citaActualizada.tipo_consulta === 'virtual' ? '5' : '2'
            };
            
            const response = await this.calendar.events.update({
                calendarId: 'primary',
                eventId: cita.google_calendar_event_id,
                resource: evento,
                sendUpdates: 'all'
            });
            
            console.log(`✅ Evento de cita ${citaId} actualizado en Google Calendar`);
            return response.data;
            
        } catch (error) {
            console.error('❌ Error al actualizar evento en Google Calendar:', error);
            throw error;
        }
    }
    
    static async eliminarEventoGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no está inicializado');
                return false;
            }
            
            // Obtener ID del evento
            const [cita] = await sequelize.query(
                'SELECT google_calendar_event_id FROM citas WHERE id = ?',
                { replacements: [citaId], type: QueryTypes.SELECT }
            );
            
            if (!cita || !cita.google_calendar_event_id) {
                return true; // No hay evento que eliminar
            }
            
            // Eliminar evento
            await this.calendar.events.delete({
                calendarId: 'primary',
                eventId: cita.google_calendar_event_id,
                sendUpdates: 'all'
            });
            
            // Limpiar ID del evento en la cita
            await sequelize.query(
                'UPDATE citas SET google_calendar_event_id = NULL WHERE id = ?',
                { replacements: [citaId] }
            );
            
            console.log(`✅ Evento de cita ${citaId} eliminado de Google Calendar`);
            return true;
            
        } catch (error) {
            console.error('❌ Error al eliminar evento de Google Calendar:', error);
            throw error;
        }
    }
    
    static async obtenerDisponibilidadProfesional(usuarioId, fecha) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no está inicializado');
                return null;
            }
            
            // Obtener email del profesional
            const [profesional] = await sequelize.query(
                'SELECT email FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!profesional || !profesional.email) {
                throw new Error('Profesional no encontrado o sin email');
            }
            
            // Obtener eventos del profesional para la fecha
            const inicio = new Date(`${fecha}T00:00:00`);
            const fin = new Date(`${fecha}T23:59:59`);
            
            const response = await this.calendar.events.list({
                calendarId: profesional.email,
                timeMin: inicio.toISOString(),
                timeMax: fin.toISOString(),
                singleEvents: true,
                orderBy: 'startTime'
            });
            
            return response.data.items.map(evento => ({
                inicio: evento.start.dateTime || evento.start.date,
                fin: evento.end.dateTime || evento.end.date,
                titulo: evento.summary,
                descripcion: evento.description
            }));
            
        } catch (error) {
            console.error('❌ Error al obtener disponibilidad de Google Calendar:', error);
            throw error;
        }
    }
    
    static async sincronizarAgendaCompleta(psicologoId, fechaInicio, fechaFin) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no está inicializado');
                return false;
            }
            
            // Obtener citas del psicólogo en el rango de fechas
            const citas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    c.hora,
                    c.duracion_minutos,
                    c.tipo_consulta,
                    c.estado,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    c.google_calendar_event_id
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.psicologo_id = ?
                AND c.fecha BETWEEN ? AND ?
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
            `, {
                replacements: [psicologoId, fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            const resultados = {
                creados: 0,
                actualizados: 0,
                errores: 0
            };
            
            // Sincronizar cada cita
            for (const cita of citas) {
                try {
                    if (cita.google_calendar_event_id) {
                        await this.actualizarEventoGoogleCalendar(cita.id);
                        resultados.actualizados++;
                    } else {
                        await this.sincronizarCitaConGoogleCalendar(cita.id);
                        resultados.creados++;
                    }
                } catch (error) {
                    console.error(`❌ Error al sincronizar cita ${cita.id}:`, error.message);
                    resultados.errores++;
                }
            }
            
            console.log(`✅ Agenda sincronizada: ${resultados.creados} creados, ${resultados.actualizados} actualizados, ${resultados.errores} errores`);
            return resultados;
            
        } catch (error) {
            console.error('❌ Error al sincronizar agenda completa:', error);
            throw error;
        }
    }
    
    // Métodos auxiliares
    static generarDescripcionEvento(cita) {
        let descripcion = `Sesión psicológica con ${cita.paciente_nombre}\n`;
        descripcion += `Tipo: ${cita.tipo_consulta === 'virtual' ? 'Virtual' : 'Presencial'}\n`;
        descripcion += `Estado: ${cita.estado}\n`;
        descripcion += `Psicólogo: ${cita.psicologo_nombre}\n`;
        
        if (cita.becario_nombre) {
            descripcion += `Becario: ${cita.becario_nombre}\n`;
        }
        
        if (cita.notas) {
            descripcion += `\nNotas: ${cita.notas}\n`;
        }
        
        descripcion += `\nID de cita: ${cita.id}`;
        return descripcion;
    }
    
    static calcularHoraFin(fecha, hora, duracionMinutos) {
        const [horas, minutos] = hora.split(':').map(Number);
        const fechaHora = new Date(`${fecha}T${hora.padStart(5, '0')}:00`);
        fechaHora.setMinutes(fechaHora.getMinutes() + duracionMinutos);
        
        return fechaHora.toISOString();
    }
    
    static obtenerAsistentes(cita) {
        const asistentes = [];
        
        // Paciente
        if (cita.paciente_email) {
            asistentes.push({ email: cita.paciente_email, displayName: cita.paciente_nombre });
        }
        
        // Psicólogo
        if (cita.psicologo_email) {
            asistentes.push({ email: cita.psicologo_email, displayName: cita.psicologo_nombre });
        }
        
        // Becario
        if (cita.becario_email) {
            asistentes.push({ email: cita.becario_email, displayName: cita.becario_nombre });
        }
        
        return asistentes;
    }
    
    static async obtenerUrlAutorizacion() {
        if (!this.oAuth2Client) {
            throw new Error('OAuth2 no inicializado');
        }
        
        const url = this.oAuth2Client.generateAuthUrl({
            access_type: 'offline',
            scope: [
                'https://www.googleapis.com/auth/calendar',
                'https://www.googleapis.com/auth/calendar.events'
            ]
        });
        
        return url;
    }
    
    static async intercambiarCodigoPorToken(codigo) {
        if (!this.oAuth2Client) {
            throw new Error('OAuth2 no inicializado');
        }
        
        const { tokens } = await this.oAuth2Client.getToken(codigo);
        this.oAuth2Client.setCredentials(tokens);
        
        return tokens;
    }
}

// Inicializar al cargar el módulo
CalendarioService.inicializar().catch(console.error);

module.exports = CalendarioService;

/src\services\dashboardService.js:
--------------------------------------------------------------------------------
// frontend/src/services/dashboardService.js
import ApiService from './api';

class DashboardService {
  static async obtenerDashboardCoordinador() {
    try {
      const response = await ApiService.getDashboardCoordinador();
      return response.data;
    } catch (error) {
      console.error('Error obteniendo dashboard coordinador:', error);
      throw error;
    }
  }

  static async obtenerMetricasGlobales(periodo = 'mes') {
    try {
      const response = await ApiService.getMetricasGlobales(periodo);
      return response.data;
    } catch (error) {
      console.error('Error obteniendo métricas globales:', error);
      throw error;
    }
  }

  static async obtenerEstadisticas() {
    try {
      const response = await ApiService.getEstadisticas();
      return response.data;
    } catch (error) {
      console.error('Error obteniendo estadísticas:', error);
      throw error;
    }
  }

  // Método para transformar los datos del backend al formato que usa el frontend
  static transformarDatosCoordinador(datosBackend) {
    const { estadisticas, top_psicologos, alertas, evolucion_mensual, citas_por_dia } = datosBackend;
    
    // Transformar estadísticas principales
    const estadisticasTransformadas = {
      becariosActivos: estadisticas.becarios_activos || 0,
      psicologosActivos: estadisticas.psicologos_activos || 0,
      pacientesActivos: estadisticas.pacientes_activos || 0,
      citasHoy: estadisticas.citas_hoy || 0,
      citasCompletadasHoy: estadisticas.citas_completadas_hoy || 0,
      altasMesActual: estadisticas.altas_mes || 0
    };

    // Transformar actividad reciente (puedes obtener esto de otra fuente o simularlo)
    const actividadReciente = this.generarActividadReciente(datosBackend);

    // Transformar distribución de citas por psicólogo
    const distribucionPsicologos = top_psicologos.map(psicologo => ({
      nombre: psicologo.nombre_completo,
      citas: psicologo.total_citas || 0,
      color: this.asignarColor(psicologo.id)
    }));

    // Transformar alertas
    const alertasTransformadas = alertas.map(alerta => ({
      tipo: alerta.tipo,
      descripcion: alerta.descripcion,
      cantidad: alerta.cantidad
    }));

    return {
      estadisticas: estadisticasTransformadas,
      actividadReciente,
      distribucionPsicologos,
      alertas: alertasTransformadas,
      evolucionMensual: evolucion_mensual,
      citasPorDia: citas_por_dia
    };
  }

  static asignarColor(id) {
    const colores = ['var(--grnb)', 'var(--blu)', 'var(--yy)', 'var(--grnd)', 'var(--grnl)', 'var(--rr)'];
    return colores[id % colores.length];
  }

  static generarActividadReciente(datosBackend) {
    // Aquí puedes implementar lógica para generar actividad reciente
    // basada en los datos del backend, logs, o mantenerlo simulado
    // por ahora devolveré datos de ejemplo transformados
    const actividades = [];
    
    // Ejemplo: si hay nuevas altas hoy
    if (datosBackend.estadisticas.altas_hoy > 0) {
      actividades.push({
        id: 1,
        tipo: 'alta_paciente',
        descripcion: `${datosBackend.estadisticas.altas_hoy} paciente(s) dado(s) de alta hoy`,
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      });
    }

    // Ejemplo: si hay pacientes nuevos hoy
    if (datosBackend.estadisticas.pacientes_nuevos_hoy > 0) {
      actividades.push({
        id: 2,
        tipo: 'nuevo_paciente',
        descripcion: `${datosBackend.estadisticas.pacientes_nuevos_hoy} nuevo(s) paciente(s) registrado(s) hoy`,
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      });
    }

    return actividades.length > 0 ? actividades : [
      {
        id: 1,
        tipo: 'sistema',
        descripcion: 'Dashboard sincronizado con datos reales',
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      }
    ];
  }
}

export default DashboardService;

/src\services\databaseService.js:
--------------------------------------------------------------------------------
const sequelize = require('../config/db');
const { QueryTypes } = require('sequelize');

class DatabaseService {
    
    static async obtenerCitasPorFechaBecario(fecha, becarioId = null) {
        try {
            let query = `
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    p.email AS paciente_email,
                    u_psi.nombre AS psicologo_nombre,
                    u_bec.nombre AS becario_nombre,
                    c.duracion_minutos AS duracion,  -- Cambia duracion_minutos a duracion
                    c.motivo AS notas,               -- Cambia motivo a notas
                    TIME_FORMAT(c.hora, '%H:%i') AS hora_formatted  -- Formatea la hora
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE DATE(c.fecha) = :fecha
            `;
            
            const params = { fecha };
            
            if (becarioId !== null && becarioId !== undefined) {
                query += ` AND c.becario_id = :becarioId`;
                params.becarioId = becarioId;
            }
            
            query += ` ORDER BY c.hora`;
            
            const results = await sequelize.query(query, {
                replacements: params,
                type: QueryTypes.SELECT
            });
            
            // Mapea los resultados para usar los nombres correctos
            return results.map(row => {
                return {
                    ...row,
                    hora: row.hora_formatted,  // Usa la hora formateada
                    duracion: row.duracion || 50,
                    notas: row.notas || ''
                };
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFechaBecario:', error);
            throw error;
        }
    }
    // En /src/services/databaseService.js
    static async crearNuevaCita(datosCita) {
        const transaction = await sequelize.transaction();
        
        try {
            console.log('🔧 Creando nueva cita con datos:', datosCita);
            
            // 1. Buscar o crear el paciente
            let paciente;
            
            // Primero intentar buscar por nombre y apellido
            const [pacienteExistente] = await sequelize.query(`
                SELECT id FROM pacientes 
                WHERE LOWER(nombre) = LOWER(:nombre) 
                AND LOWER(apellido) = LOWER(:apellido)
                LIMIT 1
            `, {
                replacements: {
                    nombre: datosCita.paciente.nombre.trim(),
                    apellido: datosCita.paciente.apellido.trim()
                },
                transaction
            });
            
            if (pacienteExistente && pacienteExistente.length > 0) {
                // Usar paciente existente
                paciente = pacienteExistente[0];
                console.log('✅ Usando paciente existente:', paciente);
            } else {
                // Crear nuevo paciente
                console.log('📋 Creando nuevo paciente');
                const [resultadoPaciente] = await sequelize.query(`
                    INSERT INTO pacientes (
                        nombre, apellido, email, telefono, estado, activo, created_at
                    ) VALUES (
                        :nombre, :apellido, :email, :telefono, 'activo', TRUE, NOW()
                    )
                    `, {
                    replacements: {
                        nombre: datosCita.paciente.nombre.trim(),
                        apellido: datosCita.paciente.apellido.trim(),
                        email: datosCita.paciente.email || null,
                        telefono: datosCita.paciente.telefono || null
                    },
                    transaction
                    });

                    const [[pacienteInsertado]] = await sequelize.query(
                    'SELECT LAST_INSERT_ID() AS id',
                    { transaction }
                    );

                    paciente = { id: pacienteInsertado.id };

                console.log('✅ Nuevo paciente creado con ID:', paciente.id);
            }
            
            // 2. Verificar que el becario existe si se especificó
            if (datosCita.becario_id) {
                const [becario] = await sequelize.query(`
                    SELECT id FROM users WHERE id = :becario_id AND rol = 'becario'
                `, {
                    replacements: { becario_id: datosCita.becario_id },
                    transaction
                });
                
                if (!becario || becario.length === 0) {
                    throw new Error('El becario especificado no existe');
                }
            }
            
            // 3. Verificar que no haya conflicto de horario
            const [citasConflicto] = await sequelize.query(`
                SELECT id FROM citas 
                WHERE fecha = :fecha 
                AND hora = :hora 
                AND estado IN ('programada', 'confirmada')
                AND becario_id = :becario_id
            `, {
                replacements: {
                    fecha: datosCita.fecha,
                    hora: datosCita.hora + ':00', // Asegurar formato HH:MM:SS
                    becario_id: datosCita.becario_id || null
                },
                transaction
            });
            
            if (citasConflicto && citasConflicto.length > 0) {
                throw new Error('Ya existe una cita programada para este horario con este becario');
            }
            
            // 4. Crear la cita
            await sequelize.query(`
                INSERT INTO citas (
                    paciente_id,
                    psicologo_id,
                    becario_id,
                    fecha,
                    hora,
                    duracion_minutos,
                    tipo_consulta,
                    estado,
                    motivo,
                    created_at
                ) VALUES (
                    :paciente_id,
                    :psicologo_id,
                    :becario_id,
                    :fecha,
                    :hora,
                    :duracion_minutos,
                    :tipo_consulta,
                    :estado,
                    :motivo,
                    NOW()
                )
            `, {
                replacements: {
                    paciente_id: paciente.id,
                    psicologo_id: datosCita.usuarioId,
                    becario_id: datosCita.becario_id || null,
                    fecha: datosCita.fecha,
                    hora: datosCita.hora,
                    duracion_minutos: datosCita.duracion || 50,
                    tipo_consulta: datosCita.tipo_consulta,
                    estado: 'programada',
                    motivo: datosCita.notas || null
                },
                transaction
            });

            const [[citaInsertada]] = await sequelize.query(
                'SELECT LAST_INSERT_ID() AS id',
                { transaction }
            );

            
            // 5. Obtener la cita creada con información del paciente
            const [citaCreada] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    u_bec.nombre AS becario_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = :cita_id
            `, {
                replacements: { cita_id: citaInsertada.id },
                transaction
            });
            
            // 6. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'nueva_cita', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId: datosCita.usuarioId,
                    pacienteId: paciente.id,
                    descripcion: `Nueva cita creada para ${datosCita.fecha} ${datosCita.hora}` 
                },
                transaction
            });
            
            await transaction.commit();
            console.log('✅ Cita creada exitosamente');
            
            return citaCreada[0];
            
        } catch (error) {
            await transaction.rollback();
            console.error('❌ Error en crearNuevaCita:', error);
            throw error;
        }
    }
    

    /**
     * Reemplaza: sp_generar_reporte_mensual
     */
    static async generarReporteMensual(mes, anio, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
                    COUNT(c.id) AS total_sesiones,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS sesiones_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) AS sesiones_canceladas,
                    SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) AS sesiones_programadas,
                    MIN(c.fecha) AS primera_sesion_mes,
                    MAX(c.fecha) AS ultima_sesion_mes
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id 
                    AND MONTH(c.fecha) = :mes 
                    AND YEAR(c.fecha) = :anio
            `;
            
            const params = { mes, anio };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND c.psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            query += `
                WHERE p.activo = TRUE
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY p.apellido, p.nombre
            `;
            
            const [results] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return results;
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_insert_alta
     * Realiza transacción atómica para dar de alta paciente
     */
    static async darAltaPaciente(pacienteId, tipoAlta, usuarioId, notas = null) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Insertar en altas
            await sequelize.query(`
                INSERT INTO altas (paciente_id, tipo_alta, usuario_id, notas, created_at)
                VALUES (:pacienteId, :tipoAlta, :usuarioId, :notas, NOW())
            `, {
                replacements: { pacienteId, tipoAlta, usuarioId, notas },
                transaction
            });
            
            // 2. Actualizar paciente
            await sequelize.query(`
                UPDATE pacientes 
                SET estado = :tipoAlta,
                    activo = FALSE,
                    updated_at = NOW()
                WHERE id = :pacienteId
            `, {
                replacements: { tipoAlta, pacienteId },
                transaction
            });
            
            // 3. Cancelar citas futuras
            await sequelize.query(`
                UPDATE citas 
                SET estado = 'cancelada',
                    motivo_cancelacion = 'Paciente dado de alta',
                    updated_at = NOW()
                WHERE paciente_id = :pacienteId 
                AND fecha >= CURDATE()
                AND estado IN ('programada', 'confirmada')
            `, {
                replacements: { pacienteId },
                transaction
            });
            
            // 4. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'alta_paciente', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId, 
                    pacienteId,
                    descripcion: `Alta tipo: ${tipoAlta}` 
                },
                transaction
            });
            
            // Commit de la transacción
            await transaction.commit();
            
            return true;
            
        } catch (error) {
            // Rollback en caso de error
            await transaction.rollback();
            console.error('Error en darAltaPaciente:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_update_cita
     * Actualiza cita y maneja notificaciones
     */
    static async actualizarCita(citaId, updates, usuarioId) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Obtener datos actuales
            const [citaActual] = await sequelize.query(`
                SELECT * FROM citas WHERE id = :citaId
            `, {
                replacements: { citaId },
                type: sequelize.QueryTypes.SELECT,
                transaction
            });
            
            if (!citaActual) {
                throw new Error('Cita no encontrada');
            }
            
            // 2. Construir query de actualización
            const setClauses = [];
            const params = { citaId };
            
            for (const [key, value] of Object.entries(updates)) {
                setClauses.push(`${key} = :${key}`);
                params[key] = value;
            }
            
            const updateQuery = `
                UPDATE citas 
                SET ${setClauses.join(', ')}, updated_at = NOW()
                WHERE id = :citaId
            `;
            
            // 3. Actualizar cita
            await sequelize.query(updateQuery, {
                replacements: params,
                transaction
            });
            
            // 4. Verificar cambios importantes para notificaciones
            const cambiosImportantes = 
                (updates.fecha && updates.fecha !== citaActual.fecha) ||
                (updates.hora && updates.hora !== citaActual.hora) ||
                (updates.tipo_consulta && updates.tipo_consulta !== citaActual.tipo_consulta);
            
            // 5. Crear notificaciones si hay cambios importantes
            if (cambiosImportantes) {
                // Obtener paciente email si existe
                const [paciente] = await sequelize.query(`
                    SELECT email FROM pacientes WHERE id = :pacienteId
                `, {
                    replacements: { pacienteId: citaActual.paciente_id },
                    type: sequelize.QueryTypes.SELECT,
                    transaction
                });
                
                if (paciente && paciente.email) {
                    // Crear notificación para el paciente (si tuvieras tabla notificaciones)
                    // await sequelize.query(...)
                }
                
                // Notificar al psicólogo y becario si están asignados
                const usuariosNotificar = [];
                if (citaActual.psicologo_id) usuariosNotificar.push(citaActual.psicologo_id);
                if (citaActual.becario_id) usuariosNotificar.push(citaActual.becario_id);
                
                for (const userId of usuariosNotificar) {
                    await sequelize.query(`
                        INSERT INTO notificaciones (
                            usuario_id, tipo, titulo, mensaje, leido, created_at
                        ) VALUES (
                            :userId, 'cita_modificada', 'Cita modificada',
                            CONCAT('La cita del paciente ha sido modificada. Nueva fecha: ', 
                                   :nuevaFecha, ' ', :nuevaHora),
                            FALSE, NOW()
                        )
                    `, {
                        replacements: {
                            userId,
                            nuevaFecha: updates.fecha || citaActual.fecha,
                            nuevaHora: updates.hora || citaActual.hora
                        },
                        transaction
                    });
                }
            }
            
            await transaction.commit();
            return true;
            
        } catch (error) {
            await transaction.rollback();
            console.error('Error en actualizarCita:', error);
            throw error;
        }
    }
    
    /**
     * Obtener estadísticas generales
     */
    static async obtenerEstadisticas(fechaInicio, fechaFin, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    COUNT(*) AS total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) AS completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) AS canceladas,
                    SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) AS programadas,
                    COUNT(DISTINCT paciente_id) AS pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) AS psicologos_activos
                FROM citas
                WHERE fecha BETWEEN :fechaInicio AND :fechaFin
            `;
            
            const params = { fechaInicio, fechaFin };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            const [result] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return result;
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            throw error;
        }
    }
}

module.exports = DatabaseService;

/src\services\emailService.js:
--------------------------------------------------------------------------------
const nodemailer = require('nodemailer');

class EmailService {
    
    static transporter = null;
    
    static async inicializar() {
        try {
            this.transporter = nodemailer.createTransport({
                host: process.env.SMTP_HOST,
                port: process.env.SMTP_PORT,
                secure: process.env.SMTP_SECURE === 'true',
                auth: {
                    user: process.env.SMTP_USER,
                    pass: process.env.SMTP_PASS
                }
            });
            
            // Verificar conexión
            await this.transporter.verify();
            console.log('✅ Servicio de email configurado correctamente');
            
        } catch (error) {
            console.error('❌ Error al configurar servicio de email:', error);
            this.transporter = null;
        }
    }
    
    static async enviarEmail(destinatario, asunto, contenido, adjuntos = []) {
        if (!this.transporter) {
            console.warn('Servicio de email no configurado');
            return false;
        }
        
        try {
            const mailOptions = {
                from: `"Sistema de Gestión Psicológica" <${process.env.SMTP_FROM || process.env.SMTP_USER}>`,
                to: destinatario,
                subject: asunto,
                html: contenido,
                attachments: adjuntos
            };
            
            const info = await this.transporter.sendMail(mailOptions);
            console.log(`📧 Email enviado a ${destinatario}: ${info.messageId}`);
            
            return true;
            
        } catch (error) {
            console.error('❌ Error al enviar email:', error);
            return false;
        }
    }
    
    static async enviarNotificacionCita(datosCita) {
        const { paciente, fecha, hora, tipo_consulta, ubicacion, psicologo } = datosCita;
        
        const asunto = `Recordatorio de Cita - ${fecha}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #4a6fa5; color: var(--white); padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #4a6fa5; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Recordatorio de Cita</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${paciente.nombre}</strong>,</p>
                        
                        <p>Le recordamos que tiene programada una cita de terapia psicológica:</p>
                        
                        <div class="details">
                            <p><strong>Fecha:</strong> ${fecha}</p>
                            <p><strong>Hora:</strong> ${hora}</p>
                            <p><strong>Modalidad:</strong> ${tipo_consulta === 'virtual' ? 'Virtual' : 'Presencial'}</p>
                            ${tipo_consulta === 'presencial' ? `<p><strong>Ubicación:</strong> ${ubicacion || 'Consultorio asignado'}</p>` : ''}
                            <p><strong>Psicólogo/a:</strong> ${psicologo.nombre} ${psicologo.apellido}</p>
                        </div>
                        
                        ${tipo_consulta === 'virtual' ? `
                        <p><strong>Enlace para la sesión virtual:</strong> <a href="${ubicacion}">${ubicacion}</a></p>
                        ` : ''}
                        
                        <p>Por favor, confirme su asistencia respondiendo a este correo o contactando a su terapeuta.</p>
                        
                        <p>Si necesita reprogramar o cancelar su cita, hágalo con al menos 24 horas de anticipación.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje automático del Sistema de Gestión Psicológica.</p>
                        <p>Por favor, no responda a este correo.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(paciente.email, asunto, contenido);
    }
    
    static async enviarNotificacionAlta(datosAlta) {
        const { paciente, fecha_alta, tipo_alta, recomendaciones, psicologo } = datosAlta;
        
        const asunto = `Proceso de Alta - ${paciente.nombre} ${paciente.apellido}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #28a745; color: var(--white); padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #28a745; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Proceso de Alta Completado</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${paciente.nombre} ${paciente.apellido}</strong>,</p>
                        
                        <p>Le informamos que se ha completado su proceso terapéutico en nuestro centro.</p>
                        
                        <div class="details">
                            <p><strong>Fecha de alta:</strong> ${fecha_alta}</p>
                            <p><strong>Tipo de alta:</strong> ${this.obtenerDescripcionAlta(tipo_alta)}</p>
                            <p><strong>Psicólogo/a responsable:</strong> ${psicologo.nombre} ${psicologo.apellido}</p>
                        </div>
                        
                        ${recomendaciones ? `
                        <h3>Recomendaciones:</h3>
                        <p>${recomendaciones}</p>
                        ` : ''}
                        
                        <p>Le agradecemos la confianza depositada en nosotros y le deseamos lo mejor en su continuo crecimiento personal.</p>
                        
                        <p>Si en el futuro requiere apoyo psicológico, no dude en contactarnos nuevamente.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje automático del Sistema de Gestión Psicológica.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(paciente.email, asunto, contenido);
    }
    
    static async enviarNotificacionObservacion(datosObservacion) {
        const { becario, supervisor, fecha, calificacion, aspectos } = datosObservacion;
        
        const asunto = `Nueva Observación - ${fecha}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #ffc107; color: #333; padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #ffc107; }
                    .aspecto { margin: 10px 0; padding: 10px; background-color: #f8f9fa; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Nueva Observación de Supervisión</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${becario.nombre} ${becario.apellido}</strong>,</p>
                        
                        <p>Su supervisor ${supervisor.nombre} ${supervisor.apellido} ha registrado una nueva observación sobre su desempeño.</p>
                        
                        <div class="details">
                            <p><strong>Fecha:</strong> ${fecha}</p>
                            <p><strong>Calificación general:</strong> ${calificacion}/10</p>
                        </div>
                        
                        ${aspectos && aspectos.length > 0 ? `
                        <h3>Aspectos evaluados:</h3>
                        ${aspectos.map(aspecto => `
                            <div class="aspecto">
                                <p><strong>${aspecto.nombre}:</strong> ${aspecto.calificacion}/10</p>
                                ${aspecto.comentario ? `<p><em>${aspecto.comentario}</em></p>` : ''}
                            </div>
                        `).join('')}
                        ` : ''}
                        
                        <p>Revise su panel para ver los detalles completos y las recomendaciones de mejora.</p>
                        
                        <p>Esta retroalimentación tiene como objetivo apoyar su desarrollo profesional.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje automático del Sistema de Gestión Psicológica.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(becario.email, asunto, contenido);
    }
    
    static async enviarReporteAdjunto(destinatario, asunto, contenido, archivoBuffer, nombreArchivo) {
        const adjuntos = [{
            filename: nombreArchivo,
            content: archivoBuffer,
            contentType: this.obtenerContentType(nombreArchivo)
        }];
        
        return await this.enviarEmail(destinatario, asunto, contenido, adjuntos);
    }
    
    static async enviarRecordatoriosCitas() {
        try {
            // Esta función se llamaría desde un job/cron
            // Obtener citas para mañana
            const fechaManana = new Date();
            fechaManana.setDate(fechaManana.getDate() + 1);
            const fechaStr = fechaManana.toISOString().split('T')[0];
            
            // En una implementación real, se obtendrían las citas de la BD
            const citasRecordatorio = []; // Obtener de BD
            
            for (const cita of citasRecordatorio) {
                if (cita.paciente.email) {
                    await this.enviarNotificacionCita(cita);
                }
            }
            
            return true;
            
        } catch (error) {
            console.error('Error al enviar recordatorios:', error);
            return false;
        }
    }
    
    // Métodos auxiliares
    static obtenerDescripcionAlta(tipo_alta) {
        const descripciones = {
            'terapeutica': 'Alta Terapéutica (Objetivos cumplidos)',
            'abandono': 'Abandono del Tratamiento',
            'traslado': 'Traslado a otro centro',
            'graduacion': 'Graduación del Programa',
            'no_continua': 'No Continúa el Tratamiento',
            'otro': 'Otro motivo'
        };
        return descripciones[tipo_alta] || tipo_alta;
    }
    
    static obtenerContentType(nombreArchivo) {
        const extension = nombreArchivo.split('.').pop().toLowerCase();
        
        const tipos = {
            'pdf': 'application/pdf',
            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'xls': 'application/vnd.ms-excel',
            'csv': 'text/csv',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'doc': 'application/msword'
        };
        
        return tipos[extension] || 'application/octet-stream';
    }
}

// Inicializar al cargar el módulo
EmailService.inicializar().catch(console.error);

module.exports = EmailService;

/src\services\estadisticaService.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class EstadisticaService {
    
    static async calcularEstadisticasGenerales(periodo = 'mes') {
        try {
            let intervalo;
            switch (periodo) {
                case 'semana':
                    intervalo = 'INTERVAL 7 DAY';
                    break;
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                case 'año':
                    intervalo = 'INTERVAL 365 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    (SELECT COUNT(*) FROM pacientes WHERE created_at >= DATE_SUB(CURDATE(), ${intervalo})) as nuevos_pacientes,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = FALSE) as pacientes_inactivos,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as total_citas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') as citas_completadas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'cancelada') as citas_canceladas,
                    
                    -- Tasa de asistencia
                    ROUND(
                        (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') * 100.0 / 
                        NULLIF((SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado IN ('programada', 'confirmada', 'completada')), 0),
                        2
                    ) as tasa_asistencia,
                    
                    -- Profesionales
                    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                    
                    -- Sesiones registradas
                    (SELECT COUNT(*) FROM sesiones s 
                     JOIN citas c ON s.cita_id = c.id 
                     WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})) as sesiones_registradas,
                    
                    -- Altas
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})) as altas_realizadas,
                    
                    -- Observaciones
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as observaciones_realizadas
            `, { type: QueryTypes.SELECT });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasGenerales:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasPsicologo(psicologoId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                    
                    -- Tiempo
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                    SUM(c.duracion_minutos) / 60.0 as horas_total,
                    
                    -- Sesiones registradas
                    COUNT(s.id) as sesiones_registradas,
                    
                    -- Observaciones
                    COUNT(ob.id) as observaciones_realizadas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion_observaciones,
                    
                    -- Altas
                    COUNT(al.id) as altas_realizadas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
                LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id
                    AND ob.fecha BETWEEN ? AND ?
                LEFT JOIN altas al ON u.id = al.usuario_id
                    AND al.fecha_alta BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [fechaInicio, fechaFin, fechaInicio, fechaFin, fechaInicio, fechaFin, psicologoId],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasPsicologo:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasBecario(becarioId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    
                    -- Observaciones recibidas
                    COUNT(ob.id) as observaciones_recibidas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    
                    -- Tiempo entre citas
                    ROUND(AVG(
                        DATEDIFF(
                            (SELECT MIN(c2.fecha) FROM citas c2 
                             WHERE c2.becario_id = c.becario_id 
                             AND c2.paciente_id = c.paciente_id 
                             AND c2.id > c.id),
                            c.fecha
                        )
                    ), 1) as dias_promedio_entre_citas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.becario_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                    AND ob.fecha BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [becarioId, fechaInicio, fechaFin, fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasBecario:', error);
            throw error;
        }
    }
    
    static async calcularTendenciasMensuales(meses = 6) {
        try {
            const tendencias = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha, '%Y-%m') as mes,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    (SELECT COUNT(*) FROM altas WHERE DATE_FORMAT(fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')) as altas_realizadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL ? MONTH)
                GROUP BY DATE_FORMAT(fecha, '%Y-%m')
                ORDER BY mes
            `, {
                replacements: [meses],
                type: QueryTypes.SELECT
            });
            
            return tendencias;
            
        } catch (error) {
            console.error('Error en calcularTendenciasMensuales:', error);
            throw error;
        }
    }
    
    static async calcularDistribucionPorGenero() {
        try {
            const distribucion = await sequelize.query(`
                SELECT 
                    COALESCE(genero, 'no especificado') as genero,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM pacientes
                WHERE activo = TRUE
                GROUP BY genero
                ORDER BY cantidad DESC
            `, { type: QueryTypes.SELECT });
            
            return distribucion;
            
        } catch (error) {
            console.error('Error en calcularDistribucionPorGenero:', error);
            throw error;
        }
    }
    
    static async calcularHorariosMasProductivos() {
        try {
            const horarios = await sequelize.query(`
                SELECT 
                    HOUR(hora) as hora,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud,
                    ROUND(AVG(duracion_minutos), 1) as duracion_promedio
                FROM citas
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
                GROUP BY HOUR(hora)
                ORDER BY total_citas DESC
                LIMIT 8
            `, { type: QueryTypes.SELECT });
            
            return horarios;
            
        } catch (error) {
            console.error('Error en calcularHorariosMasProductivos:', error);
            throw error;
        }
    }
    
    static async calcularMetricasEficiencia() {
        try {
            const [metricas] = await sequelize.query(`
                SELECT 
                    -- Tiempo promedio entre primera y última cita por paciente
                    ROUND(AVG(DATEDIFF(
                        ultima_cita.ultima,
                        primera_cita.primera
                    )), 1) as dias_tratamiento_promedio,
                    
                    -- Citas promedio por paciente
                    ROUND(AVG(total_citas.total), 1) as citas_promedio_por_paciente,
                    
                    -- Tasa de retención (pacientes con más de 1 cita)
                    ROUND(
                        COUNT(DISTINCT CASE WHEN total_citas.total > 1 THEN total_citas.paciente_id END) * 100.0 / 
                        COUNT(DISTINCT total_citas.paciente_id),
                        2
                    ) as tasa_retencion,
                    
                    -- Tiempo promedio para primera cita después del registro
                    ROUND(AVG(DATEDIFF(
                        primera_cita.primera,
                        p.created_at
                    )), 1) as dias_para_primera_cita
                    
                FROM pacientes p
                LEFT JOIN (
                    SELECT paciente_id, MIN(fecha) as primera
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) primera_cita ON p.id = primera_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, MAX(fecha) as ultima
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) ultima_cita ON p.id = ultima_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, COUNT(*) as total
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) total_citas ON p.id = total_citas.paciente_id
                WHERE p.activo = TRUE
            `, { type: QueryTypes.SELECT });
            
            return metricas;
            
        } catch (error) {
            console.error('Error en calcularMetricasEficiencia:', error);
            throw error;
        }
    }
    
    static async calcularSatisfaccionBecarios() {
        try {
            const satisfaccion = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    COUNT(ob.id) as total_observaciones,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    ROUND(STDDEV(ob.calificacion), 2) as desviacion_estandar,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    COUNT(DISTINCT ob.aspecto_evaluado) as aspectos_evaluados,
                    (SELECT CONCAT(sup.nombre, ' ', sup.apellido) 
                     FROM asignaciones a 
                     JOIN users sup ON a.psicologo_id = sup.id 
                     WHERE a.becario_id = u.id AND a.estado = 'activa' LIMIT 1) as supervisor
                FROM users u
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                WHERE u.rol = 'becario' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY promedio_calificacion DESC
            `, { type: QueryTypes.SELECT });
            
            return satisfaccion;
            
        } catch (error) {
            console.error('Error en calcularSatisfaccionBecarios:', error);
            throw error;
        }
    }
    
    static async predecirDemanda(fechaInicio, fechaFin) {
        try {
            // Análisis histórico para predecir demanda
            const prediccion = await sequelize.query(`
                SELECT 
                    -- Por día de la semana
                    DAYNAME(fecha) as dia_semana,
                    COUNT(*) as historico_total,
                    ROUND(AVG(COUNT(*)) OVER(), 0) as promedio_diario,
                    
                    -- Por hora
                    HOUR(hora) as hora_dia,
                    COUNT(*) as citas_por_hora,
                    
                    -- Por psicólogo
                    psicologo_id,
                    COUNT(*) as citas_psicologo
                    
                FROM citas
                WHERE fecha BETWEEN ? AND ?
                AND estado IN ('programada', 'confirmada', 'completada')
                GROUP BY DAYNAME(fecha), HOUR(hora), psicologo_id
                ORDER BY dia_semana, hora_dia
            `, {
                replacements: [fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return prediccion;
            
        } catch (error) {
            console.error('Error en predecirDemanda:', error);
            throw error;
        }
    }
    
    static async generarReporteComparativo(periodo, tipoComparacion) {
        try {
            let query;
            
            switch (tipoComparacion) {
                case 'psicologos':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'psicologo' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.psicologo_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'psicologo' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                case 'becarios':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'becario' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.becario_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                            AND ob.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'becario' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                default:
                    throw new Error('Tipo de comparación no válido');
            }
            
            const resultados = await sequelize.query(query, {
                replacements: [periodo, periodo],
                type: QueryTypes.SELECT
            });
            
            return resultados;
            
        } catch (error) {
            console.error('Error en generarReporteComparativo:', error);
            throw error;
        }
    }
}

module.exports = EstadisticaService;

/src\services\index.js:
--------------------------------------------------------------------------------
// Services for business logic

/src\services\reporteService.js:
--------------------------------------------------------------------------------
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');

class ReporteService {
    
    static async generarExcel(datos, tipoReporte) {
        try {
            const workbook = new ExcelJS.Workbook();
            workbook.creator = 'Sistema de Gestión Psicológica';
            workbook.created = new Date();
            
            let worksheet;
            let columns = [];
            
            switch (tipoReporte) {
                case 'citas':
                    worksheet = workbook.addWorksheet('Reporte de Citas');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'MODALIDAD', key: 'MODALIDAD', width: 15 },
                        { header: 'Empleado', key: 'Empleado', width: 20 },
                        { header: 'ESTUDIANTE', key: 'ESTUDIANTE', width: 25 },
                        { header: 'CARRERA', key: 'CARRERA', width: 20 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'EDAD', key: 'EDAD', width: 8 },
                        { header: 'SEXO', key: 'SEXO', width: 10 },
                        { header: 'MOTIVO DE CONSULTA', key: 'MOTIVO_DE_CONSULTA', width: 30 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'CORREO', key: 'CORREO', width: 25 },
                        { header: 'DIA', key: 'DIA', width: 12 },
                        { header: 'HORA', key: 'HORA', width: 10 },
                        { header: 'ESTATUS', key: 'ESTATUS', width: 12 },
                        { header: 'PRACTICANTE', key: 'PRACTICANTE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 },
                        { header: 'ATIENDE', key: 'ATIENDE', width: 20 }
                    ];
                    break;
                    
                case 'pacientes':
                    worksheet = workbook.addWorksheet('Reporte de Pacientes');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'CUATRI', key: 'CUATRI', width: 10 },
                        { header: 'TIPO DE SERVICIO', key: 'TIPO_DE_SERVICIO', width: 20 },
                        { header: 'FECHA DE PRESENTACION', key: 'FECHA_DE_PRESENTACION', width: 20 },
                        { header: 'No. de sesiones terapéuticas personales', key: 'No_de_sesiones_terapeuticas_personales', width: 15 },
                        { header: 'FECHA DE ACEPTACION', key: 'FECHA_DE_ACEPTACION', width: 20 },
                        { header: 'MMPI-2 RF', key: 'MMPI_2_RF', width: 15 },
                        { header: 'FECHA DE TERMINO', key: 'FECHA_DE_TERMINO', width: 20 },
                        { header: 'CARTA DE LIBERACION', key: 'CARTA_DE_LIBERACION', width: 20 },
                        { header: 'HORAS OBJETIVO', key: 'HORAS_OBJETIVO', width: 15 },
                        { header: 'HORAS REALIZADAS', key: 'HORAS_REALIZADAS', width: 15 },
                        { header: 'HORAS FALTANTES', key: 'HORAS_FALTANTES', width: 15 },
                        { header: 'SERVICIO COMUNITARIO LIBERADO', key: 'SERVICIO_COMUNITARIO_LIBERADO', width: 20 },
                        { header: 'QUIEN ATIENDE', key: 'QUIEN_ATIENDE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 }
                    ];
                    break;
                    
                default:
                    worksheet = workbook.addWorksheet('Reporte');
                    columns = Object.keys(datos[0] || {}).map(key => ({
                        header: key.toUpperCase(),
                        key: key,
                        width: 20
                    }));
            }
            
            worksheet.columns = columns;
            
            // Agregar datos
            if (datos && datos.length > 0) {
                datos.forEach(row => {
                    worksheet.addRow(row);
                });
            }
            
            // Aplicar estilos a la cabecera
            worksheet.getRow(1).font = { bold: true };
            worksheet.getRow(1).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFE0E0E0' }
            };
            
            // Autoajustar columnas
            worksheet.columns.forEach(column => {
                let maxLength = 0;
                column.eachCell({ includeEmpty: true }, cell => {
                    const cellLength = cell.value ? cell.value.toString().length : 0;
                    if (cellLength > maxLength) {
                        maxLength = cellLength;
                    }
                });
                column.width = Math.min(maxLength + 2, 50);
            });
            
            // Generar buffer
            const buffer = await workbook.xlsx.writeBuffer();
            return buffer;
            
        } catch (error) {
            console.error('Error en generarExcel:', error);
            throw error;
        }
    }
    
    static async generarPDF(datos, tipoReporte, titulo) {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({ margin: 50 });
                const chunks = [];
                
                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => {
                    const buffer = Buffer.concat(chunks);
                    resolve(buffer);
                });
                
                // Encabezado
                doc.fontSize(20).text(titulo || 'Reporte del Sistema', { align: 'center' });
                doc.moveDown();
                doc.fontSize(12).text(`Generado: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, { align: 'center' });
                doc.moveDown(2);
                
                // Contenido según tipo de reporte
                switch (tipoReporte) {
                    case 'resumen':
                        this.generarPDFResumen(doc, datos);
                        break;
                    case 'paciente':
                        this.generarPDFPaciente(doc, datos);
                        break;
                    default:
                        this.generarPDFTabla(doc, datos);
                }
                
                doc.end();
                
            } catch (error) {
                reject(error);
            }
        });
    }
    
    static generarPDFResumen(doc, datos) {
        doc.fontSize(16).text('Resumen Estadístico', { underline: true });
        doc.moveDown();
        
        if (datos.estadisticas) {
            const stats = datos.estadisticas;
            doc.fontSize(12);
            doc.text(`Total de Pacientes: ${stats.total_pacientes || 0}`);
            doc.text(`Pacientes Activos: ${stats.pacientes_activos || 0}`);
            doc.text(`Citas del Mes: ${stats.total_citas_mes || 0}`);
            doc.text(`Citas Completadas: ${stats.citas_completadas || 0}`);
            doc.text(`Tasa de Completitud: ${stats.tasa_completitud || '0'}%`);
            doc.moveDown();
        }
        
        if (datos.evolucion_mensual && datos.evolucion_mensual.length > 0) {
            doc.fontSize(14).text('Evolución Mensual:', { underline: true });
            doc.moveDown();
            
            datos.evolucion_mensual.forEach(item => {
                doc.fontSize(10).text(`${item.mes}: ${item.total_citas} citas (${item.citas_completadas} completadas)`);
            });
        }
    }
    
    static generarPDFPaciente(doc, datos) {
        doc.fontSize(16).text(`Expediente de ${datos.paciente?.nombre || ''} ${datos.paciente?.apellido || ''}`, { underline: true });
        doc.moveDown();
        
        // Información básica
        doc.fontSize(12).text('Información Básica:', { underline: true });
        doc.fontSize(10);
        if (datos.paciente) {
            doc.text(`Nombre: ${datos.paciente.nombre} ${datos.paciente.apellido}`);
            doc.text(`Teléfono: ${datos.paciente.telefono || 'No especificado'}`);
            doc.text(`Email: ${datos.paciente.email || 'No especificado'}`);
            doc.text(`Fecha de Nacimiento: ${datos.paciente.fecha_nacimiento || 'No especificado'}`);
        }
        doc.moveDown();
        
        // Historial de sesiones
        if (datos.sesiones && datos.sesiones.length > 0) {
            doc.fontSize(12).text('Historial de Sesiones:', { underline: true });
            doc.moveDown();
            
            datos.sesiones.forEach((sesion, index) => {
                doc.fontSize(10).text(`${index + 1}. ${sesion.fecha} - ${sesion.psicologo_nombre}`);
                if (sesion.conclusion) {
                    doc.fontSize(8).text(`   Conclusiones: ${sesion.conclusion.substring(0, 100)}...`);
                }
                doc.moveDown(0.5);
            });
        }
    }
    
    static generarPDFTabla(doc, datos) {
        if (!datos || datos.length === 0) {
            doc.text('No hay datos para mostrar');
            return;
        }
        
        // Obtener columnas
        const columnas = Object.keys(datos[0]);
        const anchoColumna = 500 / columnas.length;
        
        // Encabezado de tabla
        doc.fontSize(10).font('Helvetica-Bold');
        let xPos = 50;
        
        columnas.forEach(columna => {
            doc.text(columna.toUpperCase(), xPos, doc.y, { width: anchoColumna });
            xPos += anchoColumna;
        });
        
        doc.moveDown();
        doc.font('Helvetica');
        
        // Línea separadora
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown();
        
        // Filas de datos
        datos.forEach(fila => {
            xPos = 50;
            columnas.forEach(columna => {
                const valor = fila[columna] !== null && fila[columna] !== undefined ? 
                            fila[columna].toString() : '';
                doc.fontSize(8).text(valor.substring(0, 30), xPos, doc.y, { width: anchoColumna });
                xPos += anchoColumna;
            });
            doc.moveDown();
        });
    }
    
    static async generarCSV(datos, delimitador = ',') {
        if (!datos || datos.length === 0) {
            return '';
        }
        
        const columnas = Object.keys(datos[0]);
        let csv = columnas.join(delimitador) + '\n';
        
        datos.forEach(fila => {
            const valores = columnas.map(columna => {
                const valor = fila[columna];
                if (valor === null || valor === undefined) {
                    return '';
                }
                // Escapar comillas y delimitadores
                const valorStr = valor.toString();
                if (valorStr.includes(delimitador) || valorStr.includes('"') || valorStr.includes('\n')) {
                    return `"${valorStr.replace(/"/g, '""')}"`;
                }
                return valorStr;
            });
            csv += valores.join(delimitador) + '\n';
        });
        
        return csv;
    }
    
    static async guardarReporteArchivo(buffer, formato, nombreBase) {
        try {
            const timestamp = new Date().getTime();
            const nombreArchivo = `${nombreBase}_${timestamp}.${formato}`;
            const rutaArchivo = path.join(__dirname, '..', '..', 'reports', nombreArchivo);
            
            // Crear directorio si no existe
            await fs.mkdir(path.dirname(rutaArchivo), { recursive: true });
            
            // Guardar archivo
            await fs.writeFile(rutaArchivo, buffer);
            
            return {
                nombre: nombreArchivo,
                ruta: `/reports/${nombreArchivo}`,
                tamano: buffer.length
            };
            
        } catch (error) {
            console.error('Error al guardar reporte:', error);
            throw error;
        }
    }
    
    static async eliminarReporteAntiguos(dias = 30) {
        try {
            const directorio = path.join(__dirname, '..', '..', 'reports');
            const fechaLimite = new Date(Date.now() - dias * 24 * 60 * 60 * 1000);
            
            const archivos = await fs.readdir(directorio);
            
            for (const archivo of archivos) {
                const rutaArchivo = path.join(directorio, archivo);
                const stats = await fs.stat(rutaArchivo);
                
                if (stats.mtime < fechaLimite) {
                    await fs.unlink(rutaArchivo);
                    console.log(`Eliminado archivo antiguo: ${archivo}`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('Error al eliminar reportes antiguos:', error);
            return false;
        }
    }
}

module.exports = ReporteService;


/.env:
--------------------------------------------------------------------------------
NODE_ENV=development
PORT=3000

# Database MySQL
DB_HOST=localhost
DB_PORT=3306
DB_NAME=psicogestion_db
DB_USER=psicogestion_user
DB_PASSWORD=SecurePass123!

# JWT
JWT_SECRET=cesun
JWT_EXPIRES_IN=24h

# Bcrypt
BCRYPT_ROUNDS=12

# App
LOG_LEVEL=info

/package.json:
--------------------------------------------------------------------------------
{
  "name": "psico-gestion-root",
  "private": true,
  "version": "1.0.0",
  "description": "Sistema de Gesti√≥n de Consultorio Psicol√≥gico",
  "workspaces": [
    "backend",
    "frontend"
  ],
  "scripts": {
    "start": "npm run start:backend",
    "dev": "npm run dev:backend",
    "dev:all": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:backend": "cd backend && npm run dev",
    "dev:frontend": "cd frontend && npm run dev",
    "start:backend": "cd backend && npm start",
    "start:frontend": "cd frontend && npm start",
    "install:all": "npm install && cd backend && npm install && cd ../frontend && npm install",
    "install:backend": "cd backend && npm install",
    "install:frontend": "cd frontend && npm install",
    "clean:all": "rm -rf node_modules backend/node_modules frontend/node_modules",
    "build:frontend": "cd frontend && npm run build",
    "test:all": "cd backend && npm test && cd ../frontend && npm test"
  },
  "devDependencies": {
    "concurrently": "^8.0.0"
  },
  "keywords": [
    "psicologia",
    "gestion",
    "consultorio",
    "pacientes",
    "citas"
  ],
  "author": "Cesun Universidad",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}

/backend\package.json:
--------------------------------------------------------------------------------
{
  "name": "psico-gestion-backend",
  "version": "1.0.0",
  "description": "Backend API para sistema de gesti√≥n psicol√≥gica",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"No tests yet\""
  },
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "jsonwebtoken": "^9.0.3",
    "mysql2": "^3.15.3",
    "sequelize": "^6.37.7",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  }
}

/backend\server.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerDocument = require('./src/doc/swagger.json');
const cors = require('cors');

const sequelize = require('./src/config/db');

// Importar modelos
require('./src/models/userModel');
require('./src/models/pacienteModel');
require('./src/models/citaModel');
// Importar otros modelos seg√∫n necesites

const authRoutes = require('./src/routes/authRoutes');
const citaRoutes = require('./src/routes/citaRoutes'); // A√±adir esta l√≠nea

const app = express();
const PORT = process.env.PORT || 3000;



app.use(cors({
  origin: 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.get('/', (req, res) => {
  res.send('Server is running! Check /api-docs for documentation.');
});

app.use('/api/auth', authRoutes);
app.use('/api/citas', citaRoutes);

const userRoutes = require('./src/routes/userRoutes');
app.use('/api/users', userRoutes);

// Sincronizar modelos
sequelize.sync({ force: false, alter: false })
    .then(() => {
        console.log("‚úÖ Tablas sincronizadas (base de datos lista)");
        app.listen(PORT, () => {
          console.log(`Backend running on http://localhost:${PORT}`);
          console.log(`Swagger docs: http://localhost:${PORT}/api-docs`);
          console.log(`CORS permitido para: http://localhost:3001`);
          console.log(`Endpoints disponibles:`);
          console.log(`  GET  /api/citas/citas-por-fecha?fecha=YYYY-MM-DD&becario_id=1`);
          console.log(`  GET  /api/citas/reporte-mensual?mes=1&anio=2024`);
          console.log(`  POST /api/citas/alta-paciente`);
          console.log(`  PUT  /api/citas/cita/:id`);
        });
    })
    .catch((error) => {
        console.error("‚ùå Error al sincronizar la base de datos:", error.message);
    });

/backend\src\config\db.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASSWORD,
    {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'mysql',
        logging: false,
        
        dialectOptions: {
            ssl: {
                require: true,
                rejectUnauthorized: false
            }
        },

        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000
        }
    }
);

async function testConnection() {
    try {
        await sequelize.authenticate();
        console.log('‚úÖ Conexi√≥n a base de datos establecida exitosamente.');
    } catch (error) {
        console.error('‚ùå No se pudo conectar a la base de datos:', error);
    }
}

testConnection();

module.exports = sequelize;

/backend\src\controllers\authController.js:
--------------------------------------------------------------------------------
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
// Importamos el modelo de Sequelize
const User = require('../models/userModel'); 

class AuthController {
    
    static async login(req, res) {
        try {
            const { email, password } = req.body;

            // 1. Validar entrada b√°sica
            if (!email || !password) {
                return res.status(400).json({ message: 'Por favor ingrese email y contrase√±a' });
            }

            // 2. Buscar el usuario usando Sequelize
            // En vez de SQL crudo, usamos el m√©todo findOne con una cl√°usula 'where'
            const user = await User.findOne({ 
                where: { email: email } 
            });

            // 3. Verificar si el usuario existe
            if (!user) {
                // 'user' ser√° null si no se encuentra
                return res.status(401).json({ message: 'Credenciales inv√°lidas' });
            }

            // 4. Comparar la contrase√±a (user.password accede al campo del objeto Sequelize)
            const isMatch = await bcrypt.compare(password, user.password);

            if (!isMatch) {
                return res.status(401).json({ message: 'Credenciales inv√°lidas' });
            }

            // 5. Generar el JWT (usamos user.id y user.email del objeto Sequelize)
            const payload = {
                id: user.id,
                email: user.email
            };

            const token = jwt.sign(
                payload, 
                process.env.JWT_SECRET, 
                { expiresIn: process.env.JWT_EXPIRES_IN }
            );

            // 6. Responder (user.toJSON() limpia metadatos de Sequelize si es necesario)
            res.json({
                message: 'Login exitoso',
                token: token,
                user: { 
                    id: user.id, 
                    email: user.email,
                    nombre: user.nombre, // A√±ade esto
                    apellido: user.apellido, // A√±ade esto
                    rol: user.rol, // A√±ade esto
                    especialidad: user.especialidad, // A√±ade esto (si aplica)
                    created_at: user.created_at // Cambia createdAt por created_at
                }
            });

        } catch (error) {
            console.error('Error en el login:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }

    static async getMe(req, res) {
        try {
            const userId = req.user.id;
            
            // Buscar usuario en la base de datos
            const user = await User.findOne({ 
                where: { id: userId },
                attributes: ['id', 'email', 'nombre', 'apellido', 'rol', 'especialidad', 'created_at'] // Cambia 'createdAt' por 'created_at'
            });
            
            if (!user) {
                return res.status(404).json({ message: 'Usuario no encontrado' });
            }
            
            res.json({
                message: 'Usuario obtenido exitosamente',
                user: user
            });
            
        } catch (error) {
            console.error('Error al obtener usuario:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }
}

module.exports = AuthController

/backend\src\controllers\citaController.js:
--------------------------------------------------------------------------------
const DatabaseService = require('../services/databaseService');

class CitaController {
    
    static async obtenerCitasPorFecha(req, res) {
        try {
            console.log('obtenerCitasPorFecha llamado');
            console.log('Query params:', req.query);
            
            const { fecha, becario_id } = req.query;
            
            // Validar par√°metro requerido
            if (!fecha) {
                return res.status(400).json({
                    success: false,
                    message: 'El par√°metro "fecha" es requerido (formato: YYYY-MM-DD)'
                });
            }
            
            const becarioId = becario_id ? parseInt(becario_id) : null;
            
            console.log(`Buscando citas para fecha: ${fecha}, becarioId: ${becarioId}`);
            
            const citas = await DatabaseService.obtenerCitasPorFechaBecario(fecha, becarioId);
            
            console.log(`Citas encontradas: ${Array.isArray(citas) ? citas.length : 0}`);
            
            // Asegurarnos de que citas siempre sea un array
            const citasArray = Array.isArray(citas) ? citas : [];
            
            res.json({
                success: true,
                data: citasArray,
                count: citasArray.length
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFecha:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener citas',
                error: error.message
            });
        }
    }

    static async crearNuevaCita(req, res) {
        try {
            const { paciente, fecha, hora, tipo_consulta, duracion, notas, becario_id } = req.body;
            const usuarioId = req.user.id;
            
            console.log('üìù Datos recibidos para nueva cita:', {
                paciente,
                fecha,
                hora,
                tipo_consulta,
                duracion,
                notas,
                becario_id,
                usuarioId
            });
            
            // Validar campos requeridos
            if (!paciente || !paciente.nombre || !paciente.apellido || !fecha || !hora) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente (nombre, apellido), fecha y hora'
                });
            }
            
            // Crear la cita usando DatabaseService
            const nuevaCita = await DatabaseService.crearNuevaCita({
                paciente,
                fecha,
                hora,
                tipo_consulta: tipo_consulta || 'presencial',
                duracion: duracion || 50,
                notas,
                becario_id,
                usuarioId
            });
            
            res.json({
                success: true,
                message: 'Cita creada exitosamente',
                data: nuevaCita
            });
            
        } catch (error) {
            console.error('‚ùå Error en crearNuevaCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear la cita',
                error: error.message
            });
        }
    }
    
    static async generarReporteMensual(req, res) {
        try {
            const { mes, anio, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const reporte = await DatabaseService.generarReporteMensual(
                parseInt(mes),
                parseInt(anio),
                psicologoId
            );
            
            res.json({
                success: true,
                data: reporte,
                count: reporte.length,
                mes: mes,
                anio: anio
            });
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte',
                error: error.message
            });
        }
    }
    
    static async darAltaPaciente(req, res) {
        try {
            const { paciente_id, tipo_alta, notas } = req.body;
            const usuarioId = req.user.id;
            
            if (!paciente_id || !tipo_alta) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente_id y tipo_alta'
                });
            }
            
            await DatabaseService.darAltaPaciente(
                paciente_id,
                tipo_alta,
                usuarioId,
                notas
            );
            
            res.json({
                success: true,
                message: 'Paciente dado de alta exitosamente'
            });
            
        } catch (error) {
            console.error('Error en darAltaPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al dar de alta paciente',
                error: error.message
            });
        }
    }
    
    static async actualizarCita(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            // Validar campos que se pueden actualizar
            const camposPermitidos = ['fecha', 'hora', 'tipo_consulta', 'estado', 'notas', 'motivo_cancelacion', 'psicologo_id', 'becario_id'];
            const updatesFiltrados = {};
            
            for (const campo of camposPermitidos) {
                if (updates[campo] !== undefined) {
                    updatesFiltrados[campo] = updates[campo];
                }
            }
            
            if (Object.keys(updatesFiltrados).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos v√°lidos para actualizar'
                });
            }
            
            await DatabaseService.actualizarCita(
                parseInt(id),
                updatesFiltrados,
                usuarioId
            );
            
            res.json({
                success: true,
                message: 'Cita actualizada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en actualizarCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar cita',
                error: error.message
            });
        }
    }
    
    static async obtenerEstadisticas(req, res) {
        try {
            const { fecha_inicio, fecha_fin, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const estadisticas = await DatabaseService.obtenerEstadisticas(
                fecha_inicio,
                fecha_fin,
                psicologoId
            );
            
            res.json({
                success: true,
                data: estadisticas
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas',
                error: error.message
            });
        }
    }
}

module.exports = CitaController;

/backend\src\doc\swagger.json:
--------------------------------------------------------------------------------
{
  "swagger": "2.0",
  "info": {
    "version": "1.0.1",
    "title": "API Documentation con Auth",
    "description": "API documentation including Authentication endpoint"
  },
  "host": "localhost:3000",
  "basePath": "/",
  "schemes": [
    "http"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/": {
      "get": {
        "summary": "Root endpoint",
        "description": "Returns a basic message to confirm the server is running.",
        "responses": {
          "200": {
            "description": "Server is running"
          }
        }
      }
    },
    "/api/auth/login": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "User Login",
        "description": "Authenticate user with email and password to receive a JWT token.",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "User credentials",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LoginCredentials"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Login successful, token returned",
            "schema": {
              "$ref": "#/definitions/LoginResponse"
            }
          },
          "400": {
            "description": "Missing email or password"
          },
          "401": {
            "description": "Invalid credentials"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    }
  },
  "definitions": {
    "LoginCredentials": {
      "type": "object",
      "required": [
        "email",
        "password"
      ],
      "properties": {
        "email": {
          "type": "string",
          "example": "test@example.com"
        },
        "password": {
          "type": "string",
          "example": "123456"
        }
      }
    },
    "LoginResponse": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "example": "Login exitoso"
        },
        "token": {
          "type": "string",
          "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
        },
        "user": {
          "type": "object",
          "properties": {
            "id": { "type": "integer", "example": 1 },
            "email": { "type": "string", "example": "test@example.com" }
          }
        }
      }
    }
  }
}

/backend\src\middlewares\authMiddleware.js:
--------------------------------------------------------------------------------


const jwt = require('jsonwebtoken');

const verifyToken = (req, res, next) => {
    // 1. Obtener el token del header "Authorization"
    // Se espera el formato: "Bearer <token_aqui>"
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Obtener la segunda parte

    if (!token) {
        return res.status(403).json({ message: 'Acceso denegado. Token no proporcionado.' });
    }

    try {
        // 2. Verificar el token usando la clave secreta
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // 3. Si es v√°lido, guardamos los datos del usuario (payload) en la request
        // para que las siguientes rutas puedan usarlo (ej. req.user.id)
        req.user = decoded;
        
        // 4. Continuar con la siguiente funci√≥n
        next();
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
             return res.status(401).json({ message: 'El token ha expirado.' });
        }
        return res.status(401).json({ message: 'Token inv√°lido.' });
    }
};

module.exports = verifyToken;

/backend\src\models\citaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Cita = sequelize.define('Cita', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false
    },
    hora: {
        type: DataTypes.TIME,
        allowNull: false,
        get() {
            // Obtener la hora sin segundos
            const rawValue = this.getDataValue('hora');
            return rawValue ? rawValue.substring(0, 5) : null;
        }
    },
    tipo_consulta: {
        type: DataTypes.ENUM('presencial', 'virtual'),
        allowNull: false,
        defaultValue: 'presencial'
    },
    estado: {
        type: DataTypes.ENUM('programada', 'confirmada', 'completada', 'cancelada'),
        allowNull: false,
        defaultValue: 'programada'
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    motivo_cancelacion: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    duracion: {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 50,
        comment: 'Duraci√≥n en minutos'
    },
    // Mant√©n compatibilidad con duracion_minutos
    duracion_minutos: {
        type: DataTypes.VIRTUAL,
        get() {
            return this.getDataValue('duracion');
        }
    }
}, {
    tableName: 'citas',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['fecha', 'estado']
        },
        {
            fields: ['psicologo_id', 'fecha']
        },
        {
            fields: ['becario_id']
        },
        {
            fields: ['paciente_id']
        }
    ]
});

// Relaciones
Cita.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Cita.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });
Cita.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });

module.exports = Cita;

/backend\src\models\pacienteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const Paciente = sequelize.define('Paciente', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: true,
        validate: {
            isEmail: true
        }
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    fecha_nacimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    genero: {
        type: DataTypes.ENUM('masculino', 'femenino', 'otro', 'prefiero_no_decir'),
        allowNull: true
    },
    direccion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    estado: {
        type: DataTypes.STRING(50),
        allowNull: false,
        defaultValue: 'activo'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    }
}, {
    tableName: 'pacientes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['activo']
        },
        {
            fields: ['apellido', 'nombre']
        }
    ]
});

module.exports = Paciente;

/backend\src\models\userModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const User = sequelize.define('User', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: {
            msg: 'El correo electr√≥nico ya est√° registrado'
        },
        validate: {
            isEmail: {
                msg: 'Debe proporcionar un correo electr√≥nico v√°lido'
            },
            notEmpty: true
        }
    },
    password: {
        type: DataTypes.STRING(255),
        allowNull: false,
        validate: {
            notEmpty: true
        }
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    rol: {
        type: DataTypes.ENUM('coordinador', 'psicologo', 'becario'),
        allowNull: false,
        defaultValue: 'becario'
    },
    especialidad: {
        type: DataTypes.STRING(100),
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    }
}, {
    tableName: 'users',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

module.exports = User;

/backend\src\routes\authRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AuthController = require('../controllers/authController');
const verifyToken = require('../middlewares/authMiddleware');

router.post('/login', AuthController.login);
router.get('/me', verifyToken, AuthController.getMe);

module.exports = router;

/backend\src\routes\citaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const CitaController = require('../controllers/citaController');
const verifyToken = require('../middlewares/authMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Rutas de consulta
router.get('/citas-por-fecha', CitaController.obtenerCitasPorFecha);
router.get('/reporte-mensual', CitaController.generarReporteMensual);
router.get('/estadisticas', CitaController.obtenerEstadisticas);

// Rutas de modificaci√≥n
router.post('/alta-paciente', CitaController.darAltaPaciente);
router.put('/cita/:id', CitaController.actualizarCita);
router.post('/nueva', CitaController.crearNuevaCita);

module.exports = router;

/backend\src\routes\userRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const User = require('../models/userModel');

// Obtener todos los becarios
router.get('/becarios', verifyToken, async (req, res) => {
  try {
    const becarios = await User.findAll({
      where: { rol: 'becario', activo: true },
      attributes: ['id', 'nombre', 'apellido', 'email'],
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });
    
    res.json(becarios);
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener becarios' });
  }
});

module.exports = router;

/backend\src\services\api.js:
--------------------------------------------------------------------------------
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  static async get(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async post(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async put(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async delete(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async handleResponse(response) {
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Error en la petici√≥n');
    }
    return response.json();
  }
}

export default ApiService;

/backend\src\services\databaseService.js:
--------------------------------------------------------------------------------
const sequelize = require('../config/db');
const { QueryTypes } = require('sequelize');

class DatabaseService {
    
    static async obtenerCitasPorFechaBecario(fecha, becarioId = null) {
        try {
            let query = `
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    p.email AS paciente_email,
                    u_psi.nombre AS psicologo_nombre,
                    u_bec.nombre AS becario_nombre,
                    c.duracion_minutos AS duracion,  -- Cambia duracion_minutos a duracion
                    c.motivo AS notas,               -- Cambia motivo a notas
                    TIME_FORMAT(c.hora, '%H:%i') AS hora_formatted  -- Formatea la hora
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE DATE(c.fecha) = :fecha
            `;
            
            const params = { fecha };
            
            if (becarioId !== null && becarioId !== undefined) {
                query += ` AND c.becario_id = :becarioId`;
                params.becarioId = becarioId;
            }
            
            query += ` ORDER BY c.hora`;
            
            const results = await sequelize.query(query, {
                replacements: params,
                type: QueryTypes.SELECT
            });
            
            // Mapea los resultados para usar los nombres correctos
            return results.map(row => {
                return {
                    ...row,
                    hora: row.hora_formatted,  // Usa la hora formateada
                    duracion: row.duracion || 50,
                    notas: row.notas || ''
                };
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFechaBecario:', error);
            throw error;
        }
    }
    // En /src/services/databaseService.js
    static async crearNuevaCita(datosCita) {
        const transaction = await sequelize.transaction();
        
        try {
            console.log('üîß Creando nueva cita con datos:', datosCita);
            
            // 1. Buscar o crear el paciente
            let paciente;
            
            // Primero intentar buscar por nombre y apellido
            const [pacienteExistente] = await sequelize.query(`
                SELECT id FROM pacientes 
                WHERE LOWER(nombre) = LOWER(:nombre) 
                AND LOWER(apellido) = LOWER(:apellido)
                LIMIT 1
            `, {
                replacements: {
                    nombre: datosCita.paciente.nombre.trim(),
                    apellido: datosCita.paciente.apellido.trim()
                },
                transaction
            });
            
            if (pacienteExistente && pacienteExistente.length > 0) {
                // Usar paciente existente
                paciente = pacienteExistente[0];
                console.log('‚úÖ Usando paciente existente:', paciente);
            } else {
                // Crear nuevo paciente
                console.log('üìã Creando nuevo paciente');
                const [resultadoPaciente] = await sequelize.query(`
                    INSERT INTO pacientes (
                        nombre, apellido, email, telefono, estado, activo, created_at
                    ) VALUES (
                        :nombre, :apellido, :email, :telefono, 'activo', TRUE, NOW()
                    )
                    `, {
                    replacements: {
                        nombre: datosCita.paciente.nombre.trim(),
                        apellido: datosCita.paciente.apellido.trim(),
                        email: datosCita.paciente.email || null,
                        telefono: datosCita.paciente.telefono || null
                    },
                    transaction
                    });

                    const [[pacienteInsertado]] = await sequelize.query(
                    'SELECT LAST_INSERT_ID() AS id',
                    { transaction }
                    );

                    paciente = { id: pacienteInsertado.id };

                console.log('‚úÖ Nuevo paciente creado con ID:', paciente.id);
            }
            
            // 2. Verificar que el becario existe si se especific√≥
            if (datosCita.becario_id) {
                const [becario] = await sequelize.query(`
                    SELECT id FROM users WHERE id = :becario_id AND rol = 'becario'
                `, {
                    replacements: { becario_id: datosCita.becario_id },
                    transaction
                });
                
                if (!becario || becario.length === 0) {
                    throw new Error('El becario especificado no existe');
                }
            }
            
            // 3. Verificar que no haya conflicto de horario
            const [citasConflicto] = await sequelize.query(`
                SELECT id FROM citas 
                WHERE fecha = :fecha 
                AND hora = :hora 
                AND estado IN ('programada', 'confirmada')
                AND becario_id = :becario_id
            `, {
                replacements: {
                    fecha: datosCita.fecha,
                    hora: datosCita.hora + ':00', // Asegurar formato HH:MM:SS
                    becario_id: datosCita.becario_id || null
                },
                transaction
            });
            
            if (citasConflicto && citasConflicto.length > 0) {
                throw new Error('Ya existe una cita programada para este horario con este becario');
            }
            
            // 4. Crear la cita
            await sequelize.query(`
                INSERT INTO citas (
                    paciente_id,
                    psicologo_id,
                    becario_id,
                    fecha,
                    hora,
                    duracion_minutos,
                    tipo_consulta,
                    estado,
                    motivo,
                    created_at
                ) VALUES (
                    :paciente_id,
                    :psicologo_id,
                    :becario_id,
                    :fecha,
                    :hora,
                    :duracion_minutos,
                    :tipo_consulta,
                    :estado,
                    :motivo,
                    NOW()
                )
            `, {
                replacements: {
                    paciente_id: paciente.id,
                    psicologo_id: datosCita.usuarioId,
                    becario_id: datosCita.becario_id || null,
                    fecha: datosCita.fecha,
                    hora: datosCita.hora,
                    duracion_minutos: datosCita.duracion || 50,
                    tipo_consulta: datosCita.tipo_consulta,
                    estado: 'programada',
                    motivo: datosCita.notas || null
                },
                transaction
            });

            const [[citaInsertada]] = await sequelize.query(
                'SELECT LAST_INSERT_ID() AS id',
                { transaction }
            );

            
            // 5. Obtener la cita creada con informaci√≥n del paciente
            const [citaCreada] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    u_bec.nombre AS becario_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = :cita_id
            `, {
                replacements: { cita_id: citaInsertada.id },
                transaction
            });
            
            // 6. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'nueva_cita', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId: datosCita.usuarioId,
                    pacienteId: paciente.id,
                    descripcion: `Nueva cita creada para ${datosCita.fecha} ${datosCita.hora}` 
                },
                transaction
            });
            
            await transaction.commit();
            console.log('‚úÖ Cita creada exitosamente');
            
            return citaCreada[0];
            
        } catch (error) {
            await transaction.rollback();
            console.error('‚ùå Error en crearNuevaCita:', error);
            throw error;
        }
    }
    

    /**
     * Reemplaza: sp_generar_reporte_mensual
     */
    static async generarReporteMensual(mes, anio, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
                    COUNT(c.id) AS total_sesiones,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS sesiones_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) AS sesiones_canceladas,
                    SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) AS sesiones_programadas,
                    MIN(c.fecha) AS primera_sesion_mes,
                    MAX(c.fecha) AS ultima_sesion_mes
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id 
                    AND MONTH(c.fecha) = :mes 
                    AND YEAR(c.fecha) = :anio
            `;
            
            const params = { mes, anio };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND c.psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            query += `
                WHERE p.activo = TRUE
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY p.apellido, p.nombre
            `;
            
            const [results] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return results;
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_insert_alta
     * Realiza transacci√≥n at√≥mica para dar de alta paciente
     */
    static async darAltaPaciente(pacienteId, tipoAlta, usuarioId, notas = null) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Insertar en altas
            await sequelize.query(`
                INSERT INTO altas (paciente_id, tipo_alta, usuario_id, notas, created_at)
                VALUES (:pacienteId, :tipoAlta, :usuarioId, :notas, NOW())
            `, {
                replacements: { pacienteId, tipoAlta, usuarioId, notas },
                transaction
            });
            
            // 2. Actualizar paciente
            await sequelize.query(`
                UPDATE pacientes 
                SET estado = :tipoAlta,
                    activo = FALSE,
                    updated_at = NOW()
                WHERE id = :pacienteId
            `, {
                replacements: { tipoAlta, pacienteId },
                transaction
            });
            
            // 3. Cancelar citas futuras
            await sequelize.query(`
                UPDATE citas 
                SET estado = 'cancelada',
                    motivo_cancelacion = 'Paciente dado de alta',
                    updated_at = NOW()
                WHERE paciente_id = :pacienteId 
                AND fecha >= CURDATE()
                AND estado IN ('programada', 'confirmada')
            `, {
                replacements: { pacienteId },
                transaction
            });
            
            // 4. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'alta_paciente', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId, 
                    pacienteId,
                    descripcion: `Alta tipo: ${tipoAlta}` 
                },
                transaction
            });
            
            // Commit de la transacci√≥n
            await transaction.commit();
            
            return true;
            
        } catch (error) {
            // Rollback en caso de error
            await transaction.rollback();
            console.error('Error en darAltaPaciente:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_update_cita
     * Actualiza cita y maneja notificaciones
     */
    static async actualizarCita(citaId, updates, usuarioId) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Obtener datos actuales
            const [citaActual] = await sequelize.query(`
                SELECT * FROM citas WHERE id = :citaId
            `, {
                replacements: { citaId },
                type: sequelize.QueryTypes.SELECT,
                transaction
            });
            
            if (!citaActual) {
                throw new Error('Cita no encontrada');
            }
            
            // 2. Construir query de actualizaci√≥n
            const setClauses = [];
            const params = { citaId };
            
            for (const [key, value] of Object.entries(updates)) {
                setClauses.push(`${key} = :${key}`);
                params[key] = value;
            }
            
            const updateQuery = `
                UPDATE citas 
                SET ${setClauses.join(', ')}, updated_at = NOW()
                WHERE id = :citaId
            `;
            
            // 3. Actualizar cita
            await sequelize.query(updateQuery, {
                replacements: params,
                transaction
            });
            
            // 4. Verificar cambios importantes para notificaciones
            const cambiosImportantes = 
                (updates.fecha && updates.fecha !== citaActual.fecha) ||
                (updates.hora && updates.hora !== citaActual.hora) ||
                (updates.tipo_consulta && updates.tipo_consulta !== citaActual.tipo_consulta);
            
            // 5. Crear notificaciones si hay cambios importantes
            if (cambiosImportantes) {
                // Obtener paciente email si existe
                const [paciente] = await sequelize.query(`
                    SELECT email FROM pacientes WHERE id = :pacienteId
                `, {
                    replacements: { pacienteId: citaActual.paciente_id },
                    type: sequelize.QueryTypes.SELECT,
                    transaction
                });
                
                if (paciente && paciente.email) {
                    // Crear notificaci√≥n para el paciente (si tuvieras tabla notificaciones)
                    // await sequelize.query(...)
                }
                
                // Notificar al psic√≥logo y becario si est√°n asignados
                const usuariosNotificar = [];
                if (citaActual.psicologo_id) usuariosNotificar.push(citaActual.psicologo_id);
                if (citaActual.becario_id) usuariosNotificar.push(citaActual.becario_id);
                
                for (const userId of usuariosNotificar) {
                    await sequelize.query(`
                        INSERT INTO notificaciones (
                            usuario_id, tipo, titulo, mensaje, leido, created_at
                        ) VALUES (
                            :userId, 'cita_modificada', 'Cita modificada',
                            CONCAT('La cita del paciente ha sido modificada. Nueva fecha: ', 
                                   :nuevaFecha, ' ', :nuevaHora),
                            FALSE, NOW()
                        )
                    `, {
                        replacements: {
                            userId,
                            nuevaFecha: updates.fecha || citaActual.fecha,
                            nuevaHora: updates.hora || citaActual.hora
                        },
                        transaction
                    });
                }
            }
            
            await transaction.commit();
            return true;
            
        } catch (error) {
            await transaction.rollback();
            console.error('Error en actualizarCita:', error);
            throw error;
        }
    }
    
    /**
     * Obtener estad√≠sticas generales
     */
    static async obtenerEstadisticas(fechaInicio, fechaFin, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    COUNT(*) AS total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) AS completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) AS canceladas,
                    SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) AS programadas,
                    COUNT(DISTINCT paciente_id) AS pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) AS psicologos_activos
                FROM citas
                WHERE fecha BETWEEN :fechaInicio AND :fechaFin
            `;
            
            const params = { fechaInicio, fechaFin };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            const [result] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return result;
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            throw error;
        }
    }
}

module.exports = DatabaseService;

/backend\src\services\index.js:
--------------------------------------------------------------------------------
// Services for business logic

/frontend\.env:
--------------------------------------------------------------------------------
PORT=3001
BROWSER=none

/frontend\package.json:
--------------------------------------------------------------------------------
{
  "name": "frontend-psico",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.0",
    "axios": "^1.6.0",
    "react-icons": "^4.12.0",
    "date-fns": "^2.30.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "dev": "react-scripts start --no-lazy"
  },
  "devDependencies": {
    "react-scripts": "5.0.1"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

/frontend\src\App.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Login from './components/Auth/Login';
import MainLayout from './components/Layout/MainLayout';
import DashboardPage from './pages/DashboardPage';
import PacientesPage from './pages/PacientesPage';
import CitasPage from './pages/CitasPage';
import ConfiguracionPage from './pages/ConfiguracionPage';
import PrivateRoute from './components/Auth/PrivateRoute';

function App() {
  return (
    <Router>
      <AuthProvider>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route path="/" element={<PrivateRoute><MainLayout /></PrivateRoute>}>
            <Route index element={<DashboardPage />} />
            <Route path="dashboard" element={<DashboardPage />} />
            <Route path="pacientes" element={<PacientesPage />} />
            <Route path="citas" element={<CitasPage />} />
            <Route path="configuracion" element={<ConfiguracionPage />} />
          </Route>
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;

/frontend\src\index.js:
--------------------------------------------------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './global.css';
import './App.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

/frontend\src\components\Auth\Login.js:
--------------------------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import './Login.css';

const Login = () => {
  const [credentials, setCredentials] = useState({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    if (!credentials.email || !credentials.password) {
      setError('Por favor ingrese email y contrase√±a');
      setLoading(false);
      return;
    }

    const result = await login(credentials.email, credentials.password);
    
    console.log('Resultado del login:', result);

    if (result.success) {
      navigate('/dashboard');
    } else {
      setError(result.message);
    }
    
    setLoading(false);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleSubmit(e);
    }
  };

  return (
    <div className="login-container">
      <div className="login-card">
        <div className="login-header">
          <h1 className="login-title">PsicoGesti√≥n</h1>
          <p className="login-subtitle">Consultorio Psicol√≥gico</p>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <input
              type="email"
              className="input-field"
              placeholder="Correo electr√≥nico"
              value={credentials.email}
              onChange={(e) => setCredentials({...credentials, email: e.target.value})}
              onKeyDown={handleKeyDown}
              autoFocus
            />
          </div>

          <div className="form-group">
            <input
              type="password"
              className="input-field"
              placeholder="Contrase√±a"
              value={credentials.password}
              onChange={(e) => setCredentials({...credentials, password: e.target.value})}
              onKeyDown={handleKeyDown}
            />
          </div>

          {error && (
            <div className="error-message">
              {error}
            </div>
          )}

          <button
            type="submit"
            className="btn-primary w-100"
            disabled={loading}
          >
            {loading ? 'Iniciando sesi√≥n...' : 'Iniciar Sesi√≥n'}
          </button>

          <div className="login-footer">
            <p className="instructions">
              <span>Enter: Acceder</span>
              <span>ESC: Salir</span>
            </p>
          </div>
        </form>

        <div className="app-info">
          <p>Versi√≥n 1.0.0</p>
          <p>Sistema de Gesti√≥n de Consultorio Psicol√≥gico</p>
        </div>
      </div>
    </div>
  );
};

export default Login;

/frontend\src\components\Auth\PrivateRoute.js:
--------------------------------------------------------------------------------
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const PrivateRoute = ({ children }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <div className="global-loader">
        <div className="global-loader-content">
          <div className="global-loader-spinner"></div>
          <div className="global-loader-text">Cargando...</div>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  return children;
};

export default PrivateRoute;

/frontend\src\components\Layout\MainLayout.js:
--------------------------------------------------------------------------------
import React, { useState } from 'react';
import { Outlet, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { FiMenu, FiX, FiHome, FiUsers, FiCalendar, FiSettings, FiLogOut } from 'react-icons/fi';

const MainLayout = () => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const navItems = [
    { path: '/dashboard', icon: <FiHome />, label: 'Dashboard' },
    { path: '/pacientes', icon: <FiUsers />, label: 'Pacientes' },
    { path: '/citas', icon: <FiCalendar />, label: 'Citas' },
    { path: '/configuracion', icon: <FiSettings />, label: 'Configuraci√≥n' },
  ];

  return (
    <div className="main-container">
      {/* Top Header */}
      <header className="top-header">
        <div className="flex-row align-center">
          <button 
            className="control-btn"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <FiX size={24} /> : <FiMenu size={24} />}
          </button>
          <h2 className="app-name">PsicoGesti√≥n</h2>
        </div>
        
        <div className="flex-row align-center gap-20">
          <div className="user-info">
            <span className="user-email">{user?.email}</span>
          </div>
          <button 
            className="btn-header"
            onClick={handleLogout}
            title="Cerrar sesi√≥n"
          >
            <FiLogOut />
            <span>Salir</span>
          </button>
        </div>
      </header>

      <div className="content-wrapper">
        {/* Sidebar */}
        <aside className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
          <nav className="sidebar-nav">
            {navItems.map((item) => (
              <NavLink
                key={item.path}
                to={item.path}
                className={({ isActive }) => 
                  `sidebar-nav-item ${isActive ? 'active' : ''}`
                }
              >
                {item.icon}
                {sidebarOpen && <span>{item.label}</span>}
              </NavLink>
            ))}
          </nav>
        </aside>

        {/* Main Content */}
        <main className="main-content">
          <div className="content-area">
            <Outlet />
          </div>
        </main>
      </div>

      {/* Bottom Status Bar */}
      <footer className="status-bar">
        <div className="status-info">
          <span>Sesi√≥n activa: {user?.email}</span>
          <span>√öltima conexi√≥n: {new Date().toLocaleTimeString()}</span>
        </div>
      </footer>
    </div>
  );
};

export default MainLayout;

/frontend\src\context\AuthContext.js:
--------------------------------------------------------------------------------
import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from 'axios';

const AuthContext = createContext({});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(localStorage.getItem('token'));

  useEffect(() => {
    if (token) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      fetchUserData();
    } else {
      setLoading(false);
    }
  }, [token]);

  const fetchUserData = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/auth/me');
      setUser(response.data.user);
    } catch (error) {
      console.error('Error fetching user data:', error);
      // Si el error es 401 (token inv√°lido/vencido), hacer logout
      if (error.response?.status === 401) {
        logout();
      }
    } finally {
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    try {
      const response = await axios.post('http://localhost:3000/api/auth/login', {
        email,
        password
      });
      
      const { token, user } = response.data;
      
      localStorage.setItem('token', token);
      localStorage.setItem('psico_user', JSON.stringify(user));
      
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      setToken(token);
      setUser(user);
      
      return { success: true };
    } catch (error) {
      console.error('Login error:', error);
      return { 
        success: false, 
        message: error.response?.data?.message || 'Error en el inicio de sesi√≥n' 
      };
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('psico_user');
    delete axios.defaults.headers.common['Authorization'];
    setToken(null);
    setUser(null);
    window.location.href = '/login';
  };

  const updateUser = (updatedUser) => {
    setUser(updatedUser);
    localStorage.setItem('psico_user', JSON.stringify(updatedUser));
  };

  const value = {
    user,
    token,
    login,
    logout,
    updateUser,
    loading
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

/frontend\src\pages\CitasPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiCalendar, 
  FiClock, 
  FiUser, 
  FiPlus, 
  FiEdit2, 
  FiChevronLeft, 
  FiChevronRight,
  FiPhone,
  FiMail,
  FiRefreshCw,
  FiX
} from 'react-icons/fi';
import { format, addDays, subDays, startOfWeek, endOfWeek, eachDayOfInterval, isToday } from 'date-fns';
import { es } from 'date-fns/locale';

const CitasPage = () => {
  const [citas, setCitas] = useState([]);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [view, setView] = useState('day');
  const [loading, setLoading] = useState(true);
  const [filterBecario, setFilterBecario] = useState('');
  const [becarios, setBecarios] = useState([]);
  const [selectedCita, setSelectedCita] = useState(null);
  const [showModal, setShowModal] = useState(false);
  const [showNuevaCitaModal, setShowNuevaCitaModal] = useState(false);
  const [nuevaCitaData, setNuevaCitaData] = useState({
    paciente_nombre: '',
    paciente_apellido: '',
    paciente_telefono: '',
    paciente_email: '',
    fecha: '',
    hora: '',
    tipo_consulta: 'presencial',
    duracion: 50,
    notas: '',
    psicologo_id: '',
    becario_id: ''
  });
  const [error, setError] = useState('');

  const getToken = () => {
    return localStorage.getItem('token');
  };

  const formatDateForAPI = (date) => {
    return format(date, 'yyyy-MM-dd');
  };

  const fetchBecarios = async () => {
    try {
      const token = getToken();
      const response = await fetch('http://localhost:3000/api/users/becarios', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setBecarios(data);
      }
    } catch (error) {
      console.error('Error al obtener becarios:', error);
    }
  };

  const fetchCitas = async () => {
    try {
      setLoading(true);
      const token = getToken();
      const fecha = formatDateForAPI(selectedDate);
      
      let url = `http://localhost:3000/api/citas/citas-por-fecha?fecha=${fecha}`;
      
      if (filterBecario) {
        url += `&becario_id=${filterBecario}`;
      }
      
      console.log('üîç Fetching citas from:', url);
      
      const response = await fetch(url, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // NORMALIZA LOS DATOS
        const citasNormalizadas = (data.data || []).map(cita => {
          return {
            ...cita,
            // Formatea la hora para quitar los segundos
            hora: cita.hora ? cita.hora.substring(0, 5) : '',
            // Usa duracion_minutos como duracion
            duracion: cita.duracion_minutos || cita.duracion || 50,
            // Usa motivo como notas
            notas: cita.motivo || cita.notas || '',
            // Asegura que paciente_nombre exista
            paciente_nombre: cita.paciente_nombre || `Paciente ${cita.id}`
          };
        });
        
        setCitas(citasNormalizadas);
      } else {
        console.error('Error al obtener citas');
      }
    } catch (error) {
      console.error('Error:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchCitasSemana = async () => {
    try {
      setLoading(true);
      const token = getToken();
      
      const startDate = startOfWeek(selectedDate, { weekStartsOn: 1 });
      const endDate = endOfWeek(selectedDate, { weekStartsOn: 1 });
      
      const promises = eachDayOfInterval({ start: startDate, end: endDate }).map(async (date) => {
        const fecha = formatDateForAPI(date);
        const response = await fetch(`http://localhost:3000/api/citas/citas-por-fecha?fecha=${fecha}${filterBecario ? `&becario_id=${filterBecario}` : ''}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          return { fecha, citas: data.data || [] };
        }
        return { fecha, citas: [] };
      });
      
      const results = await Promise.all(promises);
      setCitas(results.flatMap(r => r.citas));
      
    } catch (error) {
      console.error('Error:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchBecarios();
    if (view === 'day') {
      fetchCitas();
    } else if (view === 'week') {
      fetchCitasSemana();
    }
  }, [selectedDate, view, filterBecario]);

  const goToPreviousDay = () => {
    setSelectedDate(prev => subDays(prev, 1));
  };

  const goToNextDay = () => {
    setSelectedDate(prev => addDays(prev, 1));
  };

  const goToToday = () => {
    setSelectedDate(new Date());
  };

  const goToPreviousWeek = () => {
    setSelectedDate(prev => subDays(prev, 7));
  };

  const goToNextWeek = () => {
    setSelectedDate(prev => addDays(prev, 7));
  };

  const formatDateSpanish = (date) => {
    return format(date, "EEEE d 'de' MMMM, yyyy", { locale: es });
  };

  const generateHours = () => {
    const hours = [];
    for (let i = 9; i <= 20; i++) {
      hours.push(`${i}:00`);
      if (i !== 20) {
        hours.push(`${i}:30`);
      }
    }
    return hours;
  };


  const citasDelDia = citas.filter(cita => {
    console.log('üîç Cita individual:', {
      id: cita.id,
      cita_fecha: cita.fecha,
      cita_fecha_raw: cita.fecha,
      selected_date_formatted: formatDateForAPI(selectedDate),
      cita_date_object: new Date(cita.fecha),
      cita_date_formatted: formatDateForAPI(new Date(cita.fecha))
    });
    
    const isSameDay1 = cita.fecha === formatDateForAPI(selectedDate);
    
    const citaDate = new Date(cita.fecha);
    const selectedDateObj = new Date(selectedDate);
    const isSameDay2 = formatDateForAPI(citaDate) === formatDateForAPI(selectedDateObj);
    
    // M√©todo 3: Comparar a√±o, mes y d√≠a
    const isSameDay3 = 
      citaDate.getFullYear() === selectedDateObj.getFullYear() &&
      citaDate.getMonth() === selectedDateObj.getMonth() &&
      citaDate.getDate() === selectedDateObj.getDate();
    
    
    return isSameDay1 || isSameDay2 || isSameDay3;
  });

  const handleConfirmCita = async (citaId) => {
    try {
      const token = getToken();
      const response = await fetch(`http://localhost:3000/api/citas/cita/${citaId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ estado: 'confirmada' })
      });
      
      if (response.ok) {
        fetchCitas();
      }
    } catch (error) {
      console.error('Error al confirmar cita:', error);
    }
  };

  const handleCancelCita = async (citaId) => {
    try {
      const token = getToken();
      const response = await fetch(`http://localhost:3000/api/citas/cita/${citaId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          estado: 'cancelada',
          motivo_cancelacion: 'Cancelada por usuario' 
        })
      });
      
      if (response.ok) {
        fetchCitas();
      }
    } catch (error) {
      console.error('Error al cancelar cita:', error);
    }
  };

  const showCitaDetails = (cita) => {
    setSelectedCita(cita);
    setShowModal(true);
  };

  const handleNuevaCitaChange = (e) => {
    const { name, value } = e.target;
    setNuevaCitaData({
      ...nuevaCitaData,
      [name]: value
    });
  };

  const handleNuevaCitaSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (!nuevaCitaData.paciente_nombre || !nuevaCitaData.paciente_apellido || !nuevaCitaData.fecha || !nuevaCitaData.hora) {
      setError('Por favor complete los campos requeridos: Nombre, Apellido, Fecha y Hora');
      return;
    }

    try {
      const token = getToken();
      
      const citaData = {
        paciente: {
          nombre: nuevaCitaData.paciente_nombre.trim(),
          apellido: nuevaCitaData.paciente_apellido.trim(),
          telefono: nuevaCitaData.paciente_telefono || '',
          email: nuevaCitaData.paciente_email || ''
        },
        fecha: nuevaCitaData.fecha,
        hora: nuevaCitaData.hora,
        tipo_consulta: nuevaCitaData.tipo_consulta,
        duracion: parseInt(nuevaCitaData.duracion),
        notas: nuevaCitaData.notas || '',
        becario_id: nuevaCitaData.becario_id || null
      };

      console.log('üì§ Enviando datos de cita:', citaData);

      const response = await fetch('http://localhost:3000/api/citas/nueva', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(citaData)
      });

      const responseText = await response.text();
      console.log('üì• Respuesta del servidor:', responseText);

      if (!response.ok) {
        try {
          const errorData = JSON.parse(responseText);
          throw new Error(errorData.message || 'Error al crear la cita');
        } catch (parseError) {
          throw new Error(responseText || 'Error al crear la cita');
        }
      }

      const data = JSON.parse(responseText);
      
      if (data.success) {
        setShowNuevaCitaModal(false);
        setNuevaCitaData({
          paciente_nombre: '',
          paciente_apellido: '',
          paciente_telefono: '',
          paciente_email: '',
          fecha: formatDateForAPI(selectedDate),
          hora: '',
          tipo_consulta: 'presencial',
          duracion: 50,
          notas: '',
          becario_id: ''
        });
        
        // Mostrar mensaje de √©xito
        alert('‚úÖ Cita creada exitosamente');
        
        // Recargar las citas
        if (view === 'day') {
          fetchCitas();
        } else {
          fetchCitasSemana();
        }
      } else {
        setError(data.message || 'Error al crear la cita');
      }
      
    } catch (error) {
      console.error('Error al crear cita:', error);
      setError(error.message || 'Error al crear la cita');
    }
  };

  const weekDays = view === 'week' ? 
    eachDayOfInterval({ 
      start: startOfWeek(selectedDate, { weekStartsOn: 1 }), 
      end: endOfWeek(selectedDate, { weekStartsOn: 1 }) 
    }) : [];

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando citas...</div>
      </div>
    );
  }

  return (
    <div className="citas-page">
      <div className="page-header">
        <div>
          <h1>Calendario de Citas</h1>
          <p>Gesti√≥n de agenda del consultorio</p>
        </div>
        <div className="flex-row gap-10">
          <div className="filter-select">
            <select 
              value={filterBecario} 
              onChange={(e) => setFilterBecario(e.target.value)}
              className="form-select"
            >
              <option value="">Todos los becarios</option>
              {becarios.map(becario => (
                <option key={becario.id} value={becario.id}>
                  {becario.nombre} {becario.apellido}
                </option>
              ))}
            </select>
          </div>
          <button className="btn-secondary" onClick={fetchCitas}>
            <FiRefreshCw /> Actualizar
          </button>
          <button className="btn-primary" onClick={() => setShowNuevaCitaModal(true)}>
            <FiPlus /> Nueva Cita
          </button>
        </div>
      </div>

      <div className="calendar-controls">
        <div className="view-selector">
          <button 
            className={`btn-text ${view === 'day' ? 'active' : ''}`}
            onClick={() => setView('day')}
          >
            D√≠a
          </button>
          <button 
            className={`btn-text ${view === 'week' ? 'active' : ''}`}
            onClick={() => setView('week')}
          >
            Semana
          </button>
        </div>

        <div className="date-navigation">
          <button 
            className="btn-text"
            onClick={view === 'day' ? goToPreviousDay : goToPreviousWeek}
          >
            <FiChevronLeft /> {view === 'day' ? 'Ayer' : 'Sem. anterior'}
          </button>
          
          <div className="current-date">
            <h3>
              {view === 'day' 
                ? formatDateSpanish(selectedDate)
                : `Semana del ${format(startOfWeek(selectedDate, { weekStartsOn: 1 }), 'd MMM')} al ${format(endOfWeek(selectedDate, { weekStartsOn: 1 }), 'd MMM, yyyy')}`
              }
            </h3>
          </div>
          
          <button 
            className="btn-text"
            onClick={view === 'day' ? goToNextDay : goToNextWeek}
          >
            {view === 'day' ? 'Ma√±ana' : 'Pr√≥x. semana'} <FiChevronRight />
          </button>
        </div>

        <div className="quick-actions">
          <button className="btn-secondary" onClick={goToToday}>
            Hoy
          </button>
        </div>
      </div>

      {view === 'day' ? (
        <div className="calendar-day-view">
          <div className="time-column">
            {generateHours().map((hour) => (
              <div key={hour} className="time-slot">
                <span className="time-label">{hour}</span>
              </div>
            ))}
          </div>

          <div className="events-column">
            {generateHours().map((hour) => {
              const hourCitas = citasDelDia.filter(cita => 
                cita.hora.startsWith(hour.split(':')[0])
              );

              return (
                <div key={hour} className="hour-slot">
                  {hourCitas.map((cita) => (
                    <div 
                      key={cita.id}
                      className={`event-item ${
                        cita.estado === 'confirmada' ? 'event-confirmed' :
                        cita.estado === 'completada' ? 'event-completed' :
                        cita.estado === 'programada' ? 'event-pending' :
                        'event-cancelled'
                      }`}
                      style={{ height: `${(cita.duracion / 30) * 50}px` }}
                      onClick={() => showCitaDetails(cita)}
                    >
                      <div className="event-header">
                        <div className="event-time">
                          <FiClock /> {cita.hora}
                        </div>
                        <div className="event-actions">
                          <button className="btn-text" onClick={(e) => {
                            e.stopPropagation();
                            showCitaDetails(cita);
                          }}>
                            <FiEdit2 />
                          </button>
                        </div>
                      </div>
                      <div className="event-content">
                        <div className="event-patient">
                          <FiUser /> {cita.paciente_nombre || 'Sin nombre'}
                        </div>
                        <div className="event-type">{cita.tipo_consulta}</div>
                        {cita.notas && (
                          <div className="event-notes">{cita.notas}</div>
                        )}
                      </div>
                      <div className="event-footer">
                        <span className={`badge ${
                          cita.estado === 'confirmada' ? 'badge-success' :
                          cita.estado === 'completada' ? 'badge-primary' :
                          cita.estado === 'programada' ? 'badge-warning' :
                          'badge-danger'
                        }`}>
                          {cita.estado}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              );
            })}
          </div>
        </div>
      ) : (
        <div className="calendar-week-view">
          <div className="week-header">
            <div className="time-header"></div>
            {weekDays.map((day) => (
              <div key={day.toISOString()} className="day-header">
                <div className={`day-name ${isToday(day) ? 'today' : ''}`}>
                  {format(day, 'EEE', { locale: es })}
                </div>
                <div className="day-number">
                  {format(day, 'd')}
                </div>
              </div>
            ))}
          </div>
          
          <div className="week-body">
            <div className="time-column">
              {generateHours().map(hour => (
                <div key={hour} className="time-slot">{hour}</div>
              ))}
            </div>
            
            {weekDays.map((day) => (
              <div key={day.toISOString()} className="day-column">
                {generateHours().map(hour => {
                  const dayCitas = citas.filter(cita => {
                    const citaDate = new Date(cita.fecha);
                    return citaDate.toDateString() === day.toDateString() &&
                           cita.hora.startsWith(hour.split(':')[0]);
                  });
                  
                  return (
                    <div key={hour} className="hour-cell">
                      {dayCitas.map(cita => (
                        <div 
                          key={cita.id}
                          className={`week-event ${
                            cita.estado === 'confirmada' ? 'event-confirmed' :
                            'event-pending'
                          }`}
                          onClick={() => showCitaDetails(cita)}
                          title={`${cita.hora} - ${cita.paciente_nombre}`}
                        >
                          <div className="week-event-time">{cita.hora}</div>
                          <div className="week-event-patient">{cita.paciente_nombre}</div>
                        </div>
                      ))}
                    </div>
                  );
                })}
              </div>
            ))}
          </div>
        </div>
      )}

      <div className="day-citas-list">
        <h3>
          Citas para {formatDateSpanish(selectedDate)} ({citasDelDia.length})
        </h3>
        
        {citasDelDia.length > 0 ? (
          <div className="citas-cards">
            {citasDelDia.map((cita) => (
              <div key={cita.id} className="cita-card">
                <div className="cita-card-header">
                  <div className="cita-time">
                    <FiClock /> {cita.hora} ({cita.duracion || 50} min)
                  </div>
                  <div className={`cita-status badge ${
                    cita.estado === 'confirmada' ? 'badge-success' :
                    cita.estado === 'completada' ? 'badge-primary' :
                    cita.estado === 'programada' ? 'badge-warning' :
                    'badge-danger'
                  }`}>
                    {cita.estado}
                  </div>
                </div>
                
                <div className="cita-card-body">
                  <div className="cita-paciente">
                    <FiUser /> {cita.paciente_nombre || 'Paciente'}
                  </div>
                  
                  <div className="cita-info">
                    <div className="cita-tipo">
                      {cita.tipo_consulta === 'presencial' ? 'üìã Presencial' : 'üíª Virtual'}
                    </div>
                    
                    {cita.paciente_telefono && (
                      <div className="cita-contacto">
                        <FiPhone /> {cita.paciente_telefono}
                      </div>
                    )}
                    
                    {cita.psicologo_nombre && (
                      <div className="cita-psicologo">
                        üë®‚Äç‚öïÔ∏è {cita.psicologo_nombre}
                      </div>
                    )}
                    
                    {cita.becario_nombre && (
                      <div className="cita-becario">
                        üë®‚Äçüéì {cita.becario_nombre}
                      </div>
                    )}
                  </div>
                  
                  {cita.notas && (
                    <div className="cita-notas">
                      <strong>Notas:</strong> {cita.notas}
                    </div>
                  )}
                </div>
                
                <div className="cita-card-footer">
                  <button 
                    className="btn-text"
                    onClick={() => showCitaDetails(cita)}
                  >
                    Detalles
                  </button>
                  
                  {cita.estado === 'programada' && (
                    <button 
                      className="btn-text text-success"
                      onClick={() => handleConfirmCita(cita.id)}
                    >
                      Confirmar
                    </button>
                  )}
                  
                  {(cita.estado === 'programada' || cita.estado === 'confirmada') && (
                    <button 
                      className="btn-text text-danger"
                      onClick={() => handleCancelCita(cita.id)}
                    >
                      Cancelar
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">üìÖ</div>
            <div>No hay citas programadas para este d√≠a</div>
            <button className="btn-text" onClick={() => setShowNuevaCitaModal(true)}>Agendar nueva cita</button>
          </div>
        )}
      </div>

      {showModal && selectedCita && (
        <div className="modal-overlay">
          <div className="modal-content">
            <div className="modal-header">
              <h2>Detalles de la Cita</h2>
              <button className="btn-text" onClick={() => setShowModal(false)}>√ó</button>
            </div>
            
            <div className="modal-body">
              <div className="detail-row">
                <strong>Paciente:</strong>
                <span>{selectedCita.paciente_nombre}</span>
              </div>
              
              <div className="detail-row">
                <strong>Fecha y hora:</strong>
                <span>{selectedCita.fecha} {selectedCita.hora}</span>
              </div>
              
              <div className="detail-row">
                <strong>Duraci√≥n:</strong>
                <span>{selectedCita.duracion || 50} minutos</span>
              </div>
              
              <div className="detail-row">
                <strong>Tipo:</strong>
                <span>{selectedCita.tipo_consulta === 'presencial' ? 'Presencial' : 'Virtual'}</span>
              </div>
              
              <div className="detail-row">
                <strong>Estado:</strong>
                <span className={`badge ${
                  selectedCita.estado === 'confirmada' ? 'badge-success' :
                  selectedCita.estado === 'completada' ? 'badge-primary' :
                  selectedCita.estado === 'programada' ? 'badge-warning' :
                  'badge-danger'
                }`}>
                  {selectedCita.estado}
                </span>
              </div>
              
              {selectedCita.psicologo_nombre && (
                <div className="detail-row">
                  <strong>Psic√≥logo:</strong>
                  <span>{selectedCita.psicologo_nombre}</span>
                </div>
              )}
              
              {selectedCita.becario_nombre && (
                <div className="detail-row">
                  <strong>Becario:</strong>
                  <span>{selectedCita.becario_nombre}</span>
                </div>
              )}
              
              {selectedCita.paciente_telefono && (
                <div className="detail-row">
                  <strong>Tel√©fono:</strong>
                  <span>{selectedCita.paciente_telefono}</span>
                </div>
              )}
              
              {selectedCita.notas && (
                <div className="detail-row notes">
                  <strong>Notas:</strong>
                  <p>{selectedCita.notas}</p>
                </div>
              )}
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowModal(false)}>
                Cerrar
              </button>
              <button className="btn-primary">
                <FiEdit2 /> Editar Cita
              </button>
            </div>
          </div>
        </div>
      )}

      {showNuevaCitaModal && (
      <div className="modal-overlay">
        <div className="modal-container">
          <div className="modal-header">
            <h2 className="modal-title">Agendar Nueva Cita</h2>
            <button 
              className="modal-close"
              onClick={() => {
                setShowNuevaCitaModal(false);
                setError('');
              }}
            >
              √ó
            </button>
          </div>

          {error && (
            <div className="error-message">
              {error}
            </div>
          )}
          
          <form onSubmit={handleNuevaCitaSubmit}>
            <div className="form-grid">
              <div className="form-group">
                <input 
                  type="text" 
                  name="paciente_nombre" 
                  placeholder="Nombre del paciente"
                  value={nuevaCitaData.paciente_nombre}
                  onChange={handleNuevaCitaChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group">
                <input 
                  type="text" 
                  name="paciente_apellido" 
                  placeholder="Apellido del paciente"
                  value={nuevaCitaData.paciente_apellido}
                  onChange={handleNuevaCitaChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group">
                <input 
                  type="tel" 
                  name="paciente_telefono" 
                  placeholder="Tel√©fono"
                  value={nuevaCitaData.paciente_telefono}
                  onChange={handleNuevaCitaChange}
                  className="input-field"
                />
              </div>
              
              <div className="form-group">
                <input 
                  type="email" 
                  name="paciente_email" 
                  placeholder="Email"
                  value={nuevaCitaData.paciente_email}
                  onChange={handleNuevaCitaChange}
                  className="input-field"
                />
              </div>
              
              <div className="form-group">
                <input 
                  type="date" 
                  name="fecha" 
                  value={nuevaCitaData.fecha || formatDateForAPI(selectedDate)}
                  onChange={handleNuevaCitaChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group">
                <select
                  name="hora"
                  value={nuevaCitaData.hora}
                  onChange={handleNuevaCitaChange}
                  className="select-field"
                  required
                >
                  <option value="">Seleccione hora</option>
                  {generateHours().map(hour => (
                    <option key={hour} value={hour}>{hour}</option>
                  ))}
                </select>
              </div>
              
              <div className="form-group">
                <select
                  name="tipo_consulta"
                  value={nuevaCitaData.tipo_consulta}
                  onChange={handleNuevaCitaChange}
                  className="select-field"
                >
                  <option value="presencial">Presencial</option>
                  <option value="virtual">Virtual</option>
                </select>
              </div>
              
              <div className="form-group">
                <select
                  name="duracion"
                  value={nuevaCitaData.duracion}
                  onChange={handleNuevaCitaChange}
                  className="select-field"
                >
                  <option value="30">30 minutos</option>
                  <option value="50">50 minutos</option>
                  <option value="60">60 minutos</option>
                  <option value="90">90 minutos</option>
                </select>
              </div>
              
              <div className="form-group">
                <select
                  name="becario_id"
                  value={nuevaCitaData.becario_id}
                  onChange={handleNuevaCitaChange}
                  className="select-field"
                >
                  <option value="">Sin becario asignado</option>
                  {becarios.map(becario => (
                    <option key={becario.id} value={becario.id}>
                      {becario.nombre} {becario.apellido}
                    </option>
                  ))}
                </select>
              </div>
              
              <div className="form-group" style={{ gridColumn: 'span 2' }}>
                <textarea 
                  name="notas" 
                  placeholder="Notas adicionales"
                  value={nuevaCitaData.notas}
                  onChange={handleNuevaCitaChange}
                  className="textarea-field"
                  rows="3"
                />
              </div>
            </div>
            
            <div className="modal-footer">
              <button 
                type="submit"
                className="btn-primary"
              >
                <FiPlus /> Agendar Cita
              </button>
              <button 
                type="button"
                onClick={() => {
                  setShowNuevaCitaModal(false);
                  setError('');
                }}
                className="btn-danger"
              >
                Cancelar
              </button>
            </div>
          </form>
        </div>
      </div>
    )}
    </div>
  );
};

export default CitasPage;

/frontend\src\pages\ConfiguracionPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { 
  FiUser, 
  FiLock, 
  FiBell, 
  FiCalendar, 
  FiSave,
  FiUpload,
  FiDownload
} from 'react-icons/fi';

const ConfiguracionPage = () => {
  const { user, updateUser } = useAuth();
  const [activeTab, setActiveTab] = useState('perfil');
  const [formData, setFormData] = useState({
    nombre: '',
    email: '',
    telefono: '',
    especialidad: '',
    horarioInicio: '09:00',
    horarioFin: '18:00',
    duracionCita: 45,
    notificacionesEmail: true,
    notificacionesSMS: false
  });
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState({ type: '', text: '' });

  useEffect(() => {
    if (user) {
      setFormData({
        nombre: user.nombre || '',
        email: user.email || '',
        telefono: user.telefono || '',
        especialidad: user.especialidad || 'Psicolog√≠a Cl√≠nica',
        horarioInicio: user.horarioInicio || '09:00',
        horarioFin: user.horarioFin || '18:00',
        duracionCita: user.duracionCita || 45,
        notificacionesEmail: user.notificacionesEmail || true,
        notificacionesSMS: user.notificacionesSMS || false
      });
    }
  }, [user]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData({
      ...formData,
      [name]: type === 'checkbox' ? checked : value
    });
  };

  const handlePasswordChange = (e) => {
    const { name, value } = e.target;
    setPasswordData({
      ...passwordData,
      [name]: value
    });
  };

  const handleSaveProfile = async (e) => {
    e.preventDefault();
    setSaving(true);
    
    try {
      // Simular guardado
      setTimeout(() => {
        updateUser(formData);
        setMessage({ type: 'success', text: 'Perfil actualizado correctamente' });
        setSaving(false);
        
        setTimeout(() => {
          setMessage({ type: '', text: '' });
        }, 3000);
      }, 1000);
    } catch (error) {
      setMessage({ type: 'error', text: 'Error al guardar los cambios' });
      setSaving(false);
    }
  };

  const handleChangePassword = async (e) => {
    e.preventDefault();
    
    if (passwordData.newPassword !== passwordData.confirmPassword) {
      setMessage({ type: 'error', text: 'Las contrase√±as no coinciden' });
      return;
    }
    
    if (passwordData.newPassword.length < 6) {
      setMessage({ type: 'error', text: 'La contrase√±a debe tener al menos 6 caracteres' });
      return;
    }
    
    setSaving(true);
    
    try {
      // Simular cambio de contrase√±a
      setTimeout(() => {
        setMessage({ type: 'success', text: 'Contrase√±a cambiada correctamente' });
        setPasswordData({
          currentPassword: '',
          newPassword: '',
          confirmPassword: ''
        });
        setSaving(false);
        
        setTimeout(() => {
          setMessage({ type: '', text: '' });
        }, 3000);
      }, 1000);
    } catch (error) {
      setMessage({ type: 'error', text: 'Error al cambiar la contrase√±a' });
      setSaving(false);
    }
  };

  const tabs = [
    { id: 'perfil', label: 'Perfil', icon: <FiUser /> },
    { id: 'seguridad', label: 'Seguridad', icon: <FiLock /> },
    { id: 'notificaciones', label: 'Notificaciones', icon: <FiBell /> },
    { id: 'horarios', label: 'Horarios', icon: <FiCalendar /> }
  ];

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <h1>Configuraci√≥n</h1>
        <p>Configuraci√≥n del sistema y perfil de usuario</p>
      </div>

      {message.text && (
        <div className={`alert-message ${message.type}`}>
          {message.text}
        </div>
      )}

      <div className="configuracion-container">
        {/* Tabs */}
        <div className="config-tabs">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              className={`config-tab ${activeTab === tab.id ? 'active' : ''}`}
              onClick={() => setActiveTab(tab.id)}
            >
              {tab.icon}
              <span>{tab.label}</span>
            </button>
          ))}
        </div>

        {/* Contenido de las tabs */}
        <div className="config-content">
          {/* Perfil */}
          {activeTab === 'perfil' && (
            <div className="tab-content">
              <h3>Informaci√≥n del Perfil</h3>
              <form onSubmit={handleSaveProfile}>
                <div className="form-grid">
                  <div className="form-group">
                    <label>Nombre completo</label>
                    <input
                      type="text"
                      name="nombre"
                      className="input-field"
                      value={formData.nombre}
                      onChange={handleInputChange}
                      placeholder="Tu nombre completo"
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Correo electr√≥nico</label>
                    <input
                      type="email"
                      name="email"
                      className="input-field"
                      value={formData.email}
                      onChange={handleInputChange}
                      placeholder="tu@email.com"
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Tel√©fono</label>
                    <input
                      type="tel"
                      name="telefono"
                      className="input-field"
                      value={formData.telefono}
                      onChange={handleInputChange}
                      placeholder="N√∫mero de tel√©fono"
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Especialidad</label>
                    <select
                      name="especialidad"
                      className="select-field"
                      value={formData.especialidad}
                      onChange={handleInputChange}
                    >
                      <option value="Psicolog√≠a Cl√≠nica">Psicolog√≠a Cl√≠nica</option>
                      <option value="Psicolog√≠a Educativa">Psicolog√≠a Educativa</option>
                      <option value="Psicolog√≠a Organizacional">Psicolog√≠a Organizacional</option>
                      <option value="Neuropsicolog√≠a">Neuropsicolog√≠a</option>
                      <option value="Psicoterapia">Psicoterapia</option>
                    </select>
                  </div>
                </div>
                
                <div className="form-actions">
                  <button 
                    type="submit" 
                    className="btn-primary"
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar Cambios'}
                  </button>
                </div>
              </form>
            </div>
          )}

          {/* Seguridad */}
          {activeTab === 'seguridad' && (
            <div className="tab-content">
              <h3>Cambiar Contrase√±a</h3>
              <form onSubmit={handleChangePassword}>
                <div className="form-grid">
                  <div className="form-group">
                    <label>Contrase√±a actual</label>
                    <input
                      type="password"
                      name="currentPassword"
                      className="input-field"
                      value={passwordData.currentPassword}
                      onChange={handlePasswordChange}
                      placeholder="Ingresa tu contrase√±a actual"
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Nueva contrase√±a</label>
                    <input
                      type="password"
                      name="newPassword"
                      className="input-field"
                      value={passwordData.newPassword}
                      onChange={handlePasswordChange}
                      placeholder="M√≠nimo 6 caracteres"
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Confirmar nueva contrase√±a</label>
                    <input
                      type="password"
                      name="confirmPassword"
                      className="input-field"
                      value={passwordData.confirmPassword}
                      onChange={handlePasswordChange}
                      placeholder="Repite la nueva contrase√±a"
                    />
                  </div>
                </div>
                
                <div className="form-actions">
                  <button 
                    type="submit" 
                    className="btn-primary"
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Cambiando...' : 'Cambiar Contrase√±a'}
                  </button>
                </div>
              </form>
              
              <div className="security-info">
                <h4>Recomendaciones de seguridad:</h4>
                <ul>
                  <li>Usa una contrase√±a con al menos 8 caracteres</li>
                  <li>Incluye may√∫sculas, min√∫sculas, n√∫meros y s√≠mbolos</li>
                  <li>No uses la misma contrase√±a en m√∫ltiples sitios</li>
                  <li>Cambia tu contrase√±a regularmente</li>
                </ul>
              </div>
            </div>
          )}

          {/* Notificaciones */}
          {activeTab === 'notificaciones' && (
            <div className="tab-content">
              <h3>Preferencias de Notificaciones</h3>
              <div className="notifications-list">
                <div className="notification-item">
                  <div>
                    <h4>Notificaciones por Email</h4>
                    <p>Recibe notificaciones por correo electr√≥nico</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      name="notificacionesEmail"
                      checked={formData.notificacionesEmail}
                      onChange={handleInputChange}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Notificaciones por SMS</h4>
                    <p>Recibe notificaciones por mensaje de texto</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      name="notificacionesSMS"
                      checked={formData.notificacionesSMS}
                      onChange={handleInputChange}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Recordatorios de citas</h4>
                    <p>Recuerda a los pacientes 24 horas antes de su cita</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      defaultChecked
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Reportes semanales</h4>
                    <p>Recibe un resumen semanal por email</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      defaultChecked
                    />
                    <span className="slider"></span>
                  </label>
                </div>
              </div>
            </div>
          )}

          {/* Horarios */}
          {activeTab === 'horarios' && (
            <div className="tab-content">
              <h3>Configuraci√≥n de Horarios</h3>
              <form>
                <div className="form-grid">
                  <div className="form-group">
                    <label>Horario de inicio</label>
                    <input
                      type="time"
                      name="horarioInicio"
                      className="input-field"
                      value={formData.horarioInicio}
                      onChange={handleInputChange}
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Horario de fin</label>
                    <input
                      type="time"
                      name="horarioFin"
                      className="input-field"
                      value={formData.horarioFin}
                      onChange={handleInputChange}
                    />
                  </div>
                  
                  <div className="form-group">
                    <label>Duraci√≥n de citas (minutos)</label>
                    <select
                      name="duracionCita"
                      className="select-field"
                      value={formData.duracionCita}
                      onChange={handleInputChange}
                    >
                      <option value="30">30 minutos</option>
                      <option value="45">45 minutos</option>
                      <option value="60">60 minutos</option>
                      <option value="90">90 minutos</option>
                    </select>
                  </div>
                </div>
                
                <div className="horario-disponibilidad">
                  <h4>D√≠as de atenci√≥n</h4>
                  <div className="dias-grid">
                    {['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado', 'Domingo'].map((dia) => (
                      <div key={dia} className="dia-item">
                        <label className="switch">
                          <input
                            type="checkbox"
                            defaultChecked={dia !== 'Domingo'}
                          />
                          <span className="slider"></span>
                        </label>
                        <span>{dia}</span>
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="form-actions">
                  <button type="submit" className="btn-primary">
                    <FiSave /> Guardar Horarios
                  </button>
                </div>
              </form>
            </div>
          )}
        </div>
      </div>

      {/* Opciones avanzadas */}
      <div className="advanced-settings">
        <h3>Opciones Avanzadas</h3>
        <div className="advanced-actions">
          <button className="btn-warning">
            <FiDownload /> Exportar Datos
          </button>
          <button className="btn-secondary">
            <FiUpload /> Importar Datos
          </button>
          <button className="btn-danger">
            Limpiar Cache
          </button>
        </div>
      </div>
    </div>
  );
};

export default ConfiguracionPage;

/frontend\src\pages\DashboardPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';
import { 
  FiUsers, 
  FiCalendar, 
  FiTrendingUp, 
  FiAlertCircle,
  FiClock,
  FiDollarSign
} from 'react-icons/fi';

const DashboardPage = () => {
  const { token } = useAuth();
  const [stats, setStats] = useState({
    totalPacientes: 0,
    totalCitasHoy: 0,
    totalCitasProximas: 0,
    promedioSesiones: 0,
    ingresosMes: 0,
    citasPendientes: 0
  });
  const [citasProximas, setCitasProximas] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchDashboardData();
  }, [token]);

  const fetchDashboardData = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/dashboard/estadisticas', {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      if (response.data) {
        setStats(response.data);
      }
      
      // Simular datos de citas pr√≥ximas (en un proyecto real vendr√≠a del backend)
      setCitasProximas([
        { id: 1, paciente: 'Juan P√©rez', hora: '10:00 AM', estado: 'confirmada' },
        { id: 2, paciente: 'Mar√≠a Garc√≠a', hora: '11:30 AM', estado: 'pendiente' },
        { id: 3, paciente: 'Carlos L√≥pez', hora: '2:00 PM', estado: 'confirmada' },
        { id: 4, paciente: 'Ana Mart√≠nez', hora: '4:30 PM', estado: 'cancelada' },
      ]);
    } catch (error) {
      console.error('Error fetching dashboard data:', error);
    } finally {
      setLoading(false);
    }
  };

  const statCards = [
    {
      title: 'Total Pacientes',
      value: stats.totalPacientes,
      icon: <FiUsers size={24} />,
      color: 'var(--blu)',
      change: '+12% este mes'
    },
    {
      title: 'Citas Hoy',
      value: stats.totalCitasHoy,
      icon: <FiCalendar size={24} />,
      color: 'var(--grnb)',
      change: `${stats.citasPendientes} pendientes`
    },
    {
      title: 'Pr√≥ximas Citas',
      value: stats.totalCitasProximas,
      icon: <FiClock size={24} />,
      color: 'var(--yy)',
      change: 'Pr√≥ximos 7 d√≠as'
    },
    {
      title: 'Ingresos del Mes',
      value: `$${stats.ingresosMes.toLocaleString()}`,
      icon: <FiDollarSign size={24} />,
      color: 'var(--grnd)',
      change: '+8% vs mes anterior'
    },
    {
      title: 'Promedio Sesiones',
      value: stats.promedioSesiones,
      icon: <FiTrendingUp size={24} />,
      color: 'var(--grnl)',
      change: 'por paciente'
    },
    {
      title: 'Alertas',
      value: stats.citasPendientes,
      icon: <FiAlertCircle size={24} />,
      color: 'var(--rr)',
      change: 'Requieren atenci√≥n'
    }
  ];

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando dashboard...</div>
      </div>
    );
  }

  return (
    <div className="dashboard-page">
      <div className="page-header">
        <h1>Dashboard</h1>
        <p>Resumen general del consultorio</p>
      </div>

      {/* Stats Grid */}
      <div className="stats-grid">
        {statCards.map((stat, index) => (
          <div key={index} className="stat-card">
            <div className="stat-header">
              <div className="stat-icon" style={{ color: stat.color }}>
                {stat.icon}
              </div>
              <h3>{stat.title}</h3>
            </div>
            <div className="stat-value">{stat.value}</div>
            <div className="stat-change">{stat.change}</div>
          </div>
        ))}
      </div>

      {/* Content Grid */}
      <div className="dashboard-content-grid">
        {/* Pr√≥ximas Citas */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Pr√≥ximas Citas</h3>
            <button className="btn-text">Ver todas</button>
          </div>
          
          <div className="citas-list">
            {citasProximas.map((cita) => (
              <div key={cita.id} className="cita-item">
                <div className="cita-info">
                  <div className="cita-paciente">{cita.paciente}</div>
                  <div className="cita-hora">{cita.hora}</div>
                </div>
                <div className={`cita-estado badge ${
                  cita.estado === 'confirmada' ? 'badge-success' :
                  cita.estado === 'pendiente' ? 'badge-warning' :
                  'badge-danger'
                }`}>
                  {cita.estado}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Gr√°fico de Actividad (Placeholder) */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Actividad Semanal</h3>
          </div>
          <div className="activity-chart">
            <div className="chart-placeholder">
              <p>Gr√°fico de actividad semanal</p>
              <div className="chart-bars">
                {[65, 80, 45, 90, 75, 60, 85].map((height, index) => (
                  <div key={index} className="chart-bar">
                    <div 
                      className="bar-fill"
                      style={{ height: `${height}%` }}
                    ></div>
                    <div className="bar-label">
                      {['Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b', 'Dom'][index]}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* Pacientes Recientes */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Pacientes Recientes</h3>
            <button className="btn-text">Ver todos</button>
          </div>
          
          <div className="pacientes-list">
            {[
              { id: 1, nombre: 'Juan P√©rez', ultimaSesion: '2024-01-10', progreso: 75 },
              { id: 2, nombre: 'Mar√≠a Garc√≠a', ultimaSesion: '2024-01-09', progreso: 60 },
              { id: 3, nombre: 'Carlos L√≥pez', ultimaSesion: '2024-01-08', progreso: 90 },
              { id: 4, nombre: 'Ana Mart√≠nez', ultimaSesion: '2024-01-07', progreso: 45 },
              { id: 5, nombre: 'Roberto D√≠az', ultimaSesion: '2024-01-06', progreso: 30 },
            ].map((paciente) => (
              <div key={paciente.id} className="paciente-item">
                <div className="paciente-info">
                  <div className="paciente-nombre">{paciente.nombre}</div>
                  <div className="paciente-fecha">
                    √öltima: {new Date(paciente.ultimaSesion).toLocaleDateString()}
                  </div>
                </div>
                <div className="paciente-progreso">
                  <div className="progress-container">
                    <div 
                      className="progress-bar"
                      style={{ width: `${paciente.progreso}%` }}
                    ></div>
                  </div>
                  <span className="progreso-text">{paciente.progreso}%</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Quick Actions */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Acciones R√°pidas</h3>
          </div>
          
          <div className="quick-actions">
            <button className="btn-primary w-100 mb-10">
              Agendar Nueva Cita
            </button>
            <button className="btn-secondary w-100 mb-10">
              Registrar Nuevo Paciente
            </button>
            <button className="btn-warning w-100 mb-10">
              Generar Reporte Mensual
            </button>
            <button className="btn-text w-100">
              Ver Calendario Completo
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DashboardPage;

/frontend\src\pages\PacientesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiUserPlus, FiEdit, FiTrash2, FiFilter } from 'react-icons/fi';

const PacientesPage = () => {
  const [pacientes, setPacientes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [showModal, setShowModal] = useState(false);

  useEffect(() => {
    // Simular carga de datos
    setTimeout(() => {
      setPacientes([
        {
          id: 1,
          nombre: 'Juan P√©rez',
          email: 'juan@email.com',
          telefono: '555-1234',
          edad: 35,
          diagnostico: 'Ansiedad generalizada',
          ultimaSesion: '2024-01-10',
          proximaCita: '2024-01-17',
          estado: 'activo'
        },
        {
          id: 2,
          nombre: 'Mar√≠a Garc√≠a',
          email: 'maria@email.com',
          telefono: '555-5678',
          edad: 28,
          diagnostico: 'Depresi√≥n moderada',
          ultimaSesion: '2024-01-09',
          proximaCita: '2024-01-16',
          estado: 'activo'
        },
        {
          id: 3,
          nombre: 'Carlos L√≥pez',
          email: 'carlos@email.com',
          telefono: '555-9012',
          edad: 42,
          diagnostico: 'Trastorno de estr√©s postraum√°tico',
          ultimaSesion: '2024-01-08',
          proximaCita: '2024-01-15',
          estado: 'inactivo'
        },
        {
          id: 4,
          nombre: 'Ana Mart√≠nez',
          email: 'ana@email.com',
          telefono: '555-3456',
          edad: 31,
          diagnostico: 'Fobia social',
          ultimaSesion: '2024-01-07',
          proximaCita: '2024-01-14',
          estado: 'activo'
        },
        {
          id: 5,
          nombre: 'Roberto D√≠az',
          email: 'roberto@email.com',
          telefono: '555-7890',
          edad: 39,
          diagnostico: 'Trastorno obsesivo-compulsivo',
          ultimaSesion: '2024-01-06',
          proximaCita: '2024-01-13',
          estado: 'pendiente'
        }
      ]);
      setLoading(false);
    }, 1000);
  }, []);

  const filteredPacientes = pacientes.filter(paciente =>
    paciente.nombre.toLowerCase().includes(searchTerm.toLowerCase()) ||
    paciente.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
    paciente.diagnostico.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleDelete = (id) => {
    if (window.confirm('¬øEst√°s seguro de eliminar este paciente?')) {
      setPacientes(pacientes.filter(p => p.id !== id));
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando pacientes...</div>
      </div>
    );
  }

  return (
    <div className="pacientes-page">
      <div className="page-header">
        <div>
          <h1>Pacientes</h1>
          <p>Gesti√≥n de pacientes del consultorio</p>
        </div>
        <button 
          className="btn-primary"
          onClick={() => setShowModal(true)}
        >
          <FiUserPlus /> Nuevo Paciente
        </button>
      </div>

      {/* Search and Filters */}
      <div className="filters-container">
        <div className="search-box">
          <FiSearch />
          <input
            type="text"
            className="search-input"
            placeholder="Buscar paciente por nombre, email o diagn√≥stico..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
        
        <div className="filter-buttons">
          <button className="btn-secondary">
            <FiFilter /> Filtrar
          </button>
          <select className="select-field" style={{ width: '200px' }}>
            <option value="">Todos los estados</option>
            <option value="activo">Activos</option>
            <option value="inactivo">Inactivos</option>
            <option value="pendiente">Pendientes</option>
          </select>
        </div>
      </div>

      {/* Patients Table */}
      <div className="table-container">
        <table className="data-table">
          <thead>
            <tr>
              <th>Nombre</th>
              <th>Contacto</th>
              <th>Edad</th>
              <th>Diagn√≥stico</th>
              <th>√öltima Sesi√≥n</th>
              <th>Pr√≥xima Cita</th>
              <th>Estado</th>
              <th>Acciones</th>
            </tr>
          </thead>
          <tbody>
            {filteredPacientes.map((paciente) => (
              <tr key={paciente.id}>
                <td>
                  <div className="flex-row align-center gap-10">
                    <div className="avatar">
                      {paciente.nombre.split(' ').map(n => n[0]).join('')}
                    </div>
                    <div>
                      <div className="font-bold">{paciente.nombre}</div>
                    </div>
                  </div>
                </td>
                <td>
                  <div>{paciente.email}</div>
                  <div className="text-small">{paciente.telefono}</div>
                </td>
                <td>{paciente.edad} a√±os</td>
                <td>
                  <div className="diagnostico-tag">
                    {paciente.diagnostico}
                  </div>
                </td>
                <td>
                  {new Date(paciente.ultimaSesion).toLocaleDateString()}
                </td>
                <td>
                  {new Date(paciente.proximaCita).toLocaleDateString()}
                </td>
                <td>
                  <span className={`badge ${
                    paciente.estado === 'activo' ? 'badge-success' :
                    paciente.estado === 'inactivo' ? 'badge-danger' :
                    'badge-warning'
                  }`}>
                    {paciente.estado}
                  </span>
                </td>
                <td>
                  <div className="flex-row gap-5">
                    <button 
                      className="btn-text"
                      title="Editar"
                    >
                      <FiEdit />
                    </button>
                    <button 
                      className="btn-text text-danger"
                      onClick={() => handleDelete(paciente.id)}
                      title="Eliminar"
                    >
                      <FiTrash2 />
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Pagination */}
      <div className="pagination">
        <button className="page-item">¬´</button>
        <button className="page-item active">1</button>
        <button className="page-item">2</button>
        <button className="page-item">3</button>
        <button className="page-item">¬ª</button>
      </div>

      {/* Modal para nuevo paciente (placeholder) */}
      {showModal && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3 className="modal-title">Nuevo Paciente</h3>
              <button 
                className="modal-close"
                onClick={() => setShowModal(false)}
              >
                √ó
              </button>
            </div>
            <div className="modal-content">
              <p>Formulario para nuevo paciente...</p>
            </div>
            <div className="modal-footer">
              <button 
                className="btn-primary"
                onClick={() => setShowModal(false)}
              >
                Guardar
              </button>
              <button 
                className="btn-danger"
                onClick={() => setShowModal(false)}
              >
                Cancelar
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PacientesPage;
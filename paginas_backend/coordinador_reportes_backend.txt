ARCHIVOS BACKEND PARA: COORDINADOR_REPORTES
================================================================================
Generado: 2025-12-17 14:42:22
================================================================================

/backend/src/services/api.js:
--------------------------------------------------------------------------------
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  static async get(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async post(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async put(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async delete(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async handleResponse(response) {
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Error en la petición');
    }
    return response.json();
  }
  static async getDashboardCoordinador() {
    return this.get('/dashboard/coordinador');
  }

  static async getMetricasGlobales(periodo = 'mes') {
    return this.get(`/dashboard/metricas-globales?periodo=${periodo}`);
  }

  static async getEstadisticas() {
    return this.get('/estadisticas/generales');
  }
}

export default ApiService;


/backend/src/db/db.sql:
--------------------------------------------------------------------------------
CREATE DATABASE IF NOT EXISTS psicogestion_db;
USE psicogestion_db;

CREATE TABLE fundaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(255) NOT NULL UNIQUE,
    direccion TEXT,
    telefono VARCHAR(20),
    email VARCHAR(255),
    responsable VARCHAR(255),
    activo BOOLEAN DEFAULT TRUE,
    convenio_inicio DATE,
    convenio_fin DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    rol ENUM('coordinador', 'psicologo', 'becario') NOT NULL DEFAULT 'becario',
    especialidad VARCHAR(100),
    fundacion_id INT,
    activo BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (fundacion_id) REFERENCES fundaciones(id) ON DELETE SET NULL
);

CREATE TABLE pacientes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    email VARCHAR(255),
    telefono VARCHAR(20),
    fecha_nacimiento DATE,
    genero ENUM('masculino', 'femenino', 'otro', 'prefiero_no_decir'),
    direccion TEXT,
    estado VARCHAR(50) DEFAULT 'activo',
    activo BOOLEAN DEFAULT TRUE,
    notas TEXT,
    fundacion_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (fundacion_id) REFERENCES fundaciones(id) ON DELETE SET NULL,
    INDEX idx_activo (activo),
    INDEX idx_apellido_nombre (apellido, nombre)
);

CREATE TABLE expedientes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL UNIQUE,
    psicologo_id INT,
    motivo_consulta TEXT,
    historia_personal TEXT,
    historia_familiar TEXT,
    antecedentes_medicos TEXT,
    antecedentes_psiquiatricos TEXT,
    diagnostico_presuntivo VARCHAR(500),
    diagnostico_definitivo VARCHAR(500),
    tratamiento_actual TEXT,
    medicamentos JSON,
    alergias TEXT,
    factores_riesgo JSON,
    redes_apoyo TEXT,
    emergencia_contacto VARCHAR(255),
    emergencia_telefono VARCHAR(20),
    consentimiento_informado BOOLEAN DEFAULT FALSE,
    fecha_consentimiento DATE,
    restricciones_acceso JSON,
    notas_confidenciales TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE asignaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    psicologo_id INT NOT NULL,
    becario_id INT,
    fecha_inicio DATE NOT NULL DEFAULT (CURRENT_DATE),
    fecha_fin DATE,
    motivo_fin VARCHAR(255),
    estado ENUM('activa', 'finalizada', 'suspendida') DEFAULT 'activa',
    notas TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_paciente_estado (paciente_id, estado),
    INDEX idx_psicologo_estado (psicologo_id, estado),
    INDEX idx_becario (becario_id)
);

CREATE TABLE citas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    psicologo_id INT,
    becario_id INT,
    fecha DATE NOT NULL,
    hora TIME NOT NULL,
    tipo_consulta ENUM('presencial', 'virtual') DEFAULT 'presencial',
    estado ENUM('programada', 'confirmada', 'completada', 'cancelada') DEFAULT 'programada',
    notas TEXT,
    motivo_cancelacion VARCHAR(255),
    duracion INT DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_fecha_estado (fecha, estado),
    INDEX idx_psicologo_fecha (psicologo_id, fecha),
    INDEX idx_becario (becario_id),
    INDEX idx_paciente_id (paciente_id)
);

CREATE TABLE sesiones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    cita_id INT NOT NULL UNIQUE,
    psicologo_id INT NOT NULL,
    fecha DATE NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fin TIME NOT NULL,
    tipo_sesion ENUM('evaluacion', 'terapia', 'seguimiento', 'crisis') DEFAULT 'terapia',
    objetivo TEXT,
    desarrollo TEXT,
    conclusion TEXT,
    tareas_asignadas TEXT,
    emocion_predominante VARCHAR(100),
    riesgo_suicida ENUM('ninguno', 'bajo', 'moderado', 'alto') DEFAULT 'ninguno',
    escalas_aplicadas JSON,
    siguiente_cita DATE,
    privado BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (cita_id) REFERENCES citas(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_cita_id (cita_id),
    INDEX idx_psicologo_fecha (psicologo_id, fecha),
    INDEX idx_fecha (fecha)
);

CREATE TABLE notificaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    tipo ENUM('cita_programada', 'cita_modificada', 'cita_cancelada', 'asignacion_nueva', 'observacion_nueva', 'alerta_sistema', 'reporte_generado') NOT NULL,
    titulo VARCHAR(255) NOT NULL,
    mensaje TEXT NOT NULL,
    leido BOOLEAN DEFAULT FALSE,
    leido_at TIMESTAMP NULL,
    accion_url VARCHAR(500),
    prioridad ENUM('baja', 'media', 'alta', 'urgente') DEFAULT 'media',
    datos_extra JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_leido (usuario_id, leido),
    INDEX idx_created_at (created_at),
    INDEX idx_tipo (tipo)
);

CREATE TABLE altas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    usuario_id INT NOT NULL,
    tipo_alta ENUM('terapeutica', 'abandono', 'traslado', 'graduacion', 'no_continua', 'otro') NOT NULL,
    fecha_alta DATE NOT NULL DEFAULT (CURRENT_DATE),
    motivo_detallado TEXT,
    recomendaciones TEXT,
    sesiones_totales INT,
    evaluacion_final ENUM('excelente', 'buena', 'regular', 'mala'),
    seguimiento_recomendado BOOLEAN DEFAULT FALSE,
    fecha_seguimiento DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_paciente_id (paciente_id),
    INDEX idx_fecha_alta (fecha_alta),
    INDEX idx_tipo_alta (tipo_alta)
);

CREATE TABLE reportes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    tipo_reporte ENUM('mensual', 'trimestral', 'semestral', 'anual', 'personalizado', 'paciente', 'becario', 'psicologo') NOT NULL,
    nombre VARCHAR(255) NOT NULL,
    descripcion TEXT,
    parametros JSON,
    fecha_inicio DATE,
    fecha_fin DATE,
    formato ENUM('pdf', 'excel', 'csv', 'html') DEFAULT 'pdf',
    archivo_url VARCHAR(500),
    archivo_tamano INT,
    estado ENUM('pendiente', 'generando', 'completado', 'error') DEFAULT 'pendiente',
    compartido_con JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_id (usuario_id),
    INDEX idx_tipo_reporte_estado (tipo_reporte, estado),
    INDEX idx_created_at (created_at)
);

CREATE TABLE observaciones_becarios (
    id INT PRIMARY KEY AUTO_INCREMENT,
    becario_id INT NOT NULL,
    supervisor_id INT NOT NULL,
    cita_id INT,
    fecha DATE NOT NULL DEFAULT (CURRENT_DATE),
    tipo_observacion ENUM('sesion_observada', 'retroalimentacion', 'evaluacion_periodica', 'incidencia', 'reconocimiento') DEFAULT 'sesion_observada',
    aspecto_evaluado ENUM('empatia', 'tecnicas', 'documentacion', 'puntualidad', 'profesionalismo', 'etica') NOT NULL,
    calificacion INT NOT NULL CHECK (calificacion BETWEEN 1 AND 10),
    fortalezas TEXT,
    areas_mejora TEXT,
    recomendaciones TEXT,
    plan_accion TEXT,
    fecha_seguimiento DATE,
    privada BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (supervisor_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (cita_id) REFERENCES citas(id) ON DELETE SET NULL,
    INDEX idx_becario_fecha (becario_id, fecha),
    INDEX idx_supervisor (supervisor_id),
    INDEX idx_tipo_observacion (tipo_observacion)
);

CREATE TABLE disponibilidades (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    dia_semana ENUM('lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo') NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fin TIME NOT NULL,
    tipo_disponibilidad ENUM('regular', 'extraordinaria', 'limitada') DEFAULT 'regular',
    activo BOOLEAN DEFAULT TRUE,
    fecha_inicio_vigencia DATE NOT NULL DEFAULT (CURRENT_DATE),
    fecha_fin_vigencia DATE,
    notas TEXT,
    max_citas_dia INT DEFAULT 8,
    intervalo_citas INT DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_dia_activo (usuario_id, dia_semana, activo),
    INDEX idx_fecha_vigencia (fecha_inicio_vigencia, fecha_fin_vigencia)
);

CREATE TABLE logs_sistema (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT,
    tipo_log ENUM('login', 'logout', 'creacion', 'modificacion', 'eliminacion', 'error', 'seguridad', 'backup', 'reporte', 'sistema') NOT NULL,
    modulo VARCHAR(100) NOT NULL,
    accion VARCHAR(255) NOT NULL,
    descripcion TEXT,
    datos_antes JSON,
    datos_despues JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    severidad ENUM('info', 'advertencia', 'error', 'critico') DEFAULT 'info',
    resuelto BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_tipo_log_fecha (tipo_log, created_at),
    INDEX idx_usuario_id (usuario_id),
    INDEX idx_modulo (modulo),
    INDEX idx_severidad_resuelto (severidad, resuelto)
);

CREATE TABLE permisos (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL UNIQUE,
    descripcion TEXT,
    categoria ENUM('administracion', 'pacientes', 'citas', 'reportes', 'configuracion', 'usuarios') NOT NULL,
    nivel_requerido ENUM('basico', 'intermedio', 'avanzado', 'administrador') DEFAULT 'basico',
    activo BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE usuario_permisos (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    permiso_id INT NOT NULL,
    concedido BOOLEAN DEFAULT FALSE,
    concedido_por INT,
    fecha_concesion TIMESTAMP NULL,
    fecha_expiracion TIMESTAMP NULL,
    motivo TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (permiso_id) REFERENCES permisos(id) ON DELETE CASCADE,
    FOREIGN KEY (concedido_por) REFERENCES users(id) ON DELETE SET NULL,
    UNIQUE KEY idx_usuario_permiso (usuario_id, permiso_id)
);

CREATE TABLE backups (
    id INT PRIMARY KEY AUTO_INCREMENT,
    tipo ENUM('completo', 'incremental') NOT NULL,
    ruta VARCHAR(500) NOT NULL,
    tamano BIGINT,
    base_backup_id INT,
    cambios INT DEFAULT 0,
    estado ENUM('pendiente', 'generando', 'completado', 'error', 'eliminado') DEFAULT 'pendiente',
    ultima_restauracion TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (base_backup_id) REFERENCES backups(id) ON DELETE SET NULL
);

INSERT INTO permisos (nombre, descripcion, categoria, nivel_requerido) VALUES
('ver_panel_coordinacion', 'Ver panel de coordinación', 'administracion', 'avanzado'),
('gestionar_usuarios', 'Gestionar usuarios (alta/baja/edición)', 'usuarios', 'avanzado'),
('gestionar_fundaciones', 'Gestionar fundaciones', 'administracion', 'avanzado'),
('gestionar_pacientes', 'Gestionar pacientes', 'pacientes', 'intermedio'),
('gestionar_asignaciones', 'Asignar pacientes a psicólogos/becarios', 'pacientes', 'intermedio'),
('ver_agenda_global', 'Ver agenda global completa', 'citas', 'intermedio'),
('generar_reportes', 'Generar reportes estadísticos', 'reportes', 'avanzado'),
('gestionar_altas', 'Gestionar altas de pacientes', 'pacientes', 'intermedio'),
('ver_expedientes_completos', 'Ver expedientes completos de pacientes', 'pacientes', 'avanzado'),
('configurar_sistema', 'Configurar parámetros del sistema', 'configuracion', 'administrador'),
('ver_panel_psicologo', 'Ver panel principal de psicólogo', 'administracion', 'basico'),
('ver_mis_pacientes', 'Ver pacientes asignados', 'pacientes', 'basico'),
('gestionar_mis_citas', 'Gestionar mis propias citas', 'citas', 'basico'),
('registrar_sesiones', 'Registrar contenido de sesiones', 'citas', 'intermedio'),
('supervisar_becarios', 'Supervisar becarios asignados', 'usuarios', 'intermedio'),
('crear_observaciones', 'Crear observaciones de becarios', 'usuarios', 'intermedio'),
('ver_expedientes_asignados', 'Ver expedientes de pacientes asignados', 'pacientes', 'intermedio'),
('dar_altas_pacientes', 'Dar de alta a pacientes', 'pacientes', 'intermedio'),
('ver_panel_becario', 'Ver panel principal de becario', 'administracion', 'basico'),
('ver_citas_dia', 'Ver citas del día', 'citas', 'basico'),
('gestionar_citas_asignadas', 'Gestionar citas asignadas', 'citas', 'basico'),
('ver_pacientes_asignados', 'Ver pacientes asignados', 'pacientes', 'basico'),
('ver_observaciones_propias', 'Ver observaciones propias', 'usuarios', 'basico'),
('configurar_disponibilidad', 'Configurar disponibilidad personal', 'configuracion', 'basico');

INSERT INTO fundaciones (nombre, telefono, email, responsable) VALUES
('Fundación Salud Mental Comunitaria', '555-1234', 'contacto@fsmc.org', 'Dra. María González'),
('Asociación de Psicología Aplicada', '555-5678', 'info@asocpsicologia.edu', 'Lic. Carlos Rodríguez');

INSERT INTO users (email, password, nombre, apellido, telefono, rol, especialidad, fundacion_id) VALUES
('coordinador@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Ana', 'Martínez', '555-1111', 'coordinador', 'Coordinación Clínica', 1),
('psicologo1@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Luis', 'Fernández', '555-2222', 'psicologo', 'Terapia Cognitivo-Conductual', 1),
('becario1@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Juan', 'Pérez', '555-3333', 'becario', 'Practicante de Psicología', 1),
('becario2@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Sofía', 'Ramírez', '555-4444', 'becario', 'Practicante de Psicología', 2),
('psicologo2@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Laura', 'Gutiérrez', '555-5555', 'psicologo', 'Terapia Familiar', 1),
('becario3@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Pedro', 'Hernández', '555-6666', 'becario', 'Practicante de Psicología', 1);

INSERT INTO pacientes (nombre, apellido, fecha_nacimiento, genero, telefono, email) VALUES 
('Carlos', 'Gómez', '1998-05-15', 'masculino', '555-0011', 'carlos@gmail.com'),
('Mariana', 'López', '1995-08-22', 'femenino', '555-0022', 'mariana@hotmail.com'),
('Roberto', 'Sánchez', '2000-02-10', 'masculino', '555-0033', 'roberto@yahoo.com');

INSERT INTO expedientes (paciente_id, psicologo_id, motivo_consulta) VALUES
(1, 2, 'Ansiedad académica con síntomas de estrés elevado'),
(2, 2, 'Estrés laboral crónico con afectación del sueño'),
(3, 2, 'Dificultades de adaptación al entorno universitario');

INSERT INTO asignaciones (paciente_id, psicologo_id, becario_id, fecha_inicio) VALUES
(1, 2, 3, CURDATE()),
(2, 2, 4, CURDATE()),
(3, 2, NULL, CURDATE());

INSERT INTO citas (paciente_id, psicologo_id, becario_id, fecha, hora, estado, tipo_consulta, notas) VALUES
(1, 2, 3, DATE_ADD(CURDATE(), INTERVAL 1 DAY), '10:00:00', 'programada', 'presencial', 'Primera consulta'),
(2, 2, 4, DATE_ADD(CURDATE(), INTERVAL 2 DAY), '11:00:00', 'confirmada', 'virtual', 'Seguimiento'),
(3, 2, NULL, DATE_ADD(CURDATE(), INTERVAL 3 DAY), '09:00:00', 'programada', 'presencial', 'Evaluación inicial');

INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje) VALUES
(3, 'cita_programada', 'Nueva cita asignada', 'Tienes una nueva cita con Carlos Gómez para mañana a las 10:00 AM'),
(4, 'cita_modificada', 'Cita modificada', 'La cita con Mariana López ha sido cambiada a modalidad virtual');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'coordinador'
AND p.nivel_requerido IN ('basico', 'intermedio', 'avanzado', 'administrador');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'psicologo'
AND p.nivel_requerido IN ('basico', 'intermedio');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'becario'
AND p.nivel_requerido = 'basico';

CREATE VIEW vista_citas_hoy AS
SELECT 
    c.id,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    c.fecha,
    TIME_FORMAT(c.hora, '%H:%i') AS hora,
    c.estado,
    c.tipo_consulta,
    u_psi.nombre AS psicologo_nombre,
    u_bec.nombre AS becario_nombre
FROM citas c
JOIN pacientes p ON c.paciente_id = p.id
JOIN users u_psi ON c.psicologo_id = u_psi.id
LEFT JOIN users u_bec ON c.becario_id = u_bec.id
WHERE c.fecha = CURDATE()
AND c.estado IN ('programada', 'confirmada')
ORDER BY c.hora;

CREATE VIEW vista_pacientes_asignados AS
SELECT 
    a.id,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    p.telefono,
    p.email,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    CONCAT(ub.nombre, ' ', ub.apellido) AS becario,
    a.fecha_inicio,
    a.estado AS estado_asignacion,
    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'completada') AS sesiones_completadas,
    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado IN ('programada', 'confirmada') AND fecha >= CURDATE()) AS citas_pendientes
FROM asignaciones a
JOIN pacientes p ON a.paciente_id = p.id
JOIN users u ON a.psicologo_id = u.id
LEFT JOIN users ub ON a.becario_id = ub.id
WHERE p.activo = TRUE AND a.estado = 'activa';

CREATE VIEW vista_resumen_coordinacion AS
SELECT 
    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) AS becarios_activos,
    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) AS psicologos_activos,
    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) AS pacientes_activos,
    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) AS citas_hoy,
    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') AS citas_completadas_hoy,
    (SELECT COUNT(*) FROM altas WHERE MONTH(fecha_alta) = MONTH(CURDATE())) AS altas_mes_actual;

CREATE VIEW vista_historial_sesiones AS
SELECT 
    s.id,
    s.fecha,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    s.desarrollo AS contenido_sesion,
    s.conclusion AS observaciones,
    s.tareas_asignadas,
    s.siguiente_cita AS proxima_sesion
FROM sesiones s
JOIN citas c ON s.cita_id = c.id
JOIN pacientes p ON c.paciente_id = p.id
JOIN users u ON s.psicologo_id = u.id
ORDER BY s.fecha DESC;

CREATE VIEW vista_estadisticas_psicologos AS
SELECT 
    u.id,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    COUNT(DISTINCT a.paciente_id) AS pacientes_asignados,
    COUNT(c.id) AS total_citas,
    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS citas_completadas,
    ROUND(AVG(CASE WHEN c.estado = 'completada' THEN c.duracion END), 1) AS duracion_promedio,
    COUNT(DISTINCT a.becario_id) AS becarios_supervisados
FROM users u
LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
WHERE u.rol = 'psicologo' AND u.activo = TRUE
GROUP BY u.id, u.nombre, u.apellido;

CREATE VIEW vista_disponibilidad_semanal AS
SELECT 
    u.id,
    CONCAT(u.nombre, ' ', u.apellido) AS profesional,
    u.rol,
    d.dia_semana,
    TIME_FORMAT(d.hora_inicio, '%H:%i') AS hora_inicio,
    TIME_FORMAT(d.hora_fin, '%H:%i') AS hora_fin,
    d.max_citas_dia,
    (SELECT COUNT(*) FROM citas c 
     WHERE (c.psicologo_id = u.id OR c.becario_id = u.id)
     AND c.fecha = CURDATE()
     AND c.estado IN ('programada', 'confirmada')) AS citas_hoy
FROM users u
LEFT JOIN disponibilidades d ON u.id = d.usuario_id AND d.activo = TRUE
WHERE u.rol IN ('psicologo', 'becario') AND u.activo = TRUE
ORDER BY u.rol, u.apellido, FIELD(d.dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo');

DELIMITER $$
CREATE PROCEDURE sp_obtener_citas_por_fecha_becario(
    IN p_fecha DATE,
    IN p_becario_id INT
)
BEGIN
    SELECT 
        c.*,
        CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
        p.telefono AS paciente_telefono,
        p.email AS paciente_email,
        u_psi.nombre AS psicologo_nombre,
        u_bec.nombre AS becario_nombre,
        c.duracion AS duracion_minutos,
        c.notas AS motivo
    FROM citas c
    JOIN pacientes p ON c.paciente_id = p.id
    LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
    LEFT JOIN users u_bec ON c.becario_id = u_bec.id
    WHERE c.fecha = p_fecha
    AND (c.becario_id = p_becario_id OR p_becario_id IS NULL)
    ORDER BY c.hora;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE sp_generar_reporte_mensual(
    IN p_mes INT,
    IN p_anio INT,
    IN p_psicologo_id INT
)
BEGIN
    SELECT 
        p.id,
        CONCAT(p.nombre, ' ', p.apellido) AS paciente,
        COUNT(c.id) AS total_sesiones,
        SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS sesiones_completadas,
        SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) AS sesiones_canceladas,
        SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) AS sesiones_programadas,
        MIN(c.fecha) AS primera_sesion_mes,
        MAX(c.fecha) AS ultima_sesion_mes
    FROM pacientes p
    LEFT JOIN citas c ON p.id = c.paciente_id 
        AND MONTH(c.fecha) = p_mes 
        AND YEAR(c.fecha) = p_anio
        AND (c.psicologo_id = p_psicologo_id OR p_psicologo_id IS NULL)
    WHERE p.activo = TRUE
    GROUP BY p.id, p.nombre, p.apellido
    ORDER BY p.apellido, p.nombre;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_insert_alta
AFTER INSERT ON altas
FOR EACH ROW
BEGIN
    UPDATE pacientes 
    SET estado = CONCAT('alta_', NEW.tipo_alta),
        activo = FALSE,
        updated_at = NOW()
    WHERE id = NEW.paciente_id;
    
    UPDATE citas 
    SET estado = 'cancelada',
        motivo_cancelacion = CONCAT('Paciente dado de alta (', NEW.tipo_alta, ')'),
        updated_at = NOW()
    WHERE paciente_id = NEW.paciente_id 
    AND fecha >= CURDATE()
    AND estado IN ('programada', 'confirmada');
    
    UPDATE asignaciones 
    SET estado = 'finalizada',
        fecha_fin = CURDATE(),
        motivo_fin = CONCAT('Paciente dado de alta (', NEW.tipo_alta, ')')
    WHERE paciente_id = NEW.paciente_id 
    AND estado = 'activa';
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_update_cita
AFTER UPDATE ON citas
FOR EACH ROW
BEGIN
    DECLARE paciente_nombre VARCHAR(200);
    DECLARE paciente_email VARCHAR(255);
    
    IF OLD.fecha != NEW.fecha OR OLD.hora != NEW.hora OR OLD.tipo_consulta != NEW.tipo_consulta THEN
        
        SELECT CONCAT(nombre, ' ', apellido), email INTO paciente_nombre, paciente_email
        FROM pacientes WHERE id = NEW.paciente_id;
        
        IF NEW.psicologo_id IS NOT NULL THEN
            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
            VALUES (
                NEW.psicologo_id,
                'cita_modificada',
                'Cita modificada',
                CONCAT('La cita con ', paciente_nombre, ' ha sido modificada. Nueva fecha: ', NEW.fecha, ' ', TIME_FORMAT(NEW.hora, '%H:%i')),
                NOW()
            );
        END IF;
        
        IF NEW.becario_id IS NOT NULL THEN
            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
            VALUES (
                NEW.becario_id,
                'cita_modificada',
                'Cita modificada',
                CONCAT('La cita con ', paciente_nombre, ' ha sido modificada. Nueva fecha: ', NEW.fecha, ' ', TIME_FORMAT(NEW.hora, '%H:%i')),
                NOW()
            );
        END IF;
        
        INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
        VALUES (
            NEW.psicologo_id,
            'modificacion',
            'citas',
            'Actualizar cita',
            CONCAT('Cita ', NEW.id, ' modificada para paciente ', paciente_nombre),
            NOW()
        );
    END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_insert_sesion
AFTER INSERT ON sesiones
FOR EACH ROW
BEGIN
    UPDATE expedientes 
    SET riesgo_suicida = NEW.riesgo_suicida,
        updated_at = NOW()
    WHERE paciente_id = (SELECT paciente_id FROM citas WHERE id = NEW.cita_id);
END$$
DELIMITER ;

CREATE INDEX idx_pacientes_activo ON pacientes(activo);
CREATE INDEX idx_citas_psicologo_fecha ON citas(psicologo_id, fecha, estado);
CREATE INDEX idx_sesiones_cita ON sesiones(cita_id);
CREATE INDEX idx_asignaciones_psicologo ON asignaciones(psicologo_id, fecha_fin);
CREATE INDEX idx_users_rol_activo ON users(rol, activo);
CREATE INDEX idx_expediente_paciente ON expedientes(paciente_id);
CREATE INDEX idx_expediente_psicologo ON expedientes(psicologo_id);
CREATE INDEX idx_reportes_usuario ON reportes(usuario_id, estado);
CREATE INDEX idx_reportes_tipo ON reportes(tipo_reporte, created_at);
CREATE INDEX idx_disponibilidades_vigencia ON disponibilidades(fecha_inicio_vigencia, fecha_fin_vigencia);
CREATE INDEX idx_logs_severidad ON logs_sistema(severidad, resuelto);
CREATE INDEX idx_observaciones_fecha_seguimiento ON observaciones_becarios(fecha_seguimiento);

CREATE USER IF NOT EXISTS 'psicogestion_user'@'localhost' IDENTIFIED BY 'SecurePass123!';
GRANT ALL PRIVILEGES ON psicogestion_db.* TO 'psicogestion_user'@'localhost';
GRANT EXECUTE ON PROCEDURE psicogestion_db.sp_obtener_citas_por_fecha_becario TO 'psicogestion_user'@'localhost';
GRANT EXECUTE ON PROCEDURE psicogestion_db.sp_generar_reporte_mensual TO 'psicogestion_user'@'localhost';
FLUSH PRIVILEGES;


/frontend/src/index.js:
--------------------------------------------------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './global.css';
import './App.css';

// Importa los estilos de los modales
import './components/Common/ConfirmModal.css';
import './components/Common/NotificationModal.css';

import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


/backend/src/controllers/reporteController.js:
--------------------------------------------------------------------------------
const Reporte = require('../models/reporteModel');
const ReporteService = require('../services/reporteService');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');
const path = require('path');
const fs = require('fs').promises;

class ReporteController {
    
    static async generarReporteMensual(req, res) {
        try {
            const { mes, anio, formato = 'excel' } = req.query;
            const usuarioId = req.user.id;
            
            if (!mes || !anio) {
                return res.status(400).json({
                    success: false,
                    message: 'Los parámetros mes y anio son requeridos'
                });
            }
            
            // Crear registro de reporte
            const reporte = await Reporte.create({
                usuario_id: usuarioId,
                tipo_reporte: 'mensual',
                nombre: `Reporte Mensual ${mes}/${anio}`,
                descripcion: `Reporte de actividades del mes ${mes} del año ${anio}`,
                parametros: { mes, anio, formato },
                fecha_inicio: `${anio}-${mes.padStart(2, '0')}-01`,
                fecha_fin: this.obtenerUltimoDiaMes(anio, mes),
                formato,
                estado: 'generando'
            });
            
            // Generar reporte en segundo plano
            this.generarReporteEnSegundoPlano(reporte.id, { mes, anio, formato, usuarioId });
            
            res.json({
                success: true,
                message: 'Reporte en proceso de generación',
                data: {
                    reporteId: reporte.id,
                    estado: 'generando',
                    formatoSolicitado: formato
                }
            });
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte mensual',
                error: error.message
            });
        }
    }
    
    static async generarReportePaciente(req, res) {
        try {
            const { paciente_id, fecha_inicio, fecha_fin, formato = 'pdf' } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el paciente existe
            const [paciente] = await sequelize.query(
                'SELECT id, nombre, apellido FROM pacientes WHERE id = ?',
                { replacements: [paciente_id], type: QueryTypes.SELECT }
            );
            
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Crear registro de reporte
            const reporte = await Reporte.create({
                usuario_id: usuarioId,
                tipo_reporte: 'paciente',
                nombre: `Reporte Paciente ${paciente.nombre} ${paciente.apellido}`,
                descripcion: `Reporte completo del paciente ${paciente.nombre} ${paciente.apellido}`,
                parametros: { paciente_id, fecha_inicio, fecha_fin, formato },
                fecha_inicio: fecha_inicio || null,
                fecha_fin: fecha_fin || null,
                formato,
                estado: 'generando'
            });
            
            // Generar reporte en segundo plano
            this.generarReportePacienteEnSegundoPlano(reporte.id, { paciente_id, fecha_inicio, fecha_fin, formato, usuarioId });
            
            res.json({
                success: true,
                message: 'Reporte de paciente en proceso de generación',
                data: {
                    reporteId: reporte.id,
                    estado: 'generando',
                    paciente: `${paciente.nombre} ${paciente.apellido}`
                }
            });
            
        } catch (error) {
            console.error('Error en generarReportePaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte de paciente'
            });
        }
    }
    
    static async generarReporteExcel(req, res) {
        try {
            const { tipo, mes, anio, psicologo_id, becario_id, fecha_inicio, fecha_fin } = req.query;
            const usuarioId = req.user.id;
            
            // Obtener datos según tipo
            let datos;
            let nombreReporte;
            
            switch (tipo) {
                case 'citas':
                    datos = await this.obtenerDatosCitasExcel({ mes, anio, psicologo_id, becario_id, fecha_inicio, fecha_fin });
                    nombreReporte = `Reporte_Citas_${mes || 'personalizado'}_${anio || new Date().getFullYear()}`;
                    break;
                    
                case 'pacientes':
                    datos = await this.obtenerDatosPacientesExcel({ fecha_inicio, fecha_fin });
                    nombreReporte = `Reporte_Pacientes_${new Date().toISOString().slice(0, 10)}`;
                    break;
                    
                case 'sesiones':
                    datos = await this.obtenerDatosSesionesExcel({ mes, anio, psicologo_id, fecha_inicio, fecha_fin });
                    nombreReporte = `Reporte_Sesiones_${mes || 'personalizado'}_${anio || new Date().getFullYear()}`;
                    break;
                    
                case 'becarios':
                    datos = await this.obtenerDatosBecariosExcel({ mes, anio, fecha_inicio, fecha_fin });
                    nombreReporte = `Reporte_Becarios_${mes || 'personalizado'}_${anio || new Date().getFullYear()}`;
                    break;
                    
                default:
                    return res.status(400).json({
                        success: false,
                        message: 'Tipo de reporte no válido'
                    });
            }
            
            // Generar Excel
            const buffer = await ReporteService.generarExcel(datos, tipo);
            
            // Crear registro
            await Reporte.create({
                usuario_id: usuarioId,
                tipo_reporte: tipo,
                nombre: nombreReporte,
                descripcion: `Reporte de ${tipo} generado el ${new Date().toLocaleDateString()}`,
                parametros: { tipo, mes, anio, psicologo_id, becario_id, fecha_inicio, fecha_fin },
                formato: 'excel',
                estado: 'completado'
            });
            
            // Configurar respuesta
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename="${nombreReporte}.xlsx"`);
            
            res.send(buffer);
            
        } catch (error) {
            console.error('Error en generarReporteExcel:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte Excel'
            });
        }
    }
    
    static async obtenerMisReportes(req, res) {
        try {
            const usuarioId = req.user.id;
            const { tipo_reporte, estado, limit = 20, offset = 0 } = req.query;
            
            const whereClause = { usuario_id: usuarioId };
            
            if (tipo_reporte) whereClause.tipo_reporte = tipo_reporte;
            if (estado) whereClause.estado = estado;
            
            const reportes = await Reporte.findAll({
                where: whereClause,
                order: [['created_at', 'DESC']],
                limit: parseInt(limit),
                offset: parseInt(offset)
            });
            
            res.json({
                success: true,
                data: reportes,
                count: reportes.length
            });
            
        } catch (error) {
            console.error('Error en obtenerMisReportes:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener reportes'
            });
        }
    }
    
    static async descargarReporte(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const reporte = await Reporte.findByPk(id);
            
            if (!reporte) {
                return res.status(404).json({
                    success: false,
                    message: 'Reporte no encontrado'
                });
            }
            
            // Verificar permisos
            if (reporte.usuario_id !== usuarioId && 
                (!reporte.compartido_con || !reporte.compartido_con.includes(usuarioId.toString()))) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para descargar este reporte'
                });
            }
            
            if (reporte.estado !== 'completado' || !reporte.archivo_url) {
                return res.status(400).json({
                    success: false,
                    message: 'El reporte no está disponible para descarga'
                });
            }
            
            // Obtener ruta del archivo
            const filePath = path.join(__dirname, '..', '..', reporte.archivo_url);
            
            // Verificar que el archivo existe
            try {
                await fs.access(filePath);
            } catch {
                return res.status(404).json({
                    success: false,
                    message: 'Archivo no encontrado'
                });
            }
            
            // Determinar Content-Type
            let contentType;
            switch (reporte.formato) {
                case 'pdf':
                    contentType = 'application/pdf';
                    break;
                case 'excel':
                    contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                    break;
                case 'csv':
                    contentType = 'text/csv';
                    break;
                default:
                    contentType = 'application/octet-stream';
            }
            
            // Enviar archivo
            res.setHeader('Content-Type', contentType);
            res.setHeader('Content-Disposition', `attachment; filename="${reporte.nombre}.${reporte.formato}"`);
            
            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);
            
        } catch (error) {
            console.error('Error en descargarReporte:', error);
            res.status(500).json({
                success: false,
                message: 'Error al descargar reporte'
            });
        }
    }
    
    // Métodos auxiliares para obtener datos
    static async obtenerDatosCitasExcel(params) {
        const query = `
            SELECT 
                c.fecha as DIA,
                TIME_FORMAT(c.hora, '%H:%i') as HORA,
                CONCAT(p.nombre, ' ', p.apellido) as ESTUDIANTE,
                p.matricula as MATRICULA,
                p.carrera as CARRERA,
                p.edad as EDAD,
                p.sexo as SEXO,
                p.telefono as TELEFONO,
                p.email as CORREO,
                c.tipo_consulta as MODALIDAD,
                c.estado as ESTATUS,
                u_bec.nombre as PRACTICANTE,
                u_psi.nombre as ATIENDE,
                c.motivo as OBSERVACIONES,
                MONTH(c.fecha) as MES
            FROM citas c
            JOIN pacientes p ON c.paciente_id = p.id
            LEFT JOIN users u_bec ON c.becario_id = u_bec.id
            LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
            WHERE 1=1
        `;
        
        const replacements = [];
        let whereClause = '';
        
        if (params.mes && params.anio) {
            whereClause += ` AND MONTH(c.fecha) = ? AND YEAR(c.fecha) = ?`;
            replacements.push(params.mes, params.anio);
        }
        
        if (params.fecha_inicio && params.fecha_fin) {
            whereClause += ` AND c.fecha BETWEEN ? AND ?`;
            replacements.push(params.fecha_inicio, params.fecha_fin);
        }
        
        if (params.psicologo_id) {
            whereClause += ` AND c.psicologo_id = ?`;
            replacements.push(params.psicologo_id);
        }
        
        if (params.becario_id) {
            whereClause += ` AND c.becario_id = ?`;
            replacements.push(params.becario_id);
        }
        
        const finalQuery = query + whereClause + ' ORDER BY c.fecha, c.hora';
        
        return await sequelize.query(finalQuery, {
            replacements,
            type: QueryTypes.SELECT
        });
    }
    
    static async obtenerDatosPacientesExcel(params) {
        const query = `
            SELECT 
                p.nombre as NOMBRE,
                p.apellido as APELLIDO,
                p.matricula as MATRICULA,
                p.telefono as TELEFONO,
                p.carrera as CARRERA,
                p.cuatri as CUATRI,
                p.tipo_servicio as TIPO_DE_SERVICIO,
                p.fecha_presentacion as FECHA_DE_PRESENTACION,
                (SELECT COUNT(*) FROM citas c WHERE c.paciente_id = p.id AND c.estado = 'completada') as No_de_sesiones_terapeuticas_personales,
                a.fecha_aceptacion as FECHA_DE_ACEPTACION,
                p.mmpi2_rf as MMPI_2_RF,
                al.fecha_alta as FECHA_DE_TERMINO,
                al.carta_liberacion as CARTA_DE_LIBERACION,
                p.horas_objetivo as HORAS_OBJETIVO,
                p.horas_realizadas as HORAS_REALIZADAS,
                p.horas_faltantes as HORAS_FALTANTES,
                p.servicio_comunitario_liberado as SERVICIO_COMUNITARIO_LIBERADO,
                u_psi.nombre as QUIEN_ATIENDE,
                p.observaciones as OBSERVACIONES
            FROM pacientes p
            LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
            LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
            LEFT JOIN altas al ON p.id = al.paciente_id
            WHERE p.activo = TRUE
        `;
        
        const replacements = [];
        let whereClause = '';
        
        if (params.fecha_inicio && params.fecha_fin) {
            whereClause += ` AND p.created_at BETWEEN ? AND ?`;
            replacements.push(params.fecha_inicio, params.fecha_fin);
        }
        
        const finalQuery = query + whereClause + ' ORDER BY p.apellido, p.nombre';
        
        return await sequelize.query(finalQuery, {
            replacements,
            type: QueryTypes.SELECT
        });
    }
    
    // Método auxiliar para generar reporte en segundo plano
    static async generarReporteEnSegundoPlano(reporteId, params) {
        try {
            // Aquí iría la lógica para generar el reporte
            // Por ahora simulamos la generación
            
            setTimeout(async () => {
                try {
                    const reporte = await Reporte.findByPk(reporteId);
                    if (reporte) {
                        await reporte.update({
                            estado: 'completado',
                            archivo_url: `/reports/${reporteId}.${params.formato}`
                        });
                        
                        // Notificar al usuario
                        await sequelize.query(`
                            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                            VALUES (?, 'reporte_generado', 'Reporte listo', 
                            'Su reporte mensual ha sido generado y está listo para descargar.', NOW())
                        `, { replacements: [params.usuarioId] });
                    }
                } catch (error) {
                    console.error('Error al actualizar reporte:', error);
                }
            }, 5000); // Simulamos 5 segundos de procesamiento
            
        } catch (error) {
            console.error('Error en generarReporteEnSegundoPlano:', error);
        }
    }
    
    // Método auxiliar para obtener último día del mes
    static obtenerUltimoDiaMes(anio, mes) {
        return new Date(anio, mes, 0).toISOString().split('T')[0];
    }
}

module.exports = ReporteController;


/backend/src/models/reporteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Reporte = sequelize.define('Reporte', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_reporte: {
        type: DataTypes.ENUM(
            'mensual',
            'trimestral',
            'semestral',
            'anual',
            'personalizado',
            'paciente',
            'becario',
            'psicologo'
        ),
        allowNull: false
    },
    nombre: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    parametros: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con parámetros del reporte'
    },
    fecha_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    fecha_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    formato: {
        type: DataTypes.ENUM('pdf', 'excel', 'csv', 'html'),
        defaultValue: 'pdf'
    },
    archivo_url: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    archivo_tamano: {
        type: DataTypes.INTEGER,
        allowNull: true,
        comment: 'Tamaño en bytes'
    },
    estado: {
        type: DataTypes.ENUM('pendiente', 'generando', 'completado', 'error'),
        defaultValue: 'pendiente'
    },
    compartido_con: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con IDs de usuarios con acceso'
    }
}, {
    tableName: 'reportes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['usuario_id']
        },
        {
            fields: ['tipo_reporte', 'estado']
        },
        {
            fields: ['created_at']
        }
    ]
});

Reporte.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Reporte;


/backend/server.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerDocument = require('./src/doc/swagger.json');
const cors = require('cors');

const sequelize = require('./src/config/db');

// Importar modelos
require('./src/models/userModel');
require('./src/models/pacienteModel');
require('./src/models/citaModel');
// Importar otros modelos según necesites

const authRoutes = require('./src/routes/authRoutes');
const citaRoutes = require('./src/routes/citaRoutes');
const roleRoutes = require('./src/routes/roleRoutes');
const fundacionRoutes = require('./src/routes/fundacionRoutes');
const asignacionRoutes = require('./src/routes/asignacionRoutes');
const sesionRoutes = require('./src/routes/sesionRoutes');
const notificacionRoutes = require('./src/routes/notificacionRoutes');
const altaRoutes = require('./src/routes/altaRoutes');
const reporteRoutes = require('./src/routes/reporteRoutes');
const observacionRoutes = require('./src/routes/observacionRoutes');
const disponibilidadRoutes = require('./src/routes/disponibilidadRoutes');
const expedienteRoutes = require('./src/routes/expedienteRoutes');
const dashboardRoutes = require('./src/routes/dashboardRoutes');
const agendaRoutes = require('./src/routes/agendaRoutes');
const estadisticaRoutes = require('./src/routes/estadisticaRoutes');
const pacienteRoutes = require('./src/routes/pacienteRoutes');

const app = express();
const PORT = process.env.PORT || 3000;



app.use(cors({
  origin: 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.get('/', (req, res) => {
  res.send('Server is running! Check /api-docs for documentation.');
});

app.use('/api/auth', authRoutes);
app.use('/api/citas', citaRoutes);
app.use('/api/fundaciones', fundacionRoutes);
app.use('/api/asignaciones', asignacionRoutes);
app.use('/api/sesiones', sesionRoutes);
app.use('/api/notificaciones', notificacionRoutes);
app.use('/api/altas', altaRoutes);
app.use('/api/reportes', reporteRoutes);
app.use('/api/observaciones', observacionRoutes);
app.use('/api/disponibilidad', disponibilidadRoutes);
app.use('/api/expedientes', expedienteRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/agenda', agendaRoutes);
app.use('/api/estadisticas', estadisticaRoutes);
const userRoutes = require('./src/routes/userRoutes');
app.use('/api/users', userRoutes);
app.use('/api/roles', roleRoutes);
app.use('/api/pacientes', pacienteRoutes);

// Sincronizar modelos
sequelize.sync({ force: false, alter: false })
    .then(() => {
        console.log("✅ Tablas sincronizadas (base de datos lista)");
        app.listen(PORT, () => {
          console.log(`Backend running on http://localhost:${PORT}`);
          console.log(`Swagger docs: http://localhost:${PORT}/api-docs`);
          console.log(`CORS permitido para: http://localhost:3001`);
          console.log(`Endpoints disponibles:`);
          console.log(`  GET  /api/citas/citas-por-fecha?fecha=YYYY-MM-DD&becario_id=1`);
          console.log(`  GET  /api/citas/reporte-mensual?mes=1&anio=2024`);
          console.log(`  POST /api/citas/alta-paciente`);
          console.log(`  PUT  /api/citas/cita/:id`);
        });
    })
    .catch((error) => {
        console.error("❌ Error al sincronizar la base de datos:", error.message);
    });


/frontend/src/services/api.js:
--------------------------------------------------------------------------------
// frontend/src/services/api.js
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    const headers = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    return headers;
  }

  static async request(url, options = {}) {
    const { method = 'GET', data } = options;
    
    const config = {
      method,
      headers: this.getHeaders(),
      credentials: 'include' // Importante para cookies si las usas
    };
    
    if (data) {
      config.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(`${API_BASE_URL}${url}`, config);
      return this.handleResponse(response);
    } catch (error) {
      console.error('Fetch error:', error);
      throw error;
    }
  }

  static async get(url) {
    return this.request(url);
  }

  static async post(url, data) {
    return this.request(url, { method: 'POST', data });
  }

  static async put(url, data) {
    return this.request(url, { method: 'PUT', data });
  }

  static async delete(url) {
    return this.request(url, { method: 'DELETE' });
  }

  static async handleResponse(response) {
    // Primero verificar si hay contenido
    if (response.status === 204 || response.status === 205) {
      return {};
    }
    
    const contentType = response.headers.get('content-type');
    
    // Si no es JSON, manejar como texto
    if (!contentType || !contentType.includes('application/json')) {
      const text = await response.text();
      
      if (!response.ok) {
        throw new Error(text || `HTTP error! status: ${response.status}`);
      }
      
      return text ? JSON.parse(text) : {};
    }
    
    const data = await response.json();
    
    if (!response.ok) {
      const errorMessage = data.message || data.error || `HTTP error! status: ${response.status}`;
      const error = new Error(errorMessage);
      error.status = response.status;
      error.data = data;
      throw error;
    }
    
    return data;
  }

  // Métodos específicos para el dashboard
  static async getDashboardCoordinador() {
    return this.get('/dashboard/coordinador');
  }

  static async getMetricasGlobales(periodo = 'mes') {
    return this.get(`/dashboard/metricas-globales?periodo=${periodo}`);
  }

  static async getEstadisticas() {
    return this.get('/estadisticas/generales');
  }

  // Método para obtener información del usuario actual
  static async getCurrentUser() {
    return this.get('/auth/me');
  }
}

export default ApiService;


/frontend/src/App.js:
--------------------------------------------------------------------------------
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Login from './components/Auth/Login';
import RoleRouter from './components/Auth/RoleRouter';
import ProtectedRoute from './components/Auth/ProtectedRoute';

// Importa los modales
import ConfirmModal from './components/Common/ConfirmModal';
import NotificationModal from './components/Common/NotificationModal';

// Páginas para Becarios
import BecarioDashboard from './pages/becario/DashboardPage';
import BecarioCitas from './pages/becario/CitasPage';
import BecarioPacientes from './pages/becario/PacientesPage';
import BecarioNotificaciones from './pages/becario/NotificacionesPage';
import BecarioObservaciones from './pages/becario/ObservacionesPage';

// Páginas para Psicólogos
import PsicologoDashboard from './pages/psicologo/DashboardPage';
import PsicologoPacientes from './pages/psicologo/PacientesPage';
import PsicologoCitas from './pages/psicologo/CitasPage';
import PsicologoExpedientes from './pages/psicologo/ExpedientesPage';
import PsicologoSesiones from './pages/psicologo/SesionesPage';
import PsicologoSupervision from './pages/psicologo/SupervisionPage';

// Páginas para Coordinadores
import CoordinadorDashboard from './pages/coordinador/DashboardPage';
import CoordinadorUsuarios from './pages/coordinador/UsuariosPage';
import CoordinadorPacientes from './pages/coordinador/PacientesPage';
import CoordinadorAsignaciones from './pages/coordinador/AsignacionesPage';
import CoordinadorAgenda from './pages/coordinador/AgendaPage';
import CoordinadorReportes from './pages/coordinador/ReportesPage';
import CoordinadorAltas from './pages/coordinador/AltasPage';
import CoordinadorConfiguracion from './pages/coordinador/ConfiguracionPage';

function App() {
  return (
    <Router>
      <AuthProvider>
        {/* Agrega los modales aquí */}
        <ConfirmModal />
        <NotificationModal />
        
        <Routes>
          <Route path="/login" element={<Login />} />
          
          {/* Rutas de Becario */}
          <Route path="/" element={<RoleRouter />}>
            <Route index element={<BecarioDashboard />} />
            
            {/* Becario */}
            <Route path="becario/dashboard" element={<BecarioDashboard />} />
            <Route path="becario/citas" element={<BecarioCitas />} />
            <Route path="becario/pacientes" element={<BecarioPacientes />} />
            <Route path="becario/notificaciones" element={<BecarioNotificaciones />} />
            <Route path="becario/observaciones" element={<BecarioObservaciones />} />
            
            {/* Psicólogo */}
            <Route path="psicologo/dashboard" element={<PsicologoDashboard />} />
            <Route path="psicologo/pacientes" element={<PsicologoPacientes />} />
            <Route path="psicologo/citas" element={<PsicologoCitas />} />
            <Route path="psicologo/expedientes" element={<PsicologoExpedientes />} />
            <Route path="psicologo/sesiones" element={<PsicologoSesiones />} />
            <Route path="psicologo/supervision" element={<PsicologoSupervision />} />
            
            {/* Coordinador */}
            <Route path="coordinador/dashboard" element={<CoordinadorDashboard />} />
            <Route path="coordinador/usuarios" element={<CoordinadorUsuarios />} />
            <Route path="coordinador/pacientes" element={<CoordinadorPacientes />} />
            <Route path="coordinador/asignaciones" element={<CoordinadorAsignaciones />} />
            <Route path="coordinador/agenda" element={<CoordinadorAgenda />} />
            <Route path="coordinador/reportes" element={<CoordinadorReportes />} />
            <Route path="coordinador/altas" element={<CoordinadorAltas />} />
            <Route path="coordinador/configuracion" element={<CoordinadorConfiguracion />} />
          </Route>
          
          {/* Redirección por defecto */}
          <Route path="*" element={<Navigate to="/" />} />
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;


/backend/src/services/reporteService.js:
--------------------------------------------------------------------------------
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');

class ReporteService {
    
    static async generarExcel(datos, tipoReporte) {
        try {
            const workbook = new ExcelJS.Workbook();
            workbook.creator = 'Sistema de Gestión Psicológica';
            workbook.created = new Date();
            
            let worksheet;
            let columns = [];
            
            switch (tipoReporte) {
                case 'citas':
                    worksheet = workbook.addWorksheet('Reporte de Citas');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'MODALIDAD', key: 'MODALIDAD', width: 15 },
                        { header: 'Empleado', key: 'Empleado', width: 20 },
                        { header: 'ESTUDIANTE', key: 'ESTUDIANTE', width: 25 },
                        { header: 'CARRERA', key: 'CARRERA', width: 20 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'EDAD', key: 'EDAD', width: 8 },
                        { header: 'SEXO', key: 'SEXO', width: 10 },
                        { header: 'MOTIVO DE CONSULTA', key: 'MOTIVO_DE_CONSULTA', width: 30 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'CORREO', key: 'CORREO', width: 25 },
                        { header: 'DIA', key: 'DIA', width: 12 },
                        { header: 'HORA', key: 'HORA', width: 10 },
                        { header: 'ESTATUS', key: 'ESTATUS', width: 12 },
                        { header: 'PRACTICANTE', key: 'PRACTICANTE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 },
                        { header: 'ATIENDE', key: 'ATIENDE', width: 20 }
                    ];
                    break;
                    
                case 'pacientes':
                    worksheet = workbook.addWorksheet('Reporte de Pacientes');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'CUATRI', key: 'CUATRI', width: 10 },
                        { header: 'TIPO DE SERVICIO', key: 'TIPO_DE_SERVICIO', width: 20 },
                        { header: 'FECHA DE PRESENTACION', key: 'FECHA_DE_PRESENTACION', width: 20 },
                        { header: 'No. de sesiones terapéuticas personales', key: 'No_de_sesiones_terapeuticas_personales', width: 15 },
                        { header: 'FECHA DE ACEPTACION', key: 'FECHA_DE_ACEPTACION', width: 20 },
                        { header: 'MMPI-2 RF', key: 'MMPI_2_RF', width: 15 },
                        { header: 'FECHA DE TERMINO', key: 'FECHA_DE_TERMINO', width: 20 },
                        { header: 'CARTA DE LIBERACION', key: 'CARTA_DE_LIBERACION', width: 20 },
                        { header: 'HORAS OBJETIVO', key: 'HORAS_OBJETIVO', width: 15 },
                        { header: 'HORAS REALIZADAS', key: 'HORAS_REALIZADAS', width: 15 },
                        { header: 'HORAS FALTANTES', key: 'HORAS_FALTANTES', width: 15 },
                        { header: 'SERVICIO COMUNITARIO LIBERADO', key: 'SERVICIO_COMUNITARIO_LIBERADO', width: 20 },
                        { header: 'QUIEN ATIENDE', key: 'QUIEN_ATIENDE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 }
                    ];
                    break;
                    
                default:
                    worksheet = workbook.addWorksheet('Reporte');
                    columns = Object.keys(datos[0] || {}).map(key => ({
                        header: key.toUpperCase(),
                        key: key,
                        width: 20
                    }));
            }
            
            worksheet.columns = columns;
            
            // Agregar datos
            if (datos && datos.length > 0) {
                datos.forEach(row => {
                    worksheet.addRow(row);
                });
            }
            
            // Aplicar estilos a la cabecera
            worksheet.getRow(1).font = { bold: true };
            worksheet.getRow(1).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFE0E0E0' }
            };
            
            // Autoajustar columnas
            worksheet.columns.forEach(column => {
                let maxLength = 0;
                column.eachCell({ includeEmpty: true }, cell => {
                    const cellLength = cell.value ? cell.value.toString().length : 0;
                    if (cellLength > maxLength) {
                        maxLength = cellLength;
                    }
                });
                column.width = Math.min(maxLength + 2, 50);
            });
            
            // Generar buffer
            const buffer = await workbook.xlsx.writeBuffer();
            return buffer;
            
        } catch (error) {
            console.error('Error en generarExcel:', error);
            throw error;
        }
    }
    
    static async generarPDF(datos, tipoReporte, titulo) {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({ margin: 50 });
                const chunks = [];
                
                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => {
                    const buffer = Buffer.concat(chunks);
                    resolve(buffer);
                });
                
                // Encabezado
                doc.fontSize(20).text(titulo || 'Reporte del Sistema', { align: 'center' });
                doc.moveDown();
                doc.fontSize(12).text(`Generado: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, { align: 'center' });
                doc.moveDown(2);
                
                // Contenido según tipo de reporte
                switch (tipoReporte) {
                    case 'resumen':
                        this.generarPDFResumen(doc, datos);
                        break;
                    case 'paciente':
                        this.generarPDFPaciente(doc, datos);
                        break;
                    default:
                        this.generarPDFTabla(doc, datos);
                }
                
                doc.end();
                
            } catch (error) {
                reject(error);
            }
        });
    }
    
    static generarPDFResumen(doc, datos) {
        doc.fontSize(16).text('Resumen Estadístico', { underline: true });
        doc.moveDown();
        
        if (datos.estadisticas) {
            const stats = datos.estadisticas;
            doc.fontSize(12);
            doc.text(`Total de Pacientes: ${stats.total_pacientes || 0}`);
            doc.text(`Pacientes Activos: ${stats.pacientes_activos || 0}`);
            doc.text(`Citas del Mes: ${stats.total_citas_mes || 0}`);
            doc.text(`Citas Completadas: ${stats.citas_completadas || 0}`);
            doc.text(`Tasa de Completitud: ${stats.tasa_completitud || '0'}%`);
            doc.moveDown();
        }
        
        if (datos.evolucion_mensual && datos.evolucion_mensual.length > 0) {
            doc.fontSize(14).text('Evolución Mensual:', { underline: true });
            doc.moveDown();
            
            datos.evolucion_mensual.forEach(item => {
                doc.fontSize(10).text(`${item.mes}: ${item.total_citas} citas (${item.citas_completadas} completadas)`);
            });
        }
    }
    
    static generarPDFPaciente(doc, datos) {
        doc.fontSize(16).text(`Expediente de ${datos.paciente?.nombre || ''} ${datos.paciente?.apellido || ''}`, { underline: true });
        doc.moveDown();
        
        // Información básica
        doc.fontSize(12).text('Información Básica:', { underline: true });
        doc.fontSize(10);
        if (datos.paciente) {
            doc.text(`Nombre: ${datos.paciente.nombre} ${datos.paciente.apellido}`);
            doc.text(`Teléfono: ${datos.paciente.telefono || 'No especificado'}`);
            doc.text(`Email: ${datos.paciente.email || 'No especificado'}`);
            doc.text(`Fecha de Nacimiento: ${datos.paciente.fecha_nacimiento || 'No especificado'}`);
        }
        doc.moveDown();
        
        // Historial de sesiones
        if (datos.sesiones && datos.sesiones.length > 0) {
            doc.fontSize(12).text('Historial de Sesiones:', { underline: true });
            doc.moveDown();
            
            datos.sesiones.forEach((sesion, index) => {
                doc.fontSize(10).text(`${index + 1}. ${sesion.fecha} - ${sesion.psicologo_nombre}`);
                if (sesion.conclusion) {
                    doc.fontSize(8).text(`   Conclusiones: ${sesion.conclusion.substring(0, 100)}...`);
                }
                doc.moveDown(0.5);
            });
        }
    }
    
    static generarPDFTabla(doc, datos) {
        if (!datos || datos.length === 0) {
            doc.text('No hay datos para mostrar');
            return;
        }
        
        // Obtener columnas
        const columnas = Object.keys(datos[0]);
        const anchoColumna = 500 / columnas.length;
        
        // Encabezado de tabla
        doc.fontSize(10).font('Helvetica-Bold');
        let xPos = 50;
        
        columnas.forEach(columna => {
            doc.text(columna.toUpperCase(), xPos, doc.y, { width: anchoColumna });
            xPos += anchoColumna;
        });
        
        doc.moveDown();
        doc.font('Helvetica');
        
        // Línea separadora
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown();
        
        // Filas de datos
        datos.forEach(fila => {
            xPos = 50;
            columnas.forEach(columna => {
                const valor = fila[columna] !== null && fila[columna] !== undefined ? 
                            fila[columna].toString() : '';
                doc.fontSize(8).text(valor.substring(0, 30), xPos, doc.y, { width: anchoColumna });
                xPos += anchoColumna;
            });
            doc.moveDown();
        });
    }
    
    static async generarCSV(datos, delimitador = ',') {
        if (!datos || datos.length === 0) {
            return '';
        }
        
        const columnas = Object.keys(datos[0]);
        let csv = columnas.join(delimitador) + '\n';
        
        datos.forEach(fila => {
            const valores = columnas.map(columna => {
                const valor = fila[columna];
                if (valor === null || valor === undefined) {
                    return '';
                }
                // Escapar comillas y delimitadores
                const valorStr = valor.toString();
                if (valorStr.includes(delimitador) || valorStr.includes('"') || valorStr.includes('\n')) {
                    return `"${valorStr.replace(/"/g, '""')}"`;
                }
                return valorStr;
            });
            csv += valores.join(delimitador) + '\n';
        });
        
        return csv;
    }
    
    static async guardarReporteArchivo(buffer, formato, nombreBase) {
        try {
            const timestamp = new Date().getTime();
            const nombreArchivo = `${nombreBase}_${timestamp}.${formato}`;
            const rutaArchivo = path.join(__dirname, '..', '..', 'reports', nombreArchivo);
            
            // Crear directorio si no existe
            await fs.mkdir(path.dirname(rutaArchivo), { recursive: true });
            
            // Guardar archivo
            await fs.writeFile(rutaArchivo, buffer);
            
            return {
                nombre: nombreArchivo,
                ruta: `/reports/${nombreArchivo}`,
                tamano: buffer.length
            };
            
        } catch (error) {
            console.error('Error al guardar reporte:', error);
            throw error;
        }
    }
    
    static async eliminarReporteAntiguos(dias = 30) {
        try {
            const directorio = path.join(__dirname, '..', '..', 'reports');
            const fechaLimite = new Date(Date.now() - dias * 24 * 60 * 60 * 1000);
            
            const archivos = await fs.readdir(directorio);
            
            for (const archivo of archivos) {
                const rutaArchivo = path.join(directorio, archivo);
                const stats = await fs.stat(rutaArchivo);
                
                if (stats.mtime < fechaLimite) {
                    await fs.unlink(rutaArchivo);
                    console.log(`Eliminado archivo antiguo: ${archivo}`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('Error al eliminar reportes antiguos:', error);
            return false;
        }
    }
}

module.exports = ReporteService;


/backend/src/services/estadisticaService.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class EstadisticaService {
    
    static async calcularEstadisticasGenerales(periodo = 'mes') {
        try {
            let intervalo;
            switch (periodo) {
                case 'semana':
                    intervalo = 'INTERVAL 7 DAY';
                    break;
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                case 'año':
                    intervalo = 'INTERVAL 365 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    (SELECT COUNT(*) FROM pacientes WHERE created_at >= DATE_SUB(CURDATE(), ${intervalo})) as nuevos_pacientes,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = FALSE) as pacientes_inactivos,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as total_citas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') as citas_completadas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'cancelada') as citas_canceladas,
                    
                    -- Tasa de asistencia
                    ROUND(
                        (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') * 100.0 / 
                        NULLIF((SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado IN ('programada', 'confirmada', 'completada')), 0),
                        2
                    ) as tasa_asistencia,
                    
                    -- Profesionales
                    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                    
                    -- Sesiones registradas
                    (SELECT COUNT(*) FROM sesiones s 
                     JOIN citas c ON s.cita_id = c.id 
                     WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})) as sesiones_registradas,
                    
                    -- Altas
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})) as altas_realizadas,
                    
                    -- Observaciones
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as observaciones_realizadas
            `, { type: QueryTypes.SELECT });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasGenerales:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasPsicologo(psicologoId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                    
                    -- Tiempo
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                    SUM(c.duracion_minutos) / 60.0 as horas_total,
                    
                    -- Sesiones registradas
                    COUNT(s.id) as sesiones_registradas,
                    
                    -- Observaciones
                    COUNT(ob.id) as observaciones_realizadas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion_observaciones,
                    
                    -- Altas
                    COUNT(al.id) as altas_realizadas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
                LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id
                    AND ob.fecha BETWEEN ? AND ?
                LEFT JOIN altas al ON u.id = al.usuario_id
                    AND al.fecha_alta BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [fechaInicio, fechaFin, fechaInicio, fechaFin, fechaInicio, fechaFin, psicologoId],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasPsicologo:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasBecario(becarioId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    
                    -- Observaciones recibidas
                    COUNT(ob.id) as observaciones_recibidas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    
                    -- Tiempo entre citas
                    ROUND(AVG(
                        DATEDIFF(
                            (SELECT MIN(c2.fecha) FROM citas c2 
                             WHERE c2.becario_id = c.becario_id 
                             AND c2.paciente_id = c.paciente_id 
                             AND c2.id > c.id),
                            c.fecha
                        )
                    ), 1) as dias_promedio_entre_citas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.becario_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                    AND ob.fecha BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [becarioId, fechaInicio, fechaFin, fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasBecario:', error);
            throw error;
        }
    }
    
    static async calcularTendenciasMensuales(meses = 6) {
        try {
            const tendencias = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha, '%Y-%m') as mes,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    (SELECT COUNT(*) FROM altas WHERE DATE_FORMAT(fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')) as altas_realizadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL ? MONTH)
                GROUP BY DATE_FORMAT(fecha, '%Y-%m')
                ORDER BY mes
            `, {
                replacements: [meses],
                type: QueryTypes.SELECT
            });
            
            return tendencias;
            
        } catch (error) {
            console.error('Error en calcularTendenciasMensuales:', error);
            throw error;
        }
    }
    
    static async calcularDistribucionPorGenero() {
        try {
            const distribucion = await sequelize.query(`
                SELECT 
                    COALESCE(genero, 'no especificado') as genero,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM pacientes
                WHERE activo = TRUE
                GROUP BY genero
                ORDER BY cantidad DESC
            `, { type: QueryTypes.SELECT });
            
            return distribucion;
            
        } catch (error) {
            console.error('Error en calcularDistribucionPorGenero:', error);
            throw error;
        }
    }
    
    static async calcularHorariosMasProductivos() {
        try {
            const horarios = await sequelize.query(`
                SELECT 
                    HOUR(hora) as hora,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud,
                    ROUND(AVG(duracion_minutos), 1) as duracion_promedio
                FROM citas
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
                GROUP BY HOUR(hora)
                ORDER BY total_citas DESC
                LIMIT 8
            `, { type: QueryTypes.SELECT });
            
            return horarios;
            
        } catch (error) {
            console.error('Error en calcularHorariosMasProductivos:', error);
            throw error;
        }
    }
    
    static async calcularMetricasEficiencia() {
        try {
            const [metricas] = await sequelize.query(`
                SELECT 
                    -- Tiempo promedio entre primera y última cita por paciente
                    ROUND(AVG(DATEDIFF(
                        ultima_cita.ultima,
                        primera_cita.primera
                    )), 1) as dias_tratamiento_promedio,
                    
                    -- Citas promedio por paciente
                    ROUND(AVG(total_citas.total), 1) as citas_promedio_por_paciente,
                    
                    -- Tasa de retención (pacientes con más de 1 cita)
                    ROUND(
                        COUNT(DISTINCT CASE WHEN total_citas.total > 1 THEN total_citas.paciente_id END) * 100.0 / 
                        COUNT(DISTINCT total_citas.paciente_id),
                        2
                    ) as tasa_retencion,
                    
                    -- Tiempo promedio para primera cita después del registro
                    ROUND(AVG(DATEDIFF(
                        primera_cita.primera,
                        p.created_at
                    )), 1) as dias_para_primera_cita
                    
                FROM pacientes p
                LEFT JOIN (
                    SELECT paciente_id, MIN(fecha) as primera
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) primera_cita ON p.id = primera_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, MAX(fecha) as ultima
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) ultima_cita ON p.id = ultima_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, COUNT(*) as total
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) total_citas ON p.id = total_citas.paciente_id
                WHERE p.activo = TRUE
            `, { type: QueryTypes.SELECT });
            
            return metricas;
            
        } catch (error) {
            console.error('Error en calcularMetricasEficiencia:', error);
            throw error;
        }
    }
    
    static async calcularSatisfaccionBecarios() {
        try {
            const satisfaccion = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    COUNT(ob.id) as total_observaciones,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    ROUND(STDDEV(ob.calificacion), 2) as desviacion_estandar,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    COUNT(DISTINCT ob.aspecto_evaluado) as aspectos_evaluados,
                    (SELECT CONCAT(sup.nombre, ' ', sup.apellido) 
                     FROM asignaciones a 
                     JOIN users sup ON a.psicologo_id = sup.id 
                     WHERE a.becario_id = u.id AND a.estado = 'activa' LIMIT 1) as supervisor
                FROM users u
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                WHERE u.rol = 'becario' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY promedio_calificacion DESC
            `, { type: QueryTypes.SELECT });
            
            return satisfaccion;
            
        } catch (error) {
            console.error('Error en calcularSatisfaccionBecarios:', error);
            throw error;
        }
    }
    
    static async predecirDemanda(fechaInicio, fechaFin) {
        try {
            // Análisis histórico para predecir demanda
            const prediccion = await sequelize.query(`
                SELECT 
                    -- Por día de la semana
                    DAYNAME(fecha) as dia_semana,
                    COUNT(*) as historico_total,
                    ROUND(AVG(COUNT(*)) OVER(), 0) as promedio_diario,
                    
                    -- Por hora
                    HOUR(hora) as hora_dia,
                    COUNT(*) as citas_por_hora,
                    
                    -- Por psicólogo
                    psicologo_id,
                    COUNT(*) as citas_psicologo
                    
                FROM citas
                WHERE fecha BETWEEN ? AND ?
                AND estado IN ('programada', 'confirmada', 'completada')
                GROUP BY DAYNAME(fecha), HOUR(hora), psicologo_id
                ORDER BY dia_semana, hora_dia
            `, {
                replacements: [fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return prediccion;
            
        } catch (error) {
            console.error('Error en predecirDemanda:', error);
            throw error;
        }
    }
    
    static async generarReporteComparativo(periodo, tipoComparacion) {
        try {
            let query;
            
            switch (tipoComparacion) {
                case 'psicologos':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'psicologo' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.psicologo_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'psicologo' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                case 'becarios':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'becario' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.becario_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                            AND ob.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'becario' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                default:
                    throw new Error('Tipo de comparación no válido');
            }
            
            const resultados = await sequelize.query(query, {
                replacements: [periodo, periodo],
                type: QueryTypes.SELECT
            });
            
            return resultados;
            
        } catch (error) {
            console.error('Error en generarReporteComparativo:', error);
            throw error;
        }
    }
}

module.exports = EstadisticaService;


/backend/src/routes/reporteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ReporteController = require('../controllers/reporteController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticación
router.use(verifyToken);

// Generar reportes
router.get('/mensual', requireRole(['coordinador', 'psicologo']), ReporteController.generarReporteMensual);
router.post('/paciente', requireRole(['coordinador', 'psicologo']), ReporteController.generarReportePaciente);
router.get('/excel', requireRole(['coordinador']), ReporteController.generarReporteExcel);

// Obtener reportes generados
router.get('/mis-reportes', ReporteController.obtenerMisReportes);
router.get('/descargar/:id', ReporteController.descargarReporte);

module.exports = router;


================================================================================
RESUMEN PARA COORDINADOR_REPORTES:
----------------------------------------
Archivos necesarios: 11
Archivos encontrados: 11
Archivos no encontrados: 0

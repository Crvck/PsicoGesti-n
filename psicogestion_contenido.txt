

/.env:
--------------------------------------------------------------------------------
NODE_ENV=development
PORT=3000

# Database MySQL
DB_HOST=localhost
DB_PORT=3306
DB_NAME=psicogestion_db
DB_USER=psicogestion_user
DB_PASSWORD=SecurePass123!

# JWT
JWT_SECRET=cesun
JWT_EXPIRES_IN=24h

# Bcrypt
BCRYPT_ROUNDS=12

# App
LOG_LEVEL=info

/codersito.py:
--------------------------------------------------------------------------------
import os
import json
from datetime import datetime

PAGINAS_ARCHIVOS = {
    "becario_dashboard": [
        "backend/src/controllers/dashboardController.js",
        "backend/src/routes/dashboardRoutes.js",
        "backend/src/models/userModel.js",
        "backend/src/models/citaModel.js",
        "backend/src/models/notificacionModel.js",
        "backend/src/services/estadisticaService.js",
        "backend/src/services/dashboardService.js",
        "frontend/src/services/dashboardService.js"
    ],
    "becario_citas": [
        "backend/src/controllers/citaController.js",
        "backend/src/routes/citaRoutes.js",
        "backend/src/models/citaModel.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/controllers/disponibilidadController.js",
        "backend/src/routes/disponibilidadRoutes.js"
    ],
    "becario_pacientes": [
        "backend/src/controllers/pacienteController.js",
        "backend/src/routes/pacienteRoutes.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/controllers/asignacionController.js",
        "backend/src/routes/asignacionRoutes.js"
    ],
    "becario_notificaciones": [
        "backend/src/controllers/notificacionController.js",
        "backend/src/routes/notificacionRoutes.js",
        "backend/src/models/notificacionModel.js"
    ],
    "becario_observaciones": [
        "backend/src/controllers/observacionController.js",
        "backend/src/routes/observacionRoutes.js",
        "backend/src/models/observacionBecarioModel.js",
        "backend/src/models/pacienteModel.js"
    ],
    "coordinador_dashboard": [
        "backend/src/controllers/dashboardController.js",
        "backend/src/routes/dashboardRoutes.js",
        "backend/src/models/userModel.js",
        "backend/src/models/citaModel.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/services/estadisticaService.js",
        "backend/src/services/dashboardService.js",
        "frontend/src/services/dashboardService.js"
    ],
    "coordinador_usuarios": [
        "backend/src/controllers/authController.js",
        "backend/src/routes/authRoutes.js",
        "backend/src/models/userModel.js",
        "backend/src/models/permisoModel.js"
    ],
    "coordinador_pacientes": [
        "backend/src/controllers/pacienteController.js",
        "backend/src/routes/pacienteRoutes.js",
        "backend/src/models/pacienteModel.js"
    ],
    "coordinador_asignaciones": [
        "backend/src/controllers/asignacionController.js",
        "backend/src/routes/asignacionRoutes.js",
        "backend/src/models/asignacionModel.js",
        "backend/src/models/userModel.js",
        "backend/src/models/pacienteModel.js"
    ],
    "coordinador_agenda": [
        "backend/src/controllers/agendaController.js",
        "backend/src/routes/agendaRoutes.js",
        "backend/src/models/citaModel.js",
        "backend/src/models/userModel.js",
        "backend/src/services/calendarioService.js"
    ],
    "coordinador_reportes": [
        "backend/src/controllers/reporteController.js",
        "backend/src/routes/reporteRoutes.js",
        "backend/src/models/reporteModel.js",
        "backend/src/services/reporteService.js",
        "backend/src/services/estadisticaService.js"
    ],
    "coordinador_altas": [
        "backend/src/controllers/altaController.js",
        "backend/src/routes/altaRoutes.js",
        "backend/src/models/altaModel.js",
        "backend/src/models/pacienteModel.js"
    ],
    "coordinador_configuracion": [
        "backend/src/controllers/configuracionController.js",
        "backend/src/routes/configuracionRoutes.js",
        "backend/src/services/backupService.js",
        "backend/src/models/logSistemaModel.js"
    ],
    "psicologo_dashboard": [
        "backend/src/controllers/dashboardController.js",
        "backend/src/routes/dashboardRoutes.js",
        "backend/src/models/citaModel.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/models/userModel.js",
        "backend/src/services/dashboardService.js",
        "frontend/src/services/dashboardService.js"
    ],
    "psicologo_pacientes": [
        "backend/src/controllers/pacienteController.js",
        "backend/src/routes/pacienteRoutes.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/models/expedienteModel.js"
    ],
    "psicologo_citas": [
        "backend/src/controllers/citaController.js",
        "backend/src/routes/citaRoutes.js",
        "backend/src/models/citaModel.js",
        "backend/src/controllers/disponibilidadController.js",
        "backend/src/routes/disponibilidadRoutes.js"
    ],
    "psicologo_expedientes": [
        "backend/src/controllers/expedienteController.js",
        "backend/src/routes/expedienteRoutes.js",
        "backend/src/models/expedienteModel.js",
        "backend/src/models/pacienteModel.js",
        "backend/src/models/sesionModel.js"
    ],
    "psicologo_sesiones": [
        "backend/src/controllers/sesionController.js",
        "backend/src/routes/sesionRoutes.js",
        "backend/src/models/sesionModel.js",
        "backend/src/models/pacienteModel.js"
    ],
    "psicologo_supervision": [
        "backend/src/controllers/supervisionController.js",
        "backend/src/routes/supervisionRoutes.js",
        "backend/src/models/observacionBecarioModel.js",
        "backend/src/models/userModel.js"
    ]
}

ARCHIVOS_BASE = [
    "backend/server.js",
    "backend/src/db/db.sql",
    "backend/src/services/api.js",
    "frontend/src/App.js",
    "frontend/src/index.js",
    "frontend/src/services/api.js",
    "frontend/src/global.css"
]

def generar_txt_por_pagina(directorio_base, output_dir="paginas_backend"):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    for pagina, archivos_necesarios in PAGINAS_ARCHIVOS.items():
        todos_archivos = list(set(archivos_necesarios + ARCHIVOS_BASE))
        nombre_archivo = f"{pagina}_backend.txt"
        ruta_completa = os.path.join(output_dir, nombre_archivo)
        
        print(f"Generando {nombre_archivo}...")
        
        with open(ruta_completa, 'w', encoding='utf-8') as out_file:
            out_file.write(f"ARCHIVOS BACKEND PARA: {pagina.upper()}\n")
            out_file.write("=" * 80 + "\n")
            out_file.write(f"Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            out_file.write("=" * 80 + "\n\n")
            
            archivos_encontrados = 0
            archivos_no_encontrados = []
            
            for archivo_relativo in todos_archivos:
                ruta_absoluta = os.path.join(directorio_base, archivo_relativo)
                
                out_file.write(f"/{archivo_relativo}:\n")
                out_file.write("-" * 80 + "\n")
                
                if os.path.exists(ruta_absoluta):
                    try:
                        with open(ruta_absoluta, 'r', encoding='utf-8') as in_file:
                            contenido = in_file.read()
                        out_file.write(contenido + "\n")
                        archivos_encontrados += 1
                    except Exception as e:
                        out_file.write(f"Error al leer archivo: {str(e)}\n")
                        archivos_no_encontrados.append(archivo_relativo)
                else:
                    out_file.write("ARCHIVO NO ENCONTRADO\n")
                    archivos_no_encontrados.append(archivo_relativo)
                
                out_file.write("\n\n")
            
            out_file.write("=" * 80 + "\n")
            out_file.write(f"RESUMEN PARA {pagina.upper()}:\n")
            out_file.write("-" * 40 + "\n")
            out_file.write(f"Archivos necesarios: {len(todos_archivos)}\n")
            out_file.write(f"Archivos encontrados: {archivos_encontrados}\n")
            out_file.write(f"Archivos no encontrados: {len(archivos_no_encontrados)}\n")
            
            if archivos_no_encontrados:
                out_file.write("\nArchivos faltantes:\n")
                for archivo in archivos_no_encontrados:
                    out_file.write(f"  - {archivo}\n")
    
    print(f"\nProceso completado. Archivos generados en: {output_dir}/")

def generar_archivo_contenido(directorio_base, archivo_salida, modo_manual=False, 
                             archivos_manual=None, omitir=None, omitir_extensiones=None, 
                             omitir_directorios=None):
    
    if omitir is None:
        omitir = []
    if omitir_extensiones is None:
        omitir_extensiones = []
    if omitir_directorios is None:
        omitir_directorios = []
    if archivos_manual is None:
        archivos_manual = ['.py', '.json']
    
    archivo_rutas = archivo_salida.replace('_contenido.txt', '_rutas.txt')
    
    with open(archivo_salida, 'w', encoding='utf-8') as out_file, \
         open(archivo_rutas, 'w', encoding='utf-8') as rutas_file:
        
        rutas_file.write("MAPAS DE CARPETAS Y ARCHIVOS\n")
        rutas_file.write("=" * 80 + "\n\n")
        
        for root, dirs, files in os.walk(directorio_base):
            dirs[:] = [d for d in dirs if d not in omitir_directorios]
            
            ruta_relativa = os.path.relpath(root, directorio_base)
            ruta_mostrar = ruta_relativa if ruta_relativa != '.' else ''
            ruta_completa = os.path.join(directorio_base, ruta_relativa)
            
            if ruta_mostrar:
                rutas_file.write(f"{ruta_completa}/\n")
            else:
                rutas_file.write(f"{directorio_base}/\n")
            
            archivos_incluidos = []
            
            for file in files:
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, directorio_base)
                ruta_archivo_completa = os.path.join(directorio_base, rel_path)
                
                incluir_archivo = False
                
                if modo_manual:
                    if any(file.endswith(ext) for ext in archivos_manual):
                        if file not in omitir and not any(file.endswith(ext) for ext in omitir_extensiones):
                            incluir_archivo = True
                else:
                    if file.endswith(('.py', '.json')):
                        if file not in omitir and not any(file.endswith(ext) for ext in omitir_extensiones):
                            incluir_archivo = True
                
                if incluir_archivo:
                    archivos_incluidos.append(file)
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8') as in_file:
                            contenido = in_file.read()
                        out_file.write(f"\n\n/{rel_path}:\n")
                        out_file.write("-" * 80 + "\n")
                        out_file.write(contenido)
                    except Exception as e:
                        out_file.write(f"\n\nError al leer {rel_path}: {str(e)}\n")
                
                if file not in omitir and not any(file.endswith(ext) for ext in omitir_extensiones):
                    rutas_file.write(f"  {ruta_archivo_completa}\n")
            
            if not archivos_incluidos:
                rutas_file.write("  (sin archivos incluidos)\n")
            
            rutas_file.write("\n")

if __name__ == "__main__":
    DIRECTORIO_BASE = os.path.dirname(os.path.abspath(__file__))
    OUTPUT_DIR = "paginas_backend"
    
    print("=" * 80)
    print("GENERADOR DE ARCHIVOS TXT POR P√ÅGINA")
    print("=" * 80)
    print(f"Directorio base: {DIRECTORIO_BASE}")
    print(f"Total de p√°ginas: {len(PAGINAS_ARCHIVOS)}")
    print()
    
    print("1. Generando archivos TXT por p√°gina...")
    generar_txt_por_pagina(DIRECTORIO_BASE, output_dir=OUTPUT_DIR)
    
    print("\n2. Generando archivos generales...")
    
    MODO_MANUAL = True
    ARCHIVO_CONTENIDO = "psicogestion_contenido.txt"
    ARCHIVO_RUTAS = "psicogestion_rutas.txt"
    
    ARCHIVOS_MANUAL = ['.py', '.json', '.yaml', '.yml','.env', '.js', '.jsx', '.sql', '.css']
    
    ARCHIVOS_A_OMITIR = ["instruments.json", "coder.py", "package-lock.json"]
    EXTENSIONES_A_OMITIR = ['.log', '.pyc', '.tmp', '.bak']
    DIRECTORIOS_A_OMITIR = ['__pycache__', 'logs', '.git', 'venv', 'env', '.idea', 
                           '.vscode', 'node_modules', 'images', 'scripts', OUTPUT_DIR]
    
    try:
        print(f"Generando {ARCHIVO_CONTENIDO}...")
        generar_archivo_contenido(
            DIRECTORIO_BASE, 
            ARCHIVO_CONTENIDO,
            modo_manual=MODO_MANUAL,
            archivos_manual=ARCHIVOS_MANUAL,
            omitir=ARCHIVOS_A_OMITIR,
            omitir_extensiones=EXTENSIONES_A_OMITIR,
            omitir_directorios=DIRECTORIOS_A_OMITIR
        )
        print(f"‚úì {ARCHIVO_CONTENIDO} generado")
        print(f"‚úì {ARCHIVO_RUTAS} generado")
    except Exception as e:
        print(f"‚úó Error: {e}")
    
    print("\n" + "=" * 80)
    print("¬°PROCESO COMPLETADO!")
    print("=" * 80)
    
    archivos_paginas = [f for f in os.listdir(OUTPUT_DIR) if f.endswith("_backend.txt")] if os.path.exists(OUTPUT_DIR) else []
    
    print(f"\nArchivos generados en '{OUTPUT_DIR}/':")
    print("-" * 40)
    
    grupos = {
        "BECARIO": [f for f in archivos_paginas if f.startswith("becario_")],
        "COORDINADOR": [f for f in archivos_paginas if f.startswith("coordinador_")],
        "PSIC√ìLOGO": [f for f in archivos_paginas if f.startswith("psicologo_")]
    }
    
    for grupo, archivos in grupos.items():
        if archivos:
            print(f"\n{grupo}:")
            for archivo in sorted(archivos):
                print(f"  ‚Ä¢ {archivo}")
    
    print(f"\nArchivos generales:")
    print(f"  ‚Ä¢ {ARCHIVO_CONTENIDO}")
    print(f"  ‚Ä¢ {ARCHIVO_RUTAS}")

/package.json:
--------------------------------------------------------------------------------
{
  "name": "psico-gestion-root",
  "private": true,
  "version": "1.0.0",
  "description": "Sistema de Gesti√≥n de Consultorio Psicol√≥gico",
  "workspaces": [
    "backend",
    "frontend"
  ],
  "scripts": {
    "start": "npm run start:backend",
    "dev": "npm run dev:backend",
    "dev:all": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:backend": "cd backend && npm run dev",
    "dev:frontend": "cd frontend && npm run dev",
    "start:backend": "cd backend && npm start",
    "start:frontend": "cd frontend && npm start",
    "install:all": "npm install && cd backend && npm install && cd ../frontend && npm install",
    "install:backend": "cd backend && npm install",
    "install:frontend": "cd frontend && npm install",
    "clean:all": "rm -rf node_modules backend/node_modules frontend/node_modules",
    "build:frontend": "cd frontend && npm run build",
    "test:all": "cd backend && npm test && cd ../frontend && npm test"
  },
  "devDependencies": {
    "concurrently": "^8.0.0"
  },
  "keywords": [
    "psicologia",
    "gestion",
    "consultorio",
    "pacientes",
    "citas"
  ],
  "author": "Cesun Universidad",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}

/backend\package.json:
--------------------------------------------------------------------------------
{
  "name": "psico-gestion-backend",
  "version": "1.0.0",
  "description": "Backend API para sistema de gesti√≥n psicol√≥gica",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"No tests yet\""
  },
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "exceljs": "^4.4.0",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "googleapis": "^128.0.0",
    "jsonwebtoken": "^9.0.3",
    "mysql2": "^3.15.3",
    "json2csv": "^5.0.0",
    "nodemailer": "^6.9.7",
    "pdfkit": "^0.14.0",
    "sequelize": "^6.37.7",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  }
}

/backend\server.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerDocument = require('./src/doc/swagger.json');
const cors = require('cors');

const sequelize = require('./src/config/db');

// Importar modelos
require('./src/models/userModel');
require('./src/models/pacienteModel');
require('./src/models/citaModel');
// Importar otros modelos seg√∫n necesites

const authRoutes = require('./src/routes/authRoutes');
const citaRoutes = require('./src/routes/citaRoutes');
const roleRoutes = require('./src/routes/roleRoutes');
const fundacionRoutes = require('./src/routes/fundacionRoutes');
const asignacionRoutes = require('./src/routes/asignacionRoutes');
const sesionRoutes = require('./src/routes/sesionRoutes');
const notificacionRoutes = require('./src/routes/notificacionRoutes');
const altaRoutes = require('./src/routes/altaRoutes');
const reporteRoutes = require('./src/routes/reporteRoutes');
const observacionRoutes = require('./src/routes/observacionRoutes');
const disponibilidadRoutes = require('./src/routes/disponibilidadRoutes');
const expedienteRoutes = require('./src/routes/expedienteRoutes');
const dashboardRoutes = require('./src/routes/dashboardRoutes');
const agendaRoutes = require('./src/routes/agendaRoutes');
const estadisticaRoutes = require('./src/routes/estadisticaRoutes');
const pacienteRoutes = require('./src/routes/pacienteRoutes');
const app = express();
const PORT = process.env.PORT || 3000;



app.use(cors({
  origin: 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.get('/', (req, res) => {
  res.send('Server is running! Check /api-docs for documentation.');
});

app.use('/api/auth', authRoutes);
app.use('/api/citas', citaRoutes);
app.use('/api/fundaciones', fundacionRoutes);
app.use('/api/asignaciones', asignacionRoutes);
app.use('/api/sesiones', sesionRoutes);
app.use('/api/notificaciones', notificacionRoutes);
app.use('/api/altas', altaRoutes);
app.use('/api/reportes', reporteRoutes);
app.use('/api/observaciones', observacionRoutes);
app.use('/api/disponibilidad', disponibilidadRoutes);
app.use('/api/expedientes', expedienteRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/agenda', agendaRoutes);
app.use('/api/estadisticas', estadisticaRoutes);
const userRoutes = require('./src/routes/userRoutes');
app.use('/api/users', userRoutes);
app.use('/api/roles', roleRoutes);
app.use('/api/pacientes', pacienteRoutes);
// Sincronizar modelos
sequelize.sync({ force: false, alter: false })
    .then(() => {
        console.log("‚úÖ Tablas sincronizadas (base de datos lista)");
        app.listen(PORT, () => {
          console.log(`Backend running on http://localhost:${PORT}`);
          console.log(`Swagger docs: http://localhost:${PORT}/api-docs`);
          console.log(`CORS permitido para: http://localhost:3001`);
          console.log(`Endpoints disponibles:`);
          console.log(`  GET  /api/citas/citas-por-fecha?fecha=YYYY-MM-DD&becario_id=1`);
          console.log(`  GET  /api/citas/reporte-mensual?mes=1&anio=2024`);
          console.log(`  POST /api/citas/alta-paciente`);
          console.log(`  PUT  /api/citas/cita/:id`);
        });
    })
    .catch((error) => {
        console.error("‚ùå Error al sincronizar la base de datos:", error.message);
    });

/backend\src\config\db.js:
--------------------------------------------------------------------------------
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASSWORD,
    {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: 'mysql',
        logging: false,
        
        dialectOptions: {
            ssl: {
                require: true,
                rejectUnauthorized: false
            }
        },

        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000
        }
    }
);

async function testConnection() {
    try {
        await sequelize.authenticate();
        console.log('‚úÖ Conexi√≥n a base de datos establecida exitosamente.');
    } catch (error) {
        console.error('‚ùå No se pudo conectar a la base de datos:', error);
    }
}

testConnection();

module.exports = sequelize;

/backend\src\controllers\agendaController.js:
--------------------------------------------------------------------------------
// backend/src/controllers/agendaController.js - Versi√≥n simplificada sin verificaci√≥n de roles
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes, Op } = require('sequelize');
const sequelize = require('../config/db');

class AgendaController {

    static async obtenerAgendaGlobal(req, res) {
        try {
            const { 
                fecha_inicio, 
                fecha_fin, 
                psicologo_id, 
                becario_id, 
                paciente_id,
                estado,
                tipo_consulta,
                limit = 50,
                offset = 0
            } = req.query;
            
            // Construir condiciones de filtro
            const whereClause = {};
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [Op.between]: [fecha_inicio, fecha_fin]
                };
            } else if (fecha_inicio) {
                whereClause.fecha = { [Op.gte]: fecha_inicio };
            } else if (fecha_fin) {
                whereClause.fecha = { [Op.lte]: fecha_fin };
            } else {
                // Por defecto, mostrar solo citas futuras y de hoy
                whereClause.fecha = { [Op.gte]: new Date().toISOString().split('T')[0] };
            }
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (becario_id) whereClause.becario_id = becario_id;
            if (paciente_id) whereClause.paciente_id = paciente_id;
            if (estado) whereClause.estado = estado;
            if (tipo_consulta) whereClause.tipo_consulta = tipo_consulta;
            
            console.log('Where clause:', whereClause);
            
            const citas = await Cita.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['id', 'nombre', 'apellido', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [
                    ['fecha', 'ASC'],
                    ['hora', 'ASC']
                ],
                limit: parseInt(limit),
                offset: parseInt(offset)
            });
            
            console.log('Citas encontradas:', citas.length);
            
            // Incluir estad√≠sticas - consulta simplificada
            let estadisticas = null;
            try {
                // Construir condiciones WHERE para SQL
                let whereSQL = '1=1';
                const replacements = [];
                
                if (fecha_inicio && fecha_fin) {
                    whereSQL += ' AND fecha BETWEEN ? AND ?';
                    replacements.push(fecha_inicio, fecha_fin);
                } else if (fecha_inicio) {
                    whereSQL += ' AND fecha >= ?';
                    replacements.push(fecha_inicio);
                } else if (fecha_fin) {
                    whereSQL += ' AND fecha <= ?';
                    replacements.push(fecha_fin);
                }
                
                if (psicologo_id) {
                    whereSQL += ' AND psicologo_id = ?';
                    replacements.push(psicologo_id);
                }
                
                if (estado) {
                    whereSQL += ' AND estado = ?';
                    replacements.push(estado);
                }
                
                const query = `
                    SELECT 
                        COUNT(*) as total_citas,
                        SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                        SUM(CASE WHEN estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                        SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                        SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                        COUNT(DISTINCT psicologo_id) as psicologos_involucrados,
                        COUNT(DISTINCT becario_id) as becarios_involucrados,
                        COUNT(DISTINCT paciente_id) as pacientes_atendidos
                    FROM citas
                    WHERE ${whereSQL}
                `;
                
                const [stats] = await sequelize.query(query, {
                    replacements,
                    type: QueryTypes.SELECT
                });
                
                estadisticas = stats;
                console.log('Estad√≠sticas:', estadisticas);
                
            } catch (statsError) {
                console.error('Error al obtener estad√≠sticas:', statsError);
                // Continuar sin estad√≠sticas
                estadisticas = {
                    total_citas: citas.length,
                    programadas: citas.filter(c => c.estado === 'programada').length,
                    confirmadas: citas.filter(c => c.estado === 'confirmada').length,
                    completadas: citas.filter(c => c.estado === 'completada').length,
                    canceladas: citas.filter(c => c.estado === 'cancelada').length,
                    psicologos_involucrados: new Set(citas.map(c => c.psicologo_id)).size,
                    becarios_involucrados: new Set(citas.map(c => c.becario_id)).size - 1, // Restar null
                    pacientes_atendidos: new Set(citas.map(c => c.paciente_id)).size
                };
            }
            
            res.json({
                success: true,
                data: {
                    citas,
                    estadisticas,
                    filtros: {
                        fecha_inicio,
                        fecha_fin,
                        psicologo_id,
                        becario_id,
                        paciente_id,
                        estado,
                        tipo_consulta
                    }
                },
                count: citas.length
            });
            
        } catch (error) {
            console.error('Error detallado en obtenerAgendaGlobal:', error);
            console.error('Stack trace:', error.stack);
            res.status(500).json({
                success: false,
                message: 'Error al obtener agenda global',
                error: error.message,
                stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
            });
        }
    }
    
    static async obtenerAgendaDiaria(req, res) {
        try {
            const { fecha } = req.query;
            
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            
            const query = `
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    c.duracion as duracion_minutos,
                    c.notas,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario,
                    u_psi.especialidad as psicologo_especialidad
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.fecha = ?
                ORDER BY c.hora
            `;
            
            const replacements = [fechaConsulta];
            
            const citas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Obtener disponibilidad de profesionales para este d√≠a
            const diaSemana = this.obtenerDiaSemana(fechaConsulta);
            const [disponibilidad] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    GROUP_CONCAT(
                        CONCAT(
                            TIME_FORMAT(d.hora_inicio, '%H:%i'), 
                            ' - ', 
                            TIME_FORMAT(d.hora_fin, '%H:%i')
                        ) SEPARATOR ', '
                    ) as horarios_disponibles,
                    COUNT(DISTINCT c.id) as citas_programadas
                FROM users u
                LEFT JOIN disponibilidades d ON u.id = d.usuario_id 
                    AND d.dia_semana = ?
                    AND d.activo = TRUE
                LEFT JOIN citas c ON u.id = c.psicologo_id 
                    AND c.fecha = ?
                    AND c.estado IN ('programada', 'confirmada')
                WHERE u.rol IN ('psicologo', 'becario')
                AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido, u.rol
                ORDER BY u.rol, u.apellido, u.nombre
            `, {
                replacements: [diaSemana, fechaConsulta],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    fecha: fechaConsulta,
                    citas,
                    disponibilidad: disponibilidad || [],
                    total_citas: citas.length
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerAgendaDiaria:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener agenda diaria'
            });
        }
    }
    
    static async obtenerCalendarioMensual(req, res) {
        try {
            const { mes, anio } = req.query;
            
            const mesActual = mes || new Date().getMonth() + 1;
            const anioActual = anio || new Date().getFullYear();
            
            // Obtener citas del mes
            const query = `
                SELECT 
                    c.fecha,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                    SUM(CASE WHEN c.estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                    GROUP_CONCAT(
                        CONCAT(
                            TIME_FORMAT(c.hora, '%H:%i'), ' ', 
                            SUBSTRING(p.nombre, 1, 1), '. ', p.apellido
                        ) 
                        ORDER BY c.hora 
                        SEPARATOR '; '
                    ) as detalle_citas
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE MONTH(c.fecha) = ? AND YEAR(c.fecha) = ?
                GROUP BY c.fecha ORDER BY c.fecha
            `;
            
            const replacements = [mesActual, anioActual];
            
            const citasPorDia = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Crear calendario
            const diasMes = new Date(anioActual, mesActual, 0).getDate();
            const calendario = [];
            
            for (let dia = 1; dia <= diasMes; dia++) {
                const fecha = `${anioActual}-${mesActual.toString().padStart(2, '0')}-${dia.toString().padStart(2, '0')}`;
                const datosDia = citasPorDia.find(c => c.fecha === fecha);
                
                calendario.push({
                    fecha,
                    dia,
                    dia_semana: this.obtenerDiaSemana(fecha),
                    total_citas: datosDia ? datosDia.total_citas : 0,
                    programadas: datosDia ? datosDia.programadas : 0,
                    confirmadas: datosDia ? datosDia.confirmadas : 0,
                    completadas: datosDia ? datosDia.completadas : 0,
                    canceladas: datosDia ? datosDia.canceladas : 0,
                    detalle_citas: datosDia ? datosDia.detalle_citas : null
                });
            }
            
            // Estad√≠sticas del mes
            const [estadisticasMes] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_citas_mes,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(AVG(duracion), 1) as duracion_promedio
                FROM citas
                WHERE MONTH(fecha) = ? AND YEAR(fecha) = ?
            `, {
                replacements: [mesActual, anioActual],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    mes: mesActual,
                    anio: anioActual,
                    calendario,
                    estadisticas: estadisticasMes || {},
                    total_dias: diasMes
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerCalendarioMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener calendario mensual'
            });
        }
    }
    
    static async reprogramarCita(req, res) {
        try {
            const { id } = req.params;
            const { nueva_fecha, nueva_hora, motivo } = req.body;
            
            const cita = await Cita.findByPk(id);
            
            if (!cita) {
                return res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
            }
            
            // Verificar que la nueva fecha/hora no se solape
            const [solapamiento] = await sequelize.query(`
                SELECT id FROM citas 
                WHERE (
                    (psicologo_id = ? OR becario_id = ?)
                    AND fecha = ?
                    AND hora = ?
                    AND estado IN ('programada', 'confirmada')
                    AND id != ?
                )
            `, {
                replacements: [
                    cita.psicologo_id,
                    cita.becario_id || 0,
                    nueva_fecha,
                    nueva_hora,
                    id
                ],
                type: QueryTypes.SELECT
            });
            
            if (solapamiento) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe una cita programada en ese horario'
                });
            }
            
            // Guardar datos originales para log
            const datosOriginales = {
                fecha: cita.fecha,
                hora: cita.hora,
                estado: cita.estado
            };
            
            // Actualizar cita
            await cita.update({
                fecha: nueva_fecha,
                hora: nueva_hora,
                estado: 'programada',
                motivo_cancelacion: motivo ? `Reprogramaci√≥n: ${motivo}` : 'Reprogramaci√≥n'
            });
            
            // Crear notificaciones
            const [paciente] = await sequelize.query(
                'SELECT email, nombre, apellido FROM pacientes WHERE id = ?',
                { replacements: [cita.paciente_id], type: QueryTypes.SELECT }
            );
            
            // Notificar al psic√≥logo
            if (cita.psicologo_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'cita_modificada', 'Cita reprogramada', 
                    CONCAT('Cita reprogramada para el paciente: ', ?, '. Nueva fecha: ', ?, ' ', ?), NOW())
                `, {
                    replacements: [
                        cita.psicologo_id,
                        `${paciente?.nombre || 'Paciente'} ${paciente?.apellido || ''}`,
                        nueva_fecha,
                        nueva_hora
                    ]
                });
            }
            
            // Notificar al becario si est√° asignado
            if (cita.becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'cita_modificada', 'Cita reprogramada', 
                    CONCAT('Cita reprogramada para el paciente: ', ?, '. Nueva fecha: ', ?, ' ', ?), NOW())
                `, {
                    replacements: [
                        cita.becario_id,
                        `${paciente?.nombre || 'Paciente'} ${paciente?.apellido || ''}`,
                        nueva_fecha,
                        nueva_hora
                    ]
                });
            }
            
            res.json({
                success: true,
                message: 'Cita reprogramada exitosamente',
                data: {
                    cita_id: id,
                    fecha_anterior: datosOriginales.fecha,
                    hora_anterior: datosOriginales.hora,
                    nueva_fecha,
                    nueva_hora
                }
            });
            
        } catch (error) {
            console.error('Error en reprogramarCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al reprogramar cita'
            });
        }
    }
    
    

    static async obtenerDisponibilidadProfesionales(req, res) {
        try {
            const { fecha } = req.query;
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            
            
            // Funci√≥n auxiliar para obtener d√≠a de la semana
            const obtenerDiaSemana = (fechaStr) => {
                try {
                    const fechaObj = new Date(fechaStr);
                    const dias = ['domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'];
                    return dias[fechaObj.getDay()];
                } catch (error) {
                    console.error('Error parseando fecha:', fechaStr, error);
                    return 'lunes';
                }
            };
            
            const diaSemana = obtenerDiaSemana(fechaConsulta);
            
            // CONSULTA PRINCIPAL: Obtener psic√≥logos y becarios activos
            const psicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    u.especialidad,
                    u.email
                FROM users u
                WHERE u.rol IN ('psicologo', 'becario')
                    AND u.activo = TRUE
                ORDER BY 
                    CASE u.rol 
                        WHEN 'psicologo' THEN 1
                        WHEN 'becario' THEN 2
                        ELSE 3
                    END,
                    u.apellido, u.nombre
            `, {
                type: QueryTypes.SELECT
            });
            
            
            // Para cada profesional, obtener su disponibilidad y citas programadas
            const disponibilidadDetallada = [];
            
            for (const psicologo of psicologos) {
                try {
                    // 1. Obtener disponibilidad del d√≠a
                    const [disponibilidad] = await sequelize.query(`
                        SELECT 
                            TIME_FORMAT(hora_inicio, '%H:%i') as hora_inicio,
                            TIME_FORMAT(hora_fin, '%H:%i') as hora_fin,
                            COALESCE(max_citas_dia, 8) as max_citas_dia,
                            intervalo_citas
                        FROM disponibilidades
                        WHERE usuario_id = ?
                            AND dia_semana = ?
                            AND activo = TRUE
                            AND (? BETWEEN fecha_inicio_vigencia AND COALESCE(fecha_fin_vigencia, '2099-12-31'))
                        LIMIT 1
                    `, {
                        replacements: [psicologo.id, diaSemana, fechaConsulta],
                        type: QueryTypes.SELECT
                    });
                    
                    // 2. Obtener citas programadas para la fecha
                    const [citasCount] = await sequelize.query(`
                        SELECT COUNT(*) as citas_programadas
                        FROM citas 
                        WHERE (psicologo_id = ? OR becario_id = ?)
                            AND fecha = ?
                            AND estado IN ('programada', 'confirmada')
                    `, {
                        replacements: [psicologo.id, psicologo.id, fechaConsulta],
                        type: QueryTypes.SELECT
                    });
                    
                    const citasProgramadas = citasCount ? parseInt(citasCount.citas_programadas) : 0;
                    const maxCitas = disponibilidad ? parseInt(disponibilidad.max_citas_dia) : 8;
                    const cuposDisponibles = Math.max(0, maxCitas - citasProgramadas);
                    const porcentajeOcupacion = maxCitas > 0 ? Math.round((citasProgramadas / maxCitas) * 100) : 0;
                    
                    // Determinar estado de disponibilidad
                    let estado = 'disponible';
                    if (cuposDisponibles === 0) estado = 'completo';
                    else if (cuposDisponibles <= 2) estado = 'limitado';
                    
                    disponibilidadDetallada.push({
                        id: psicologo.id,
                        profesional: psicologo.profesional,
                        rol: psicologo.rol,
                        especialidad: psicologo.especialidad || (psicologo.rol === 'becario' ? 'Becario' : 'Psicolog√≠a General'),
                        email: psicologo.email,
                        hora_inicio: disponibilidad ? disponibilidad.hora_inicio : '09:00',
                        hora_fin: disponibilidad ? disponibilidad.hora_fin : '18:00',
                        max_citas_dia: maxCitas,
                        citas_programadas: citasProgramadas,
                        cupos_disponibles: cuposDisponibles,
                        porcentaje_ocupacion: porcentajeOcupacion,
                        estado: estado,
                        intervalo_citas: disponibilidad ? disponibilidad.intervalo_citas : 50
                    });
                    
                    
                } catch (error) {
                    console.error(`‚ö†Ô∏è Error procesando ${psicologo.profesional}:`, error.message);
                    // Datos de respaldo
                    disponibilidadDetallada.push({
                        id: psicologo.id,
                        profesional: psicologo.profesional,
                        rol: psicologo.rol,
                        especialidad: psicologo.especialidad || 'Psicolog√≠a General',
                        email: psicologo.email,
                        hora_inicio: '09:00',
                        hora_fin: '18:00',
                        max_citas_dia: 8,
                        citas_programadas: 0,
                        cupos_disponibles: 8,
                        porcentaje_ocupacion: 0,
                        estado: 'disponible',
                        intervalo_citas: 50
                    });
                }
            }
            
            // Estad√≠sticas generales
            const totalProfesionales = disponibilidadDetallada.length;
            const totalCupos = disponibilidadDetallada.reduce((sum, p) => sum + p.max_citas_dia, 0);
            const totalCitasProgramadas = disponibilidadDetallada.reduce((sum, p) => sum + p.citas_programadas, 0);
            const totalCuposDisponibles = disponibilidadDetallada.reduce((sum, p) => sum + p.cupos_disponibles, 0);
            const porcentajeTotalOcupacion = totalCupos > 0 ? Math.round((totalCitasProgramadas / totalCupos) * 100) : 0;
            
            console.log(`üìä Estad√≠sticas: ${totalCitasProgramadas}/${totalCupos} citas (${porcentajeTotalOcupacion}% ocupado)`);
            
            res.json({
                success: true,
                data: {
                    fecha: fechaConsulta,
                    dia_semana: diaSemana,
                    disponibilidad: disponibilidadDetallada,
                    total_profesionales: totalProfesionales,
                    estadisticas: {
                        total_cupos: totalCupos,
                        total_citas_programadas: totalCitasProgramadas,
                        total_cupos_disponibles: totalCuposDisponibles,
                        porcentaje_ocupacion_total: porcentajeTotalOcupacion,
                        profesionales_disponibles: disponibilidadDetallada.filter(p => p.estado === 'disponible').length,
                        profesionales_limitados: disponibilidadDetallada.filter(p => p.estado === 'limitado').length,
                        profesionales_completos: disponibilidadDetallada.filter(p => p.estado === 'completo').length
                    }
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error CR√çTICO en obtenerDisponibilidadProfesionales:', error);
            console.error('Stack trace:', error.stack);
            
            // Respuesta de error controlada
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad de profesionales',
                error: process.env.NODE_ENV === 'development' ? error.message : 'Error interno del servidor',
                data: {
                    fecha: req.query.fecha || new Date().toISOString().split('T')[0],
                    dia_semana: 'lunes',
                    disponibilidad: [],
                    total_profesionales: 0,
                    estadisticas: {
                        total_cupos: 0,
                        total_citas_programadas: 0,
                        total_cupos_disponibles: 0,
                        porcentaje_ocupacion_total: 0,
                        profesionales_disponibles: 0,
                        profesionales_limitados: 0,
                        profesionales_completos: 0
                    }
                }
            });
        }
    }

    // M√©todo auxiliar para obtener d√≠a de la semana
    static obtenerDiaSemana(fecha) {
        try {
            const fechaObj = new Date(fecha);
            const dias = ['domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'];
            return dias[fechaObj.getDay()];
        } catch (error) {
            return 'lunes'; // Valor por defecto
        }
    }
    
    static construirWhereSQL(whereClause) {
        const condiciones = [];
        
        for (const [key, value] of Object.entries(whereClause)) {
            if (typeof value === 'object' && value[Op.between]) {
                condiciones.push(`${key} BETWEEN '${value[Op.between][0]}' AND '${value[Op.between][1]}'`);
            } else if (typeof value === 'object' && value[Op.gte]) {
                condiciones.push(`${key} >= '${value[Op.gte]}'`);
            } else if (typeof value === 'object' && value[Op.lte]) {
                condiciones.push(`${key} <= '${value[Op.lte]}'`);
            } else {
                condiciones.push(`${key} = ${typeof value === 'string' ? `'${value}'` : value}`);
            }
        }
        
        return condiciones.join(' AND ');
    }
    
}

module.exports = AgendaController;

/backend\src\controllers\altaController.js:
--------------------------------------------------------------------------------
const Alta = require('../models/altaModel');
const Paciente = require('../models/pacienteModel');
const Cita = require('../models/citaModel');
const Asignacion = require('../models/asignacionModel');
const { QueryTypes, Op } = require('sequelize'); // A√ëADE Op aqu√≠
const sequelize = require('../config/db');

class AltaController {
    
    static async darAltaPaciente(req, res) {
        try {
            const { paciente_id, tipo_alta, motivo_detallado, recomendaciones, 
                    evaluacion_final, seguimiento_recomendado, fecha_seguimiento } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el paciente existe y est√° activo
            const paciente = await Paciente.findByPk(paciente_id);
            
            if (!paciente || !paciente.activo) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado o ya dado de alta'
                });
            }
            
            // Obtener estad√≠sticas del paciente
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_sesiones,
                    COUNT(CASE WHEN estado = 'completada' THEN 1 END) as sesiones_completadas,
                    MIN(fecha) as primera_sesion,
                    MAX(fecha) as ultima_sesion
                FROM citas 
                WHERE paciente_id = ?
                AND estado IN ('completada', 'cancelada')
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Iniciar transacci√≥n
            const transaction = await sequelize.transaction();
            
            try {
                // 1. Registrar el alta
                const alta = await Alta.create({
                    paciente_id,
                    usuario_id: usuarioId,
                    tipo_alta,
                    fecha_alta: new Date().toISOString().split('T')[0],
                    motivo_detallado,
                    recomendaciones,
                    sesiones_totales: estadisticas?.sesiones_completadas || 0,
                    evaluacion_final,
                    seguimiento_recomendado,
                    fecha_seguimiento: seguimiento_recomendado ? fecha_seguimiento : null
                }, { transaction });
                
                // 2. Desactivar paciente
                await paciente.update({
                    activo: false,
                    estado: `alta_${tipo_alta}`,
                    updated_at: new Date()
                }, { transaction });
                
                // 3. Finalizar asignaciones activas
                await Asignacion.update({
                    estado: 'finalizada',
                    fecha_fin: new Date().toISOString().split('T')[0],
                    motivo_fin: `Paciente dado de alta (${tipo_alta})`
                }, {
                    where: { paciente_id, estado: 'activa' },
                    transaction
                });
                
                // 4. Cancelar citas futuras - VERSI√ìN CORREGIDA
                const fechaHoy = new Date().toISOString().split('T')[0];
                
                await Cita.update({
                    estado: 'cancelada',
                    motivo_cancelacion: `Paciente dado de alta (${tipo_alta})`,
                    updated_at: new Date()
                }, {
                    where: {
                        paciente_id,
                        fecha: { [Op.gte]: fechaHoy },
                        estado: { [Op.in]: ['programada', 'confirmada'] }
                    },
                    transaction
                });
                
                // 5. Obtener profesionales asignados para notificaciones
                const [profesionales] = await sequelize.query(`
                    SELECT DISTINCT 
                        a.psicologo_id,
                        a.becario_id
                    FROM asignaciones a
                    WHERE a.paciente_id = ?
                    AND a.estado = 'activa'
                `, {
                    replacements: [paciente_id],
                    type: QueryTypes.SELECT,
                    transaction
                });
                
                // 6. Crear notificaciones
                if (profesionales) {
                    const notificaciones = [];
                    const titulo = 'Paciente dado de alta';
                    const mensaje = `El paciente ${paciente.nombre} ${paciente.apellido} ha sido dado de alta (${tipo_alta}).`;
                    
                    if (profesionales.psicologo_id) {
                        notificaciones.push([profesionales.psicologo_id, 'alerta_sistema', titulo, mensaje]);
                    }
                    
                    if (profesionales.becario_id) {
                        notificaciones.push([profesionales.becario_id, 'alerta_sistema', titulo, mensaje]);
                    }
                    
                    for (const [usuarioIdNotif, tipo, tituloNotif, mensajeNotif] of notificaciones) {
                        await sequelize.query(`
                            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                            VALUES (?, ?, ?, ?, NOW())
                        `, {
                            replacements: [usuarioIdNotif, tipo, tituloNotif, mensajeNotif],
                            transaction
                        });
                    }
                }
                
                // 7. Registrar log
                await sequelize.query(`
                    INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                    VALUES (?, 'modificacion', 'altas', 'Dar de alta paciente', ?, NOW())
                `, {
                    replacements: [usuarioId, `Alta paciente ${paciente_id} - Tipo: ${tipo_alta}`],
                    transaction
                });
                
                // Commit transacci√≥n
                await transaction.commit();
                
                res.json({
                    success: true,
                    message: 'Paciente dado de alta exitosamente',
                    data: {
                        alta,
                        paciente: {
                            id: paciente.id,
                            nombre: paciente.nombre,
                            apellido: paciente.apellido,
                            estado: paciente.estado
                        },
                        estadisticas
                    }
                });
                
            } catch (error) {
                await transaction.rollback();
                console.error('Error en transacci√≥n de alta:', error);
                throw error;
            }
            
        } catch (error) {
            console.error('Error en darAltaPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al dar de alta paciente',
                error: error.message
            });
        }
    }
    
    static async obtenerAltas(req, res) {
        try {
            const { fecha_inicio, fecha_fin, tipo_alta, psicologo_id } = req.query;
            
            let query = `
                SELECT 
                    a.*,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    p.telefono AS paciente_telefono,
                    u.nombre AS usuario_nombre,
                    u.apellido AS usuario_apellido,
                    COUNT(DISTINCT c.id) AS total_sesiones
                FROM altas a
                JOIN pacientes p ON a.paciente_id = p.id
                JOIN users u ON a.usuario_id = u.id
                LEFT JOIN citas c ON a.paciente_id = c.paciente_id AND c.estado = 'completada'
                WHERE 1=1
            `;
            
            const replacements = [];
            
            if (fecha_inicio) {
                query += ` AND a.fecha_alta >= ?`;
                replacements.push(fecha_inicio);
            }
            
            if (fecha_fin) {
                query += ` AND a.fecha_alta <= ?`;
                replacements.push(fecha_fin);
            }
            
            if (tipo_alta) {
                query += ` AND a.tipo_alta = ?`;
                replacements.push(tipo_alta);
            }
            
            if (psicologo_id) {
                query += ` AND EXISTS (
                    SELECT 1 FROM asignaciones asig 
                    WHERE asig.paciente_id = a.paciente_id 
                    AND asig.psicologo_id = ?
                    AND asig.estado = 'finalizada'
                )`;
                replacements.push(psicologo_id);
            }
            
            query += ` GROUP BY a.id, p.id, u.id
                      ORDER BY a.fecha_alta DESC, p.apellido, p.nombre`;
            
            const altas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: altas,
                count: altas.length
            });
            
        } catch (error) {
            console.error('Error en obtenerAltas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener altas'
            });
        }
    }
    
    static async obtenerAltaDetalle(req, res) {
        try {
            const { id } = req.params;
            
            const query = `
                SELECT 
                    a.*,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    p.fecha_nacimiento,
                    p.genero,
                    p.email AS paciente_email,
                    p.telefono AS paciente_telefono,
                    u.nombre AS usuario_nombre,
                    u.apellido AS usuario_apellido,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = a.paciente_id AND estado = 'completada') AS total_sesiones,
                    (SELECT GROUP_CONCAT(DISTINCT DATE_FORMAT(fecha, '%Y-%m-%d') ORDER BY fecha DESC SEPARATOR ', ') 
                    FROM citas WHERE paciente_id = a.paciente_id AND estado = 'completada' LIMIT 10) AS ultimas_sesiones
                FROM altas a
                JOIN pacientes p ON a.paciente_id = p.id
                JOIN users u ON a.usuario_id = u.id
                LEFT JOIN (
                    SELECT paciente_id, psicologo_id 
                    FROM asignaciones 
                    WHERE paciente_id = ? 
                    ORDER BY fecha_inicio DESC 
                    LIMIT 1
                ) asig ON p.id = asig.paciente_id
                LEFT JOIN users u_psi ON asig.psicologo_id = u_psi.id
                WHERE a.id = ?
            `;
            
            const [alta] = await sequelize.query(query, {
                replacements: [id, id],
                type: QueryTypes.SELECT
            });
            
            if (!alta) {
                return res.status(404).json({
                    success: false,
                    message: 'Alta no encontrada'
                });
            }
            
            res.json({
                success: true,
                data: alta
            });
            
        } catch (error) {
            console.error('Error en obtenerAltaDetalle:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener detalle de alta'
            });
        }
    }
    
    static async obtenerEstadisticasAltas(req, res) {
        try {
            const { fecha_inicio, fecha_fin } = req.query;
            
            let query = `
                SELECT 
                    tipo_alta,
                    COUNT(*) as total,
                    MONTH(fecha_alta) as mes,
                    YEAR(fecha_alta) as anio,
                    AVG(sesiones_totales) as promedio_sesiones,
                    SUM(CASE WHEN seguimiento_recomendado = TRUE THEN 1 ELSE 0 END) as seguimientos_recomendados
                FROM altas
                WHERE 1=1
            `;
            
            let replacements = [];
            
            if (fecha_inicio) {
                query += ` AND fecha_alta >= ?`;
                replacements.push(fecha_inicio);
            }
            
            if (fecha_fin) {
                query += ` AND fecha_alta <= ?`;
                replacements.push(fecha_fin);
            }
            
            query += ` GROUP BY tipo_alta, YEAR(fecha_alta), MONTH(fecha_alta)
                    ORDER BY anio DESC, mes DESC, total DESC`;
            
            const estadisticas = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            // Totales generales - AQU√ç ESTABA EL ERROR PRINCIPAL
            // Crear la query para totales de forma din√°mica
            let totalesQuery = `
                SELECT 
                    COUNT(*) as total_altas,
                    AVG(sesiones_totales) as promedio_sesiones_global,
                    MIN(fecha_alta) as primera_alta,
                    MAX(fecha_alta) as ultima_alta
                FROM altas
                WHERE 1=1
            `;
            
            let totalesReplacements = [];
            
            if (fecha_inicio) {
                totalesQuery += ` AND fecha_alta >= ?`;
                totalesReplacements.push(fecha_inicio);
            }
            
            if (fecha_fin) {
                totalesQuery += ` AND fecha_alta <= ?`;
                totalesReplacements.push(fecha_fin);
            }
            
            const [totales] = await sequelize.query(totalesQuery, {
                replacements: totalesReplacements,
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    totales
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasAltas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas de altas'
            });
        }
    }
    
    // M√©todo auxiliar para verificar permisos
    static async verificarPermisoAlta(usuarioId, pacienteId) {
        const usuarioRol = await this.obtenerRolUsuario(usuarioId);
        
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
            `, {
                replacements: [pacienteId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!asignacion;
        }
        
        return false;
    }
    
    static async obtenerRolUsuario(usuarioId) {
        const [usuario] = await sequelize.query(
            'SELECT rol FROM users WHERE id = ?',
            { replacements: [usuarioId], type: QueryTypes.SELECT }
        );
        
        return usuario?.rol;
    }
}

module.exports = AltaController;

/backend\src\controllers\asignacionController.js:
--------------------------------------------------------------------------------
const Asignacion = require('../models/asignacionModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class AsignacionController {
    
    static async crearAsignacion(req, res) {
        try {
            const { paciente_id, psicologo_id, becario_id, notas } = req.body;
            const usuarioId = req.user.id;
            
            // Validar que el paciente existe y est√° activo
            const paciente = await Paciente.findByPk(paciente_id);
            if (!paciente || !paciente.activo) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado o inactivo'
                });
            }
            
            // Validar que el psic√≥logo existe y es psic√≥logo
            const psicologo = await User.findOne({
                where: { id: psicologo_id, rol: 'psicologo', activo: true }
            });
            
            if (!psicologo) {
                return res.status(404).json({
                    success: false,
                    message: 'Psic√≥logo no encontrado o inactivo'
                });
            }
            
            // Validar que el becario existe si se especifica
            if (becario_id) {
                const becario = await User.findOne({
                    where: { id: becario_id, rol: 'becario', activo: true }
                });
                
                if (!becario) {
                    return res.status(404).json({
                        success: false,
                        message: 'Becario no encontrado o inactivo'
                    });
                }
            }
            
            // Verificar que no haya asignaci√≥n activa
            const asignacionExistente = await Asignacion.findOne({
                where: {
                    paciente_id,
                    estado: 'activa'
                }
            });
            
            if (asignacionExistente) {
                // Finalizar asignaci√≥n anterior
                await asignacionExistente.update({
                    estado: 'finalizada',
                    fecha_fin: new Date().toISOString().split('T')[0],
                    motivo_fin: 'Reasignaci√≥n'
                });
            }
            
            // Crear nueva asignaci√≥n
            const asignacion = await Asignacion.create({
                paciente_id,
                psicologo_id,
                becario_id,
                notas,
                fecha_inicio: new Date().toISOString().split('T')[0]
            });
            
            // Actualizar paciente con psic√≥logo asignado
            await paciente.update({ fundacion_id: psicologo.fundacion_id });
            
            // Crear notificaciones
            await sequelize.query(`
                INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                VALUES 
                (?, 'asignacion_nueva', 'Nueva asignaci√≥n', CONCAT('Se le ha asignado el paciente: ', ?), NOW()),
                (?, 'asignacion_nueva', 'Nueva asignaci√≥n', CONCAT('Ha sido asignado como supervisor del paciente: ', ?), NOW())
            `, {
                replacements: [
                    psicologo_id,
                    `${paciente.nombre} ${paciente.apellido}`,
                    usuarioId,
                    `${paciente.nombre} ${paciente.apellido}`
                ]
            });
            
            if (becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'asignacion_nueva', 'Nueva asignaci√≥n', CONCAT('Se le ha asignado el paciente: ', ?), NOW())
                `, {
                    replacements: [
                        becario_id,
                        `${paciente.nombre} ${paciente.apellido}`
                    ]
                });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'asignaciones', 'Crear asignaci√≥n', ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Asignaci√≥n creada: Paciente ${paciente.id} ‚Üí Psic√≥logo ${psicologo_id}${becario_id ? ` + Becario ${becario_id}` : ''}`
                ]
            });
            
            res.json({
                success: true,
                message: 'Asignaci√≥n creada exitosamente',
                data: asignacion
            });
            
        } catch (error) {
            console.error('Error en crearAsignacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear asignaci√≥n',
                error: error.message
            });
        }
    }
    
    static async obtenerAsignacionesActivas(req, res) {
        try {
            const { psicologo_id, becario_id, paciente_id } = req.query;
            const usuarioId = req.user.id;
            
            const whereClause = { estado: 'activa' };
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (becario_id) whereClause.becario_id = becario_id;
            if (paciente_id) whereClause.paciente_id = paciente_id;
            
            const asignaciones = await Asignacion.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['id', 'nombre', 'apellido', 'email', 'telefono', 'estado']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'email', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            res.json({
                success: true,
                data: asignaciones,
                count: asignaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerAsignacionesActivas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener asignaciones'
            });
        }
    }
    
    static async obtenerMisPacientes(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            let query = '';
            let replacements = [usuarioId];
            
            if (usuarioRol === 'psicologo') {
                query = `
                    SELECT 
                        p.*,
                        a.fecha_inicio,
                        a.becario_id,
                        u_bec.nombre AS becario_nombre,
                        u_bec.apellido AS becario_apellido,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.estado = 'completada') AS sesiones_completadas,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.estado = 'programada'
                         AND c.fecha >= CURDATE()) AS citas_pendientes
                    FROM asignaciones a
                    JOIN pacientes p ON a.paciente_id = p.id
                    LEFT JOIN users u_bec ON a.becario_id = u_bec.id
                    WHERE a.psicologo_id = ? 
                    AND a.estado = 'activa'
                    AND p.activo = TRUE
                    ORDER BY p.apellido, p.nombre
                `;
            } else if (usuarioRol === 'becario') {
                query = `
                    SELECT 
                        p.*,
                        a.fecha_inicio,
                        a.psicologo_id,
                        u_psi.nombre AS psicologo_nombre,
                        u_psi.apellido AS psicologo_apellido,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.becario_id = ?
                         AND c.estado = 'completada') AS sesiones_completadas,
                        (SELECT COUNT(*) FROM citas c 
                         WHERE c.paciente_id = p.id 
                         AND c.becario_id = ?
                         AND c.estado = 'programada'
                         AND c.fecha >= CURDATE()) AS citas_pendientes
                    FROM asignaciones a
                    JOIN pacientes p ON a.paciente_id = p.id
                    JOIN users u_psi ON a.psicologo_id = u_psi.id
                    WHERE a.becario_id = ? 
                    AND a.estado = 'activa'
                    AND p.activo = TRUE
                    ORDER BY p.apellido, p.nombre
                `;
                replacements = [usuarioId, usuarioId, usuarioId];
            } else {
                return res.status(403).json({
                    success: false,
                    message: 'Acceso no permitido para este rol'
                });
            }
            
            const pacientes = await sequelize.query(query, {
                replacements,
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: pacientes,
                count: pacientes.length
            });
            
        } catch (error) {
            console.error('Error en obtenerMisPacientes:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener pacientes asignados'
            });
        }
    }
    
    static async finalizarAsignacion(req, res) {
        try {
            const { id } = req.params;
            const { motivo_fin, notas } = req.body;
            const usuarioId = req.user.id;
            
            const asignacion = await Asignacion.findByPk(id);
            
            if (!asignacion || asignacion.estado !== 'activa') {
                return res.status(404).json({
                    success: false,
                    message: 'Asignaci√≥n activa no encontrada'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...asignacion.toJSON() };
            
            await asignacion.update({
                estado: 'finalizada',
                fecha_fin: new Date().toISOString().split('T')[0],
                motivo_fin: motivo_fin || 'Finalizaci√≥n manual',
                notas: notas ? `${asignacion.notas || ''}\n--- Finalizaci√≥n ---\n${notas}` : asignacion.notas
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'asignaciones', 'Finalizar asignaci√≥n', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Asignaci√≥n finalizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(asignacion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Asignaci√≥n finalizada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en finalizarAsignacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al finalizar asignaci√≥n'
            });
        }
    }
    
    static async obtenerHistorialAsignaciones(req, res) {
        try {
            const { paciente_id } = req.params;
            
            const asignaciones = await Asignacion.findAll({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            res.json({
                success: true,
                data: asignaciones,
                count: asignaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerHistorialAsignaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener historial de asignaciones'
            });
        }
    }
}

module.exports = AsignacionController;

/backend\src\controllers\authController.js:
--------------------------------------------------------------------------------
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
// Importamos el modelo de Sequelize
const User = require('../models/userModel'); 

class AuthController {
    
    static async login(req, res) {
        try {
            const { email, password } = req.body;

            // 1. Validar entrada b√°sica
            if (!email || !password) {
                return res.status(400).json({ message: 'Por favor ingrese email y contrase√±a' });
            }

            // 2. Buscar el usuario usando Sequelize
            // En vez de SQL crudo, usamos el m√©todo findOne con una cl√°usula 'where'
            const user = await User.findOne({ 
                where: { email: email } 
            });

            // 3. Verificar si el usuario existe
            if (!user) {
                // 'user' ser√° null si no se encuentra
                return res.status(401).json({ message: 'Credenciales inv√°lidas' });
            }

            // 4. Comparar la contrase√±a (user.password accede al campo del objeto Sequelize)
            const isMatch = await bcrypt.compare(password, user.password);

            if (!isMatch) {
                return res.status(401).json({ message: 'Credenciales inv√°lidas' });
            }

            // 5. Generar el JWT (usamos user.id y user.email del objeto Sequelize)
            const payload = {
                id: user.id,
                email: user.email
            };

            const token = jwt.sign(
                payload, 
                process.env.JWT_SECRET, 
                { expiresIn: process.env.JWT_EXPIRES_IN }
            );

            // 6. Responder (user.toJSON() limpia metadatos de Sequelize si es necesario)
            res.json({
                message: 'Login exitoso',
                token: token,
                user: { 
                    id: user.id, 
                    email: user.email,
                    nombre: user.nombre, // A√±ade esto
                    apellido: user.apellido, // A√±ade esto
                    rol: user.rol, // A√±ade esto
                    especialidad: user.especialidad, // A√±ade esto (si aplica)
                    created_at: user.created_at // Cambia createdAt por created_at
                }
            });

        } catch (error) {
            console.error('Error en el login:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }

    static async getMe(req, res) {
        try {
            const userId = req.user.id;
            
            // Buscar usuario en la base de datos
            const user = await User.findOne({ 
                where: { id: userId },
                attributes: ['id', 'email', 'nombre', 'apellido', 'rol', 'especialidad', 'created_at'] // Cambia 'createdAt' por 'created_at'
            });
            
            if (!user) {
                return res.status(404).json({ message: 'Usuario no encontrado' });
            }
            
            res.json({
                message: 'Usuario obtenido exitosamente',
                user: user
            });
            
        } catch (error) {
            console.error('Error al obtener usuario:', error);
            res.status(500).json({ message: 'Error interno del servidor' });
        }
    }
}

module.exports = AuthController

/backend\src\controllers\citaController.js:
--------------------------------------------------------------------------------
const DatabaseService = require('../services/databaseService');

class CitaController {
    
    static async obtenerCitasPorFecha(req, res) {
        try {
            console.log('obtenerCitasPorFecha llamado');
            console.log('Query params:', req.query);
            
            const { fecha, becario_id } = req.query;
            
            // Validar par√°metro requerido
            if (!fecha) {
                return res.status(400).json({
                    success: false,
                    message: 'El par√°metro "fecha" es requerido (formato: YYYY-MM-DD)'
                });
            }
            
            const becarioId = becario_id ? parseInt(becario_id) : null;
            
            console.log(`Buscando citas para fecha: ${fecha}, becarioId: ${becarioId}`);
            
            const citas = await DatabaseService.obtenerCitasPorFechaBecario(fecha, becarioId);
            
            console.log(`Citas encontradas: ${Array.isArray(citas) ? citas.length : 0}`);
            
            // Asegurarnos de que citas siempre sea un array
            const citasArray = Array.isArray(citas) ? citas : [];
            
            res.json({
                success: true,
                data: citasArray,
                count: citasArray.length
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFecha:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener citas',
                error: error.message
            });
        }
    }

    static async crearNuevaCita(req, res) {
        try {
            const { paciente, fecha, hora, tipo_consulta, duracion, notas, becario_id } = req.body;
            const usuarioId = req.user.id;
            
            console.log('üìù Datos recibidos para nueva cita:', {
                paciente,
                fecha,
                hora,
                tipo_consulta,
                duracion,
                notas,
                becario_id,
                usuarioId
            });
            
            // Validar campos requeridos
            if (!paciente || !paciente.nombre || !paciente.apellido || !fecha || !hora) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente (nombre, apellido), fecha y hora'
                });
            }
            
            // Crear la cita usando DatabaseService
            const nuevaCita = await DatabaseService.crearNuevaCita({
                paciente,
                fecha,
                hora,
                tipo_consulta: tipo_consulta || 'presencial',
                duracion: duracion || 50,
                notas,
                becario_id,
                usuarioId
            });
            
            res.json({
                success: true,
                message: 'Cita creada exitosamente',
                data: nuevaCita
            });
            
        } catch (error) {
            console.error('‚ùå Error en crearNuevaCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear la cita',
                error: error.message
            });
        }
    }
    
    static async generarReporteMensual(req, res) {
        try {
            const { mes, anio, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const reporte = await DatabaseService.generarReporteMensual(
                parseInt(mes),
                parseInt(anio),
                psicologoId
            );
            
            res.json({
                success: true,
                data: reporte,
                count: reporte.length,
                mes: mes,
                anio: anio
            });
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte',
                error: error.message
            });
        }
    }
    
    static async darAltaPaciente(req, res) {
        try {
            const { paciente_id, tipo_alta, notas } = req.body;
            const usuarioId = req.user.id;
            
            if (!paciente_id || !tipo_alta) {
                return res.status(400).json({
                    success: false,
                    message: 'Faltan campos requeridos: paciente_id y tipo_alta'
                });
            }
            
            await DatabaseService.darAltaPaciente(
                paciente_id,
                tipo_alta,
                usuarioId,
                notas
            );
            
            res.json({
                success: true,
                message: 'Paciente dado de alta exitosamente'
            });
            
        } catch (error) {
            console.error('Error en darAltaPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al dar de alta paciente',
                error: error.message
            });
        }
    }
    
    static async actualizarCita(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            // Validar campos que se pueden actualizar
            const camposPermitidos = ['fecha', 'hora', 'tipo_consulta', 'estado', 'notas', 'motivo_cancelacion', 'psicologo_id', 'becario_id'];
            const updatesFiltrados = {};
            
            for (const campo of camposPermitidos) {
                if (updates[campo] !== undefined) {
                    updatesFiltrados[campo] = updates[campo];
                }
            }
            
            if (Object.keys(updatesFiltrados).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos v√°lidos para actualizar'
                });
            }
            
            await DatabaseService.actualizarCita(
                parseInt(id),
                updatesFiltrados,
                usuarioId
            );
            
            res.json({
                success: true,
                message: 'Cita actualizada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en actualizarCita:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar cita',
                error: error.message
            });
        }
    }
    
    static async obtenerEstadisticas(req, res) {
        try {
            const { fecha_inicio, fecha_fin, psicologo_id } = req.query;
            const psicologoId = psicologo_id ? parseInt(psicologo_id) : null;
            
            const estadisticas = await DatabaseService.obtenerEstadisticas(
                fecha_inicio,
                fecha_fin,
                psicologoId
            );
            
            res.json({
                success: true,
                data: estadisticas
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas',
                error: error.message
            });
        }
    }
}

module.exports = CitaController;

/backend\src\controllers\dashboardController.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class DashboardController {
    
    static async obtenerDashboardCoordinador(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estad√≠sticas generales
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = FALSE) as pacientes_inactivos,
                    (SELECT COUNT(*) FROM pacientes WHERE DATE(created_at) = CURDATE()) as pacientes_nuevos_hoy,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'cancelada') as citas_canceladas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 7 DAY) AND CURDATE()) as citas_semana,
                    
                    -- Profesionales
                    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'coordinador' AND activo = TRUE) as coordinadores_activos,
                    
                    -- Asignaciones
                    (SELECT COUNT(*) FROM asignaciones WHERE estado = 'activa') as asignaciones_activas,
                    (SELECT COUNT(*) FROM asignaciones WHERE estado = 'finalizada' AND fecha_fin >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as asignaciones_finalizadas_mes,
                    
                    -- Altas
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as altas_mes,
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta = CURDATE()) as altas_hoy
            `, { type: QueryTypes.SELECT });
            
            // Citas por d√≠a de la semana actual
            const citasPorDia = await sequelize.query(`
                SELECT 
                    DAYNAME(fecha) as dia,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas
                FROM citas
                WHERE YEARWEEK(fecha, 1) = YEARWEEK(CURDATE(), 1)
                GROUP BY DAYNAME(fecha), DAYOFWEEK(fecha)
                ORDER BY DAYOFWEEK(fecha)
            `, { type: QueryTypes.SELECT });
            
            // Top psic√≥logos por citas completadas
            const topPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as nombre_completo,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completadas
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
                WHERE u.rol = 'psicologo' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY citas_completadas DESC
                LIMIT 10
            `, { type: QueryTypes.SELECT });
            
            // Alertas y pendientes
            const alertas = await sequelize.query(`
                SELECT 
                    'citas_sin_confirmar' as tipo,
                    COUNT(*) as cantidad,
                    'Citas programadas sin confirmar' as descripcion
                FROM citas
                WHERE estado = 'programada' AND fecha = CURDATE()
                
                UNION ALL
                
                SELECT 
                    'observaciones_pendientes' as tipo,
                    COUNT(*) as cantidad,
                    'Observaciones de becarios pendientes de revisi√≥n' as descripcion
                FROM observaciones_becarios
                WHERE fecha_seguimiento <= CURDATE() AND fecha_seguimiento IS NOT NULL
                
                UNION ALL
                
                SELECT 
                    'altas_pendientes' as tipo,
                    COUNT(*) as cantidad,
                    'Pacientes pendientes de revisi√≥n para alta' as descripcion
                FROM pacientes p
                WHERE p.activo = TRUE 
                AND NOT EXISTS (SELECT 1 FROM altas a WHERE a.paciente_id = p.id)
                AND (SELECT COUNT(*) FROM citas c WHERE c.paciente_id = p.id AND c.estado = 'completada') >= 4
            `, { type: QueryTypes.SELECT });
            
            // Evoluci√≥n mensual de pacientes
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha_alta, '%Y-%m') as mes,
                    COUNT(*) as altas,
                    SUM(CASE WHEN tipo_alta = 'terapeutica' THEN 1 ELSE 0 END) as altas_terapeuticas,
                    SUM(CASE WHEN tipo_alta = 'abandono' THEN 1 ELSE 0 END) as abandonos
                FROM altas
                WHERE fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
                GROUP BY DATE_FORMAT(fecha_alta, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    citas_por_dia: citasPorDia,
                    top_psicologos: topPsicologos,
                    alertas,
                    evolucion_mensual: evolucionMensual.reverse(), // Orden ascendente
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardCoordinador:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de coordinador'
            });
        }
    }
    
    static async obtenerDashboardPsicologo(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estad√≠sticas del psic√≥logo
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes asignados
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE psicologo_id = ? AND estado = 'activa') as pacientes_asignados,
                    
                    -- Becarios supervisados
                    (SELECT COUNT(DISTINCT becario_id) FROM asignaciones WHERE psicologo_id = ? AND becario_id IS NOT NULL AND estado = 'activa') as becarios_supervisados,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 7 DAY) AND CURDATE()) as citas_semana,
                    
                    -- Sesiones registradas
                    (SELECT COUNT(*) FROM sesiones WHERE psicologo_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as sesiones_mes,
                    
                    -- Observaciones realizadas
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE supervisor_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as observaciones_mes,
                    
                    -- Altas realizadas
                    (SELECT COUNT(*) FROM altas WHERE usuario_id = ? AND fecha_alta >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as altas_mes
            `, {
                replacements: [usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Pr√≥ximas citas
            const proximasCitas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    u_bec.nombre as becario_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.psicologo_id = ?
                AND c.fecha >= CURDATE()
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
                LIMIT 10
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Pacientes con seguimiento pendiente
            const pacientesSeguimiento = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    MAX(c.fecha) as ultima_sesion,
                    DATEDIFF(CURDATE(), MAX(c.fecha)) as dias_desde_ultima,
                    COUNT(c.id) as total_sesiones
                FROM asignaciones a
                JOIN pacientes p ON a.paciente_id = p.id
                LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
                WHERE a.psicologo_id = ?
                AND a.estado = 'activa'
                AND p.activo = TRUE
                GROUP BY p.id, p.nombre, p.apellido
                HAVING DATEDIFF(CURDATE(), MAX(c.fecha)) > 14 OR MAX(c.fecha) IS NULL
                ORDER BY dias_desde_ultima DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Observaciones recientes de becarios
            const observacionesRecientes = await sequelize.query(`
                SELECT 
                    ob.id,
                    ob.fecha,
                    ob.aspecto_evaluado,
                    ob.calificacion,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario,
                    ob.plan_accion,
                    ob.fecha_seguimiento
                FROM observaciones_becarios ob
                JOIN users u_bec ON ob.becario_id = u_bec.id
                WHERE ob.supervisor_id = ?
                ORDER BY ob.fecha DESC, ob.created_at DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Disponibilidad para la semana
            const disponibilidadSemana = await sequelize.query(`
                SELECT 
                    d.dia_semana,
                    TIME_FORMAT(d.hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(d.hora_fin, '%H:%i') as hora_fin,
                    COUNT(c.id) as citas_programadas
                FROM disponibilidades d
                LEFT JOIN citas c ON d.usuario_id = c.psicologo_id 
                    AND c.fecha BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY)
                    AND c.estado IN ('programada', 'confirmada')
                    AND DAYNAME(c.fecha) = d.dia_semana
                    AND TIME(c.hora) BETWEEN d.hora_inicio AND d.hora_fin
                WHERE d.usuario_id = ?
                AND d.activo = TRUE
                GROUP BY d.dia_semana, d.hora_inicio, d.hora_fin
                ORDER BY FIELD(d.dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo')
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    proximas_citas: proximasCitas,
                    pacientes_seguimiento: pacientesSeguimiento,
                    observaciones_recientes: observacionesRecientes,
                    disponibilidad_semana: disponibilidadSemana,
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardPsicologo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de psic√≥logo'
            });
        }
    }
    
    static async obtenerDashboardBecario(req, res) {
        try {
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            
            // Estad√≠sticas del becario
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes asignados
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE becario_id = ? AND estado = 'activa') as pacientes_asignados,
                    
                    -- Citas de hoy
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy,
                    
                    -- Citas totales
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND CURDATE()) as citas_mes,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND estado = 'completada') as citas_completadas_total,
                    
                    -- Observaciones recibidas
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE becario_id = ? AND fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as observaciones_mes,
                    (SELECT AVG(calificacion) FROM observaciones_becarios WHERE becario_id = ?) as promedio_calificacion,
                    
                    -- Supervisor
                    (SELECT CONCAT(u.nombre, ' ', u.apellido) FROM asignaciones a 
                     JOIN users u ON a.psicologo_id = u.id 
                     WHERE a.becario_id = ? AND a.estado = 'activa' LIMIT 1) as supervisor
            `, {
                replacements: [usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Citas de hoy
            const citasHoy = await sequelize.query(`
                SELECT 
                    c.id,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    c.tipo_consulta,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono,
                    u_psi.nombre as psicologo_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
                WHERE c.becario_id = ?
                AND c.fecha = CURDATE()
                AND c.estado IN ('programada', 'confirmada', 'completada')
                ORDER BY c.hora
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Pr√≥ximas citas
            const proximasCitas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    c.estado,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    p.telefono as paciente_telefono
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.fecha > CURDATE()
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
                LIMIT 10
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Observaciones recientes
            const observacionesRecientes = await sequelize.query(`
                SELECT 
                    ob.id,
                    ob.fecha,
                    ob.aspecto_evaluado,
                    ob.calificacion,
                    ob.fortalezas,
                    ob.areas_mejora,
                    CONCAT(u_sup.nombre, ' ', u_sup.apellido) as supervisor,
                    ob.fecha_seguimiento
                FROM observaciones_becarios ob
                JOIN users u_sup ON ob.supervisor_id = u_sup.id
                WHERE ob.becario_id = ?
                ORDER BY ob.fecha DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Tareas pendientes (sesiones sin registro)
            const tareasPendientes = await sequelize.query(`
                SELECT 
                    c.id as cita_id,
                    c.fecha,
                    TIME_FORMAT(c.hora, '%H:%i') as hora,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    DATEDIFF(CURDATE(), c.fecha) as dias_pasados
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.estado = 'completada'
                AND NOT EXISTS (SELECT 1 FROM sesiones s WHERE s.cita_id = c.id)
                AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
                ORDER BY c.fecha DESC
                LIMIT 5
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            // Disponibilidad
            const disponibilidad = await sequelize.query(`
                SELECT 
                    dia_semana,
                    TIME_FORMAT(hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(hora_fin, '%H:%i') as hora_fin
                FROM disponibilidades
                WHERE usuario_id = ?
                AND activo = TRUE
                ORDER BY FIELD(dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo')
            `, {
                replacements: [usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    estadisticas,
                    citas_hoy,
                    proximas_citas,
                    observaciones_recientes,
                    tareas_pendientes,
                    disponibilidad,
                    ultima_actualizacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDashboardBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener dashboard de becario'
            });
        }
    }
    
    static async obtenerMetricasGlobales(req, res) {
        try {
            const { periodo = 'mes' } = req.query; // mes, trimestre, semestre, a√±o
            
            let intervalo;
            switch (periodo) {
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                case 'semestre':
                    intervalo = 'INTERVAL 180 DAY';
                    break;
                case 'a√±o':
                    intervalo = 'INTERVAL 365 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            // M√©tricas principales
            const [metricas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    COUNT(DISTINCT p.id) as total_pacientes,
                    COUNT(DISTINCT CASE WHEN p.activo = TRUE THEN p.id END) as pacientes_activos,
                    COUNT(DISTINCT CASE WHEN p.activo = FALSE THEN p.id END) as pacientes_inactivos,
                    
                    -- Citas
                    COUNT(DISTINCT c.id) as total_citas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) as citas_completadas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'cancelada' THEN c.id END) as citas_canceladas,
                    
                    -- Sesiones
                    COUNT(DISTINCT s.id) as sesiones_registradas,
                    
                    -- Altas
                    COUNT(DISTINCT a.id) as altas_realizadas,
                    COUNT(DISTINCT CASE WHEN a.tipo_alta = 'terapeutica' THEN a.id END) as altas_terapeuticas,
                    
                    -- Tasa de completitud
                    ROUND(COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) * 100.0 / 
                          NULLIF(COUNT(DISTINCT c.id), 0), 2) as tasa_completitud_citas,
                    
                    -- Tasa de abandono
                    ROUND(COUNT(DISTINCT CASE WHEN a.tipo_alta = 'abandono' THEN a.id END) * 100.0 / 
                          NULLIF(COUNT(DISTINCT a.id), 0), 2) as tasa_abandono
                    
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN altas a ON p.id = a.paciente_id AND a.fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})
                WHERE p.created_at >= DATE_SUB(CURDATE(), ${intervalo})
            `, { type: QueryTypes.SELECT });
            
            // Evoluci√≥n semanal
            const evolucionSemanal = await sequelize.query(`
                SELECT 
                    YEARWEEK(c.fecha, 1) as semana,
                    COUNT(DISTINCT c.id) as total_citas,
                    COUNT(DISTINCT CASE WHEN c.estado = 'completada' THEN c.id END) as citas_completadas,
                    COUNT(DISTINCT p.id) as pacientes_atendidos,
                    COUNT(DISTINCT a.id) as altas_realizadas
                FROM citas c
                LEFT JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN altas a ON p.id = a.paciente_id AND YEARWEEK(a.fecha_alta, 1) = YEARWEEK(c.fecha, 1)
                WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY YEARWEEK(c.fecha, 1)
                ORDER BY semana DESC
                LIMIT 12
            `, { type: QueryTypes.SELECT });
            
            // Distribuci√≥n por tipo de consulta
            const distribucionConsulta = await sequelize.query(`
                SELECT 
                    c.tipo_consulta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM citas c
                WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY c.tipo_consulta
            `, { type: QueryTypes.SELECT });
            
            // Distribuci√≥n por motivo de alta
            const distribucionAlta = await sequelize.query(`
                SELECT 
                    a.tipo_alta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM altas a
                WHERE a.fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})
                GROUP BY a.tipo_alta
            `, { type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    periodo,
                    metricas,
                    evolucion_semanal: evolucionSemanal.reverse(),
                    distribucion_consulta: distribucionConsulta,
                    distribucion_alta: distribucionAlta,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerMetricasGlobales:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener m√©tricas globales'
            });
        }
    }
}

module.exports = DashboardController;

/backend\src\controllers\disponibilidadController.js:
--------------------------------------------------------------------------------
const Disponibilidad = require('../models/disponibilidadModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class DisponibilidadController {
    
    static async crearDisponibilidad(req, res) {
        try {
            const { dia_semana, hora_inicio, hora_fin, tipo_disponibilidad, 
                    notas, max_citas_dia, intervalo_citas, fecha_fin_vigencia } = req.body;
            const usuarioId = req.user.id;
            
            // Validar que el usuario existe y es profesional (psicologo o becario)
            const usuario = await User.findByPk(usuarioId);
            if (!['psicologo', 'becario'].includes(usuario.rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo psic√≥logos y becarios pueden configurar disponibilidad'
                });
            }
            
            // Validar formato de hora
            if (!this.validarHora(hora_inicio) || !this.validarHora(hora_fin)) {
                return res.status(400).json({
                    success: false,
                    message: 'Formato de hora inv√°lido. Use HH:MM'
                });
            }
            
            // Validar que hora_fin sea mayor que hora_inicio
            if (this.compararHoras(hora_fin, hora_inicio) <= 0) {
                return res.status(400).json({
                    success: false,
                    message: 'La hora de fin debe ser mayor que la hora de inicio'
                });
            }
            
            // Verificar que no se solape con otra disponibilidad en el mismo d√≠a
            const solapamiento = await Disponibilidad.findOne({
                where: {
                    usuario_id: usuarioId,
                    dia_semana,
                    activo: true,
                    [sequelize.Op.or]: [
                        {
                            hora_inicio: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                        },
                        {
                            hora_fin: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                        },
                        {
                            [sequelize.Op.and]: [
                                { hora_inicio: { [sequelize.Op.lte]: hora_inicio } },
                                { hora_fin: { [sequelize.Op.gte]: hora_fin } }
                            ]
                        }
                    ]
                }
            });
            
            if (solapamiento) {
                return res.status(400).json({
                    success: false,
                    message: 'La disponibilidad se solapa con otro horario configurado para este d√≠a'
                });
            }
            
            // Crear disponibilidad
            const disponibilidad = await Disponibilidad.create({
                usuario_id: usuarioId,
                dia_semana,
                hora_inicio,
                hora_fin,
                tipo_disponibilidad: tipo_disponibilidad || 'regular',
                notas,
                max_citas_dia: max_citas_dia || 8,
                intervalo_citas: intervalo_citas || 50,
                fecha_inicio_vigencia: new Date().toISOString().split('T')[0],
                fecha_fin_vigencia: fecha_fin_vigencia || null,
                activo: true
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'disponibilidad', 'Crear disponibilidad', ?, NOW())
            `, {
                replacements: [usuarioId, `Disponibilidad creada: ${dia_semana} ${hora_inicio}-${hora_fin}`]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad creada exitosamente',
                data: disponibilidad
            });
            
        } catch (error) {
            console.error('Error en crearDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear disponibilidad',
                error: error.message
            });
        }
    }
    
    static async obtenerMiDisponibilidad(req, res) {
        try {
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findAll({
                where: {
                    usuario_id: usuarioId,
                    activo: true,
                    [sequelize.Op.or]: [
                        { fecha_fin_vigencia: null },
                        { fecha_fin_vigencia: { [sequelize.Op.gte]: new Date().toISOString().split('T')[0] } }
                    ]
                },
                order: [
                    ['dia_semana', 'ASC'],
                    ['hora_inicio', 'ASC']
                ]
            });
            
            // Obtener citas programadas para los pr√≥ximos 7 d√≠as
            const [citasProgramadas] = await sequelize.query(`
                SELECT 
                    fecha,
                    COUNT(*) as citas_count
                FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY)
                AND estado IN ('programada', 'confirmada')
                GROUP BY fecha
                ORDER BY fecha
            `, {
                replacements: [usuarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    disponibilidad,
                    proximas_citas: citasProgramadas || []
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerMiDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad'
            });
        }
    }
    
    static async obtenerDisponibilidadUsuario(req, res) {
        try {
            const { usuario_id } = req.params;
            const solicitanteId = req.user.id;
            const solicitanteRol = req.user.rol;
            
            // Verificar permisos (coordinador o psic√≥logo supervisor)
            const puedeVer = await this.verificarPermisoVerDisponibilidad(solicitanteId, solicitanteRol, usuario_id);
            
            if (!puedeVer) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver la disponibilidad de este usuario'
                });
            }
            
            const disponibilidad = await Disponibilidad.findAll({
                where: {
                    usuario_id,
                    activo: true
                },
                order: [
                    ['dia_semana', 'ASC'],
                    ['hora_inicio', 'ASC']
                ]
            });
            
            // Obtener informaci√≥n del usuario
            const usuario = await User.findByPk(usuario_id, {
                attributes: ['id', 'nombre', 'apellido', 'rol', 'especialidad']
            });
            
            res.json({
                success: true,
                data: {
                    usuario,
                    disponibilidad
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerDisponibilidadUsuario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener disponibilidad del usuario'
            });
        }
    }
    
    static async actualizarDisponibilidad(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findByPk(id);
            
            if (!disponibilidad) {
                return res.status(404).json({
                    success: false,
                    message: 'Disponibilidad no encontrada'
                });
            }
            
            // Verificar que el usuario es el due√±o de la disponibilidad
            if (disponibilidad.usuario_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar esta disponibilidad'
                });
            }
            
            // Validar horas si se est√°n actualizando
            if (updates.hora_inicio || updates.hora_fin) {
                const hora_inicio = updates.hora_inicio || disponibilidad.hora_inicio;
                const hora_fin = updates.hora_fin || disponibilidad.hora_fin;
                
                if (this.compararHoras(hora_fin, hora_inicio) <= 0) {
                    return res.status(400).json({
                        success: false,
                        message: 'La hora de fin debe ser mayor que la hora de inicio'
                    });
                }
                
                // Verificar solapamiento excluyendo el registro actual
                const solapamiento = await Disponibilidad.findOne({
                    where: {
                        usuario_id: disponibilidad.usuario_id,
                        dia_semana: updates.dia_semana || disponibilidad.dia_semana,
                        id: { [sequelize.Op.ne]: id },
                        activo: true,
                        [sequelize.Op.or]: [
                            {
                                hora_inicio: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                            },
                            {
                                hora_fin: { [sequelize.Op.between]: [hora_inicio, hora_fin] }
                            },
                            {
                                [sequelize.Op.and]: [
                                    { hora_inicio: { [sequelize.Op.lte]: hora_inicio } },
                                    { hora_fin: { [sequelize.Op.gte]: hora_fin } }
                                ]
                            }
                        ]
                    }
                });
                
                if (solapamiento) {
                    return res.status(400).json({
                        success: false,
                        message: 'La disponibilidad se solapa con otro horario configurado'
                    });
                }
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...disponibilidad.toJSON() };
            
            await disponibilidad.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'disponibilidad', 'Actualizar disponibilidad', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Disponibilidad actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(disponibilidad.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad actualizada exitosamente',
                data: disponibilidad
            });
            
        } catch (error) {
            console.error('Error en actualizarDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar disponibilidad'
            });
        }
    }
    
    static async desactivarDisponibilidad(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const disponibilidad = await Disponibilidad.findByPk(id);
            
            if (!disponibilidad) {
                return res.status(404).json({
                    success: false,
                    message: 'Disponibilidad no encontrada'
                });
            }
            
            // Verificar que el usuario es el due√±o de la disponibilidad
            if (disponibilidad.usuario_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para desactivar esta disponibilidad'
                });
            }
            
            // Verificar que no haya citas futuras en este horario
            const [citasFuturas] = await sequelize.query(`
                SELECT COUNT(*) as count FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha > CURDATE()
                AND estado IN ('programada', 'confirmada')
                AND DAYOFWEEK(fecha) = ?
                AND TIME(hora) BETWEEN ? AND ?
            `, {
                replacements: [
                    disponibilidad.usuario_id,
                    disponibilidad.usuario_id,
                    this.diaSemanaANumero(disponibilidad.dia_semana),
                    disponibilidad.hora_inicio,
                    disponibilidad.hora_fin
                ],
                type: QueryTypes.SELECT
            });
            
            if (citasFuturas.count > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se puede desactivar la disponibilidad porque hay citas programadas en este horario'
                });
            }
            
            await disponibilidad.update({ activo: false });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'modificacion', 'disponibilidad', 'Desactivar disponibilidad', ?, NOW())
            `, {
                replacements: [usuarioId, `Disponibilidad desactivada ID: ${id}`]
            });
            
            res.json({
                success: true,
                message: 'Disponibilidad desactivada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en desactivarDisponibilidad:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar disponibilidad'
            });
        }
    }
    
    static async obtenerHorariosDisponibles(req, res) {
        try {
            const { usuario_id, fecha } = req.query;
            
            if (!usuario_id || !fecha) {
                return res.status(400).json({
                    success: false,
                    message: 'Los par√°metros usuario_id y fecha son requeridos'
                });
            }
            
            // Obtener d√≠a de la semana de la fecha
            const fechaObj = new Date(fecha);
            const diaSemana = this.numeroADiaSemana(fechaObj.getDay());
            
            // Obtener disponibilidad del usuario para ese d√≠a
            const [disponibilidad] = await sequelize.query(`
                SELECT * FROM disponibilidades
                WHERE usuario_id = ?
                AND dia_semana = ?
                AND activo = TRUE
                AND (fecha_fin_vigencia IS NULL OR fecha_fin_vigencia >= ?)
                AND (fecha_inicio_vigencia <= ?)
            `, {
                replacements: [usuario_id, diaSemana, fecha, fecha],
                type: QueryTypes.SELECT
            });
            
            if (!disponibilidad) {
                return res.json({
                    success: true,
                    data: {
                        disponible: false,
                        horarios: [],
                        mensaje: 'El profesional no tiene disponibilidad para esta fecha'
                    }
                });
            }
            
            // Obtener citas ya programadas para esa fecha
            const [citasProgramadas] = await sequelize.query(`
                SELECT hora, duracion_minutos
                FROM citas
                WHERE (psicologo_id = ? OR becario_id = ?)
                AND fecha = ?
                AND estado IN ('programada', 'confirmada')
                ORDER BY hora
            `, {
                replacements: [usuario_id, usuario_id, fecha],
                type: QueryTypes.SELECT
            });
            
            // Generar horarios disponibles
            const horariosDisponibles = this.generarHorariosDisponibles(
                disponibilidad.hora_inicio,
                disponibilidad.hora_fin,
                disponibilidad.intervalo_citas,
                citasProgramadas || [],
                disponibilidad.max_citas_dia
            );
            
            res.json({
                success: true,
                data: {
                    disponible: true,
                    horarios: horariosDisponibles,
                    intervalo_minutos: disponibilidad.intervalo_citas,
                    max_citas_dia: disponibilidad.max_citas_dia,
                    citas_actuales: (citasProgramadas || []).length
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerHorariosDisponibles:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener horarios disponibles'
            });
        }
    }
    
    // M√©todos auxiliares
    static validarHora(hora) {
        const regex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
        return regex.test(hora);
    }
    
    static compararHoras(hora1, hora2) {
        const [h1, m1] = hora1.split(':').map(Number);
        const [h2, m2] = hora2.split(':').map(Number);
        
        if (h1 !== h2) return h1 - h2;
        return m1 - m2;
    }
    
    static diaSemanaANumero(diaSemana) {
        const dias = {
            'domingo': 1,
            'lunes': 2,
            'martes': 3,
            'miercoles': 4,
            'jueves': 5,
            'viernes': 6,
            'sabado': 7
        };
        return dias[diaSemana.toLowerCase()] || 1;
    }
    
    static numeroADiaSemana(numero) {
        const dias = [
            'domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'
        ];
        return dias[numero] || 'domingo';
    }
    
    static async verificarPermisoVerDisponibilidad(solicitanteId, solicitanteRol, usuarioId) {
        if (solicitanteRol === 'coordinador') return true;
        
        if (solicitanteId === parseInt(usuarioId)) return true;
        
        if (solicitanteRol === 'psicologo') {
            // Verificar si es supervisor del usuario
            const [relacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE becario_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [usuarioId, solicitanteId],
                type: QueryTypes.SELECT
            });
            
            return !!relacion;
        }
        
        return false;
    }
    
    static generarHorariosDisponibles(horaInicio, horaFin, intervalo, citasProgramadas, maxCitas) {
        const horarios = [];
        const citasPorHora = {};
        
        // Mapear citas existentes por hora
        citasProgramadas.forEach(cita => {
            const hora = cita.hora.substring(0, 5); // Formato HH:MM
            citasPorHora[hora] = true;
        });
        
        // Si ya alcanz√≥ el m√°ximo de citas, no hay horarios disponibles
        if (citasProgramadas.length >= maxCitas) {
            return horarios;
        }
        
        // Generar horarios cada X minutos
        let [hora, minuto] = horaInicio.split(':').map(Number);
        
        while (true) {
            const horaStr = `${hora.toString().padStart(2, '0')}:${minuto.toString().padStart(2, '0')}`;
            const horaFinCalculada = this.sumarMinutos(horaStr, intervalo);
            
            // Si pasa de la hora de fin, terminar
            if (this.compararHoras(horaFinCalculada, horaFin) > 0) {
                break;
            }
            
            // Si no hay cita en este horario, agregarlo
            if (!citasPorHora[horaStr]) {
                horarios.push({
                    hora: horaStr,
                    hora_fin: horaFinCalculada,
                    disponible: true
                });
            }
            
            // Avanzar intervalo
            minuto += intervalo;
            while (minuto >= 60) {
                hora += 1;
                minuto -= 60;
            }
        }
        
        return horarios;
    }
    
    static sumarMinutos(hora, minutos) {
        const [h, m] = hora.split(':').map(Number);
        let nuevaHora = h;
        let nuevosMinutos = m + minutos;
        
        while (nuevosMinutos >= 60) {
            nuevaHora += 1;
            nuevosMinutos -= 60;
        }
        
        return `${nuevaHora.toString().padStart(2, '0')}:${nuevosMinutos.toString().padStart(2, '0')}`;
    }
}

module.exports = DisponibilidadController;

/backend\src\controllers\estadisticaController.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class EstadisticaController {
    
    static async obtenerEstadisticasGenerales(req, res) {
        try {
            const { fecha_inicio, fecha_fin } = req.query;
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'WHERE fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'WHERE fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'WHERE fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estad√≠sticas de citas
            const [estadisticasCitas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) as programadas,
                    SUM(CASE WHEN estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud,
                    ROUND(SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_cancelacion,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    ROUND(AVG(duracion_minutos), 1) as duracion_promedio
                FROM citas
                ${condicionesFecha}
            `, { replacements, type: QueryTypes.SELECT });
            
            // Estad√≠sticas de pacientes
            const [estadisticasPacientes] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_pacientes,
                    SUM(CASE WHEN activo = TRUE THEN 1 ELSE 0 END) as pacientes_activos,
                    SUM(CASE WHEN activo = FALSE THEN 1 ELSE 0 END) as pacientes_inactivos,
                    COUNT(DISTINCT genero) as generos_unicos,
                    ROUND(AVG(YEAR(CURDATE()) - YEAR(fecha_nacimiento)), 1) as edad_promedio,
                    (SELECT COUNT(*) FROM altas ${condicionesFecha.replace('fecha', 'fecha_alta')}) as altas_totales
                FROM pacientes
            `, { replacements, type: QueryTypes.SELECT });
            
            // Distribuci√≥n por g√©nero
            const distribucionGenero = await sequelize.query(`
                SELECT 
                    COALESCE(genero, 'no especificado') as genero,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM pacientes
                GROUP BY genero
                ORDER BY cantidad DESC
            `, { type: QueryTypes.SELECT });
            
            // Evoluci√≥n mensual
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha, '%Y-%m') as mes,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos
                FROM citas
                ${condicionesFecha ? condicionesFecha.replace('fecha', 'fecha') : 'WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 12
            `, { replacements, type: QueryTypes.SELECT });
            
            // Top psic√≥logos por productividad
            const topPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    u.especialidad,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id ${condicionesFecha ? `AND ${condicionesFecha.replace('WHERE', '')}` : ''}
                WHERE u.rol = 'psicologo' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido, u.especialidad
                ORDER BY citas_completadas DESC
                LIMIT 10
            `, { replacements, type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    citas: estadisticasCitas,
                    pacientes: estadisticasPacientes,
                    distribucion_genero: distribucionGenero,
                    evolucion_mensual: evolucionMensual.reverse(),
                    top_psicologos: topPsicologos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasGenerales:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas generales'
            });
        }
    }
    
    static async obtenerEstadisticasPsicologo(req, res) {
        try {
            const { psicologo_id, fecha_inicio, fecha_fin } = req.query;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            let psicologoConsulta = psicologo_id;
            if (!psicologoConsulta && usuarioRol === 'psicologo') {
                psicologoConsulta = usuarioId;
            } else if (!psicologoConsulta) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere especificar un psic√≥logo'
                });
            }
            
            // Verificar que el psic√≥logo existe
            const [psicologo] = await sequelize.query(
                'SELECT id, nombre, apellido, especialidad FROM users WHERE id = ? AND rol = "psicologo"',
                { replacements: [psicologoConsulta], type: QueryTypes.SELECT }
            );
            
            if (!psicologo) {
                return res.status(404).json({
                    success: false,
                    message: 'Psic√≥logo no encontrado'
                });
            }
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [psicologoConsulta];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'AND c.fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'AND c.fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'AND c.fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estad√≠sticas generales del psic√≥logo
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE psicologo_id = ? AND estado = 'activa') as pacientes_activos,
                    
                    -- Sesiones
                    COUNT(s.id) as sesiones_registradas,
                    ROUND(AVG(TIMESTAMPDIFF(MINUTE, s.hora_inicio, s.hora_fin)), 1) as duracion_promedio_sesiones,
                    
                    -- Becarios supervisados
                    COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                    
                    -- Observaciones
                    COUNT(ob.id) as observaciones_realizadas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion_observaciones,
                    
                    -- Altas
                    COUNT(al.id) as altas_realizadas,
                    SUM(CASE WHEN al.tipo_alta = 'terapeutica' THEN 1 ELSE 0 END) as altas_terapeuticas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id ${condicionesFecha}
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
                LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id
                LEFT JOIN altas al ON u.id = al.usuario_id ${condicionesFecha.replace('c.fecha', 'al.fecha_alta')}
                WHERE u.id = ?
                GROUP BY u.id
            `, { replacements, type: QueryTypes.SELECT });
            
            // Evoluci√≥n mensual
            const evolucionMensual = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    COUNT(s.id) as sesiones_registradas,
                    COUNT(al.id) as altas_realizadas
                FROM citas c
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN altas al ON c.paciente_id = al.paciente_id AND DATE_FORMAT(al.fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')
                WHERE c.psicologo_id = ?
                ${condicionesFecha ? condicionesFecha : 'AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [psicologoConsulta, ...(condicionesFecha ? replacements.slice(1) : [])], type: QueryTypes.SELECT });
            
            // Distribuci√≥n por tipo de consulta
            const distribucionConsulta = await sequelize.query(`
                SELECT 
                    c.tipo_consulta,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM citas c
                WHERE c.psicologo_id = ?
                ${condicionesFecha}
                GROUP BY c.tipo_consulta
                ORDER BY cantidad DESC
            `, { replacements, type: QueryTypes.SELECT });
            
            // Pacientes con m√°s sesiones
            const pacientesTop = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    COUNT(c.id) as total_sesiones,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    AVG(c.duracion_minutos) as duracion_promedio
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.psicologo_id = ?
                AND c.estado = 'completada'
                ${condicionesFecha}
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY total_sesiones DESC
                LIMIT 10
            `, { replacements, type: QueryTypes.SELECT });
            
            // Horarios m√°s productivos
            const horariosProductivos = await sequelize.query(`
                SELECT 
                    HOUR(c.hora) as hora,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE c.psicologo_id = ?
                ${condicionesFecha}
                GROUP BY HOUR(c.hora)
                ORDER BY total_citas DESC
                LIMIT 8
            `, { replacements, type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    psicologo,
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    estadisticas: estadisticas || {},
                    evolucion_mensual: evolucionMensual.reverse(),
                    distribucion_consulta: distribucionConsulta,
                    pacientes_top: pacientesTop,
                    horarios_productivos: horariosProductivos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasPsicologo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas del psic√≥logo'
            });
        }
    }
    
    static async obtenerEstadisticasBecario(req, res) {
        try {
            const { becario_id, fecha_inicio, fecha_fin } = req.query;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            let becarioConsulta = becario_id;
            if (!becarioConsulta && usuarioRol === 'becario') {
                becarioConsulta = usuarioId;
            } else if (!becarioConsulta) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere especificar un becario'
                });
            }
            
            // Verificar que el becario existe
            const [becario] = await sequelize.query(
                'SELECT id, nombre, apellido FROM users WHERE id = ? AND rol = "becario"',
                { replacements: [becarioConsulta], type: QueryTypes.SELECT }
            );
            
            if (!becario) {
                return res.status(404).json({
                    success: false,
                    message: 'Becario no encontrado'
                });
            }
            
            // Construir condiciones de fecha
            let condicionesFecha = '';
            const replacements = [becarioConsulta];
            
            if (fecha_inicio && fecha_fin) {
                condicionesFecha = 'AND c.fecha BETWEEN ? AND ?';
                replacements.push(fecha_inicio, fecha_fin);
            } else if (fecha_inicio) {
                condicionesFecha = 'AND c.fecha >= ?';
                replacements.push(fecha_inicio);
            } else if (fecha_fin) {
                condicionesFecha = 'AND c.fecha <= ?';
                replacements.push(fecha_fin);
            }
            
            // Estad√≠sticas generales del becario
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    (SELECT COUNT(DISTINCT paciente_id) FROM asignaciones WHERE becario_id = ? AND estado = 'activa') as pacientes_activos,
                    
                    -- Observaciones recibidas
                    COUNT(ob.id) as observaciones_recibidas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    
                    -- Supervisor
                    (SELECT CONCAT(u.nombre, ' ', u.apellido) FROM asignaciones a 
                     JOIN users u ON a.psicologo_id = u.id 
                     WHERE a.becario_id = ? AND a.estado = 'activa' LIMIT 1) as supervisor,
                    
                    -- Disponibilidad
                    (SELECT COUNT(*) FROM disponibilidades WHERE usuario_id = ? AND activo = TRUE) as horarios_configurados,
                    
                    -- Tiempo promedio entre citas
                    ROUND(AVG(DATEDIFF(
                        (SELECT MIN(c2.fecha) FROM citas c2 
                         WHERE c2.becario_id = c.becario_id 
                         AND c2.paciente_id = c.paciente_id 
                         AND c2.id > c.id),
                        c.fecha
                    )), 1) as dias_promedio_entre_citas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.becario_id ${condicionesFecha}
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                WHERE u.id = ?
                GROUP BY u.id
            `, { replacements: [...replacements, becarioConsulta, becarioConsulta], type: QueryTypes.SELECT });
            
            // Evoluci√≥n de calificaciones
            const evolucionCalificaciones = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(ob.fecha, '%Y-%m') as mes,
                    COUNT(ob.id) as total_observaciones,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima
                FROM observaciones_becarios ob
                WHERE ob.becario_id = ?
                ${condicionesFecha ? condicionesFecha.replace('c.fecha', 'ob.fecha') : 'AND ob.fecha >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)'}
                GROUP BY DATE_FORMAT(ob.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [becarioConsulta, ...(condicionesFecha ? replacements.slice(1) : [])], type: QueryTypes.SELECT });
            
            // Distribuci√≥n por aspecto evaluado
            const distribucionAspectos = await sequelize.query(`
                SELECT 
                    ob.aspecto_evaluado,
                    COUNT(*) as cantidad,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM observaciones_becarios ob
                WHERE ob.becario_id = ?
                ${condicionesFecha ? condicionesFecha.replace('c.fecha', 'ob.fecha') : ''}
                GROUP BY ob.aspecto_evaluado
                ORDER BY cantidad DESC
            `, { replacements, type: QueryTypes.SELECT });
            
            // Citas por d√≠a de la semana
            const citasPorDia = await sequelize.query(`
                SELECT 
                    DAYNAME(c.fecha) as dia_semana,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE c.becario_id = ?
                ${condicionesFecha}
                GROUP BY DAYNAME(c.fecha), DAYOFWEEK(c.fecha)
                ORDER BY DAYOFWEEK(c.fecha)
            `, { replacements, type: QueryTypes.SELECT });
            
            // Pacientes atendidos
            const pacientesAtendidos = await sequelize.query(`
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente,
                    COUNT(c.id) as total_sesiones,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    (SELECT COUNT(*) FROM sesiones s 
                     JOIN citas c2 ON s.cita_id = c2.id 
                     WHERE c2.paciente_id = p.id AND c2.becario_id = ?) as sesiones_registradas
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.becario_id = ?
                AND c.estado = 'completada'
                ${condicionesFecha}
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY total_sesiones DESC
                LIMIT 10
            `, { replacements: [becarioConsulta, ...replacements], type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    becario,
                    periodo: {
                        fecha_inicio: fecha_inicio || 'No especificado',
                        fecha_fin: fecha_fin || 'No especificado'
                    },
                    estadisticas: estadisticas || {},
                    evolucion_calificaciones: evolucionCalificaciones.reverse(),
                    distribucion_aspectos: distribucionAspectos,
                    citas_por_dia: citasPorDia,
                    pacientes_atendidos: pacientesAtendidos,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas del becario'
            });
        }
    }
    
    static async obtenerEstadisticasPaciente(req, res) {
        try {
            const { paciente_id } = req.params;
            
            // Verificar que el paciente existe
            const [paciente] = await sequelize.query(
                'SELECT id, nombre, apellido, fecha_nacimiento, genero FROM pacientes WHERE id = ?',
                { replacements: [paciente_id], type: QueryTypes.SELECT }
            );
            
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Estad√≠sticas del paciente
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_asistencia,
                    
                    -- Tiempo
                    MIN(c.fecha) as primera_cita,
                    MAX(c.fecha) as ultima_cita,
                    DATEDIFF(MAX(c.fecha), MIN(c.fecha)) as dias_tratamiento,
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                    
                    -- Profesionales
                    COUNT(DISTINCT c.psicologo_id) as psicologos_atendieron,
                    COUNT(DISTINCT c.becario_id) as becarios_atendieron,
                    
                    -- Sesiones registradas
                    COUNT(s.id) as sesiones_registradas,
                    
                    -- Asignaciones
                    COUNT(DISTINCT a.id) as total_asignaciones,
                    (SELECT COUNT(*) FROM asignaciones WHERE paciente_id = ? AND estado = 'activa') as asignaciones_activas,
                    
                    -- Altas
                    (SELECT tipo_alta FROM altas WHERE paciente_id = ? ORDER BY fecha_alta DESC LIMIT 1) as ultimo_tipo_alta
                    
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON p.id = a.paciente_id
                WHERE p.id = ?
                GROUP BY p.id
            `, { replacements: [paciente_id, paciente_id, paciente_id], type: QueryTypes.SELECT });
            
            // Evoluci√≥n de citas
            const evolucionCitas = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    GROUP_CONCAT(
                        CONCAT(
                            DAY(c.fecha), ': ',
                            CASE c.estado 
                                WHEN 'completada' THEN '‚úì'
                                WHEN 'cancelada' THEN '‚úó'
                                ELSE '‚óã'
                            END
                        ) 
                        ORDER BY c.fecha 
                        SEPARATOR ', '
                    ) as detalle_dias
                FROM citas c
                WHERE c.paciente_id = ?
                GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
                ORDER BY mes DESC
                LIMIT 6
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            // Distribuci√≥n por psic√≥logo
            const distribucionPsicologos = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    u.especialidad,
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    MIN(c.fecha) as primera_cita,
                    MAX(c.fecha) as ultima_cita
                FROM citas c
                JOIN users u ON c.psicologo_id = u.id
                WHERE c.paciente_id = ?
                GROUP BY u.id, u.nombre, u.apellido, u.especialidad
                ORDER BY total_citas DESC
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            // Frecuencia de citas
            const frecuenciaCitas = await sequelize.query(`
                SELECT 
                    CONCAT(
                        CASE 
                            WHEN dias BETWEEN 0 AND 7 THEN '1 semana o menos'
                            WHEN dias BETWEEN 8 AND 14 THEN '2 semanas'
                            WHEN dias BETWEEN 15 AND 21 THEN '3 semanas'
                            WHEN dias BETWEEN 22 AND 30 THEN '4 semanas'
                            ELSE 'M√°s de 1 mes'
                        END
                    ) as intervalo,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM (
                    SELECT 
                        DATEDIFF(
                            c2.fecha,
                            (SELECT MAX(c3.fecha) FROM citas c3 
                             WHERE c3.paciente_id = c.paciente_id 
                             AND c3.id < c2.id)
                        ) as dias
                    FROM citas c2
                    WHERE c2.paciente_id = ?
                    AND c2.estado = 'completada'
                    ORDER BY c2.fecha
                ) as intervalos
                WHERE dias IS NOT NULL
                GROUP BY 
                    CASE 
                        WHEN dias BETWEEN 0 AND 7 THEN '1 semana o menos'
                        WHEN dias BETWEEN 8 AND 14 THEN '2 semanas'
                        WHEN dias BETWEEN 15 AND 21 THEN '3 semanas'
                        WHEN dias BETWEEN 22 AND 30 THEN '4 semanas'
                        ELSE 'M√°s de 1 mes'
                    END
                ORDER BY cantidad DESC
            `, { replacements: [paciente_id], type: QueryTypes.SELECT });
            
            res.json({
                success: true,
                data: {
                    paciente,
                    estadisticas: estadisticas || {},
                    evolucion_citas: evolucionCitas.reverse(),
                    distribucion_psicologos: distribucionPsicologos,
                    frecuencia_citas: frecuenciaCitas,
                    fecha_consulta: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerEstadisticasPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener estad√≠sticas del paciente'
            });
        }
    }
    
    static async obtenerReporteComparativo(req, res) {
        try {
            const { periodo = 'mes', tipo_comparacion = 'psicologos' } = req.query;
            
            let intervalo;
            switch (periodo) {
                case 'semana':
                    intervalo = 'INTERVAL 7 DAY';
                    break;
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            let reporte;
            
            if (tipo_comparacion === 'psicologos') {
                reporte = await this.generarComparativoPsicologos(intervalo);
            } else if (tipo_comparacion === 'becarios') {
                reporte = await this.generarComparativoBecarios(intervalo);
            } else if (tipo_comparacion === 'meses') {
                reporte = await this.generarComparativoMeses(intervalo);
            } else {
                return res.status(400).json({
                    success: false,
                    message: 'Tipo de comparaci√≥n no v√°lido'
                });
            }
            
            res.json({
                success: true,
                data: {
                    tipo_comparacion,
                    periodo,
                    reporte,
                    fecha_generacion: new Date().toISOString()
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerReporteComparativo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte comparativo'
            });
        }
    }
    
    // M√©todos auxiliares para comparativos
    static async generarComparativoPsicologos(intervalo) {
        return await sequelize.query(`
            SELECT 
                u.id,
                CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                u.especialidad,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                COUNT(s.id) as sesiones_registradas,
                COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                COUNT(ob.id) as observaciones_realizadas
            FROM users u
            LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            LEFT JOIN sesiones s ON c.id = s.cita_id
            LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
            LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id AND ob.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            WHERE u.rol = 'psicologo' AND u.activo = TRUE
            GROUP BY u.id, u.nombre, u.apellido, u.especialidad
            ORDER BY citas_completadas DESC
        `, { type: QueryTypes.SELECT });
    }
    
    static async generarComparativoBecarios(intervalo) {
        return await sequelize.query(`
            SELECT 
                u.id,
                CONCAT(u.nombre, ' ', u.apellido) as becario,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                COUNT(ob.id) as observaciones_recibidas,
                ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                (SELECT CONCAT(u2.nombre, ' ', u2.apellido) FROM asignaciones a 
                 JOIN users u2 ON a.psicologo_id = u2.id 
                 WHERE a.becario_id = u.id AND a.estado = 'activa' LIMIT 1) as supervisor
            FROM users u
            LEFT JOIN citas c ON u.id = c.becario_id AND c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id AND ob.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            WHERE u.rol = 'becario' AND u.activo = TRUE
            GROUP BY u.id, u.nombre, u.apellido
            ORDER BY citas_completadas DESC
        `, { type: QueryTypes.SELECT });
    }
    
    static async generarComparativoMeses(intervalo) {
        return await sequelize.query(`
            SELECT 
                DATE_FORMAT(c.fecha, '%Y-%m') as mes,
                COUNT(c.id) as total_citas,
                SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                COUNT(DISTINCT c.psicologo_id) as psicologos_activos,
                COUNT(DISTINCT c.becario_id) as becarios_activos,
                COUNT(s.id) as sesiones_registradas,
                COUNT(a.id) as altas_realizadas
            FROM citas c
            LEFT JOIN sesiones s ON c.id = s.cita_id
            LEFT JOIN altas a ON c.paciente_id = a.paciente_id AND DATE_FORMAT(a.fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')
            WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})
            GROUP BY DATE_FORMAT(c.fecha, '%Y-%m')
            ORDER BY mes DESC
        `, { type: QueryTypes.SELECT });
    }
}

module.exports = EstadisticaController;

/backend\src\controllers\expedienteController.js:
--------------------------------------------------------------------------------
const Expediente = require('../models/expedienteModel');
const Paciente = require('../models/pacienteModel');
const Sesion = require('../models/sesionModel');
const Cita = require('../models/citaModel');
const Asignacion = require('../models/asignacionModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class ExpedienteController {
    
    static async obtenerExpedienteCompleto(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tieneAcceso = await this.verificarAccesoExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para acceder a este expediente'
                });
            }
            
            // Obtener informaci√≥n b√°sica del paciente
            const paciente = await Paciente.findByPk(paciente_id, {
                attributes: { exclude: ['password'] }
            });
            
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Obtener expediente cl√≠nico
            const expediente = await Expediente.findOne({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    }
                ]
            });
            
            // Obtener asignaci√≥n actual
            const asignacion = await Asignacion.findOne({
                where: {
                    paciente_id,
                    estado: 'activa'
                },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    }
                ]
            });
            
            // Obtener historial de sesiones
            const sesiones = await Sesion.findAll({
                where: { '$Cita.paciente_id$': paciente_id },
                include: [
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora', 'tipo_consulta']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha', 'DESC'], ['hora_inicio', 'DESC']],
                limit: 20
            });
            
            // Obtener citas futuras
            const citasFuturas = await Cita.findAll({
                where: {
                    paciente_id,
                    fecha: { [sequelize.Op.gte]: new Date().toISOString().split('T')[0] },
                    estado: { [sequelize.Op.in]: ['programada', 'confirmada'] }
                },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha', 'ASC'], ['hora', 'ASC']]
            });
            
            // Obtener estad√≠sticas
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(*) as total_sesiones,
                    COUNT(CASE WHEN c.estado = 'completada' THEN 1 END) as sesiones_completadas,
                    COUNT(CASE WHEN c.estado = 'cancelada' THEN 1 END) as sesiones_canceladas,
                    MIN(c.fecha) as primera_sesion,
                    MAX(c.fecha) as ultima_sesion,
                    AVG(TIMESTAMPDIFF(MINUTE, s.hora_inicio, s.hora_fin)) as duracion_promedio
                FROM citas c
                LEFT JOIN sesiones s ON c.id = s.cita_id
                WHERE c.paciente_id = ?
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Obtener historial de asignaciones
            const historialAsignaciones = await Asignacion.findAll({
                where: { paciente_id },
                include: [
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['id', 'nombre', 'apellido']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido']
                    }
                ],
                order: [['fecha_inicio', 'DESC']]
            });
            
            // Obtener altas si las hay
            const [altas] = await sequelize.query(`
                SELECT * FROM altas WHERE paciente_id = ? ORDER BY fecha_alta DESC LIMIT 1
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    paciente,
                    expediente: expediente || {},
                    asignacion_actual: asignacion || null,
                    sesiones,
                    citas_futuras: citasFuturas,
                    estadisticas: estadisticas || {},
                    historial_asignaciones: historialAsignaciones,
                    alta: altas || null
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerExpedienteCompleto:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener expediente completo'
            });
        }
    }
    
    static async crearExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const expedienteData = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el paciente existe
            const paciente = await Paciente.findByPk(paciente_id);
            if (!paciente) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            // Verificar que no exista ya un expediente
            const expedienteExistente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (expedienteExistente) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe un expediente para este paciente'
                });
            }
            
            // Crear expediente
            const expediente = await Expediente.create({
                paciente_id,
                ...expedienteData
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'expedientes', 'Crear expediente', ?, NOW())
            `, {
                replacements: [usuarioId, `Expediente creado para paciente ${paciente_id}`]
            });
            
            res.json({
                success: true,
                message: 'Expediente creado exitosamente',
                data: expediente
            });
            
        } catch (error) {
            console.error('Error en crearExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear expediente'
            });
        }
    }
    
    static async actualizarExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const puedeActualizar = await this.verificarPermisoActualizarExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!puedeActualizar) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar este expediente'
                });
            }
            
            const expediente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (!expediente) {
                return res.status(404).json({
                    success: false,
                    message: 'Expediente no encontrado'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...expediente.toJSON() };
            
            await expediente.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'expedientes', 'Actualizar expediente', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Expediente actualizado para paciente ${paciente_id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(expediente.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Expediente actualizado exitosamente',
                data: expediente
            });
            
        } catch (error) {
            console.error('Error en actualizarExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar expediente'
            });
        }
    }
    
    static async agregarNotaConfidencial(req, res) {
        try {
            const { paciente_id } = req.params;
            const { nota } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que el usuario es psic√≥logo asignado
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [paciente_id, usuarioId],
                type: QueryTypes.SELECT
            });
            
            if (!asignacion && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'Solo el psic√≥logo asignado puede agregar notas confidenciales'
                });
            }
            
            const expediente = await Expediente.findOne({
                where: { paciente_id }
            });
            
            if (!expediente) {
                return res.status(404).json({
                    success: false,
                    message: 'Expediente no encontrado'
                });
            }
            
            // Agregar nota con timestamp
            const fecha = new Date().toLocaleString('es-MX');
            const nuevaNota = `[${fecha}] ${usuarioId}: ${nota}\n\n`;
            const notasActuales = expediente.notas_confidenciales || '';
            
            await expediente.update({
                notas_confidenciales: nuevaNota + notasActuales
            });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'modificacion', 'expedientes', 'Agregar nota confidencial', ?, NOW())
            `, {
                replacements: [usuarioId, `Nota confidencial agregada para paciente ${paciente_id}`]
            });
            
            res.json({
                success: true,
                message: 'Nota confidencial agregada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en agregarNotaConfidencial:', error);
            res.status(500).json({
                success: false,
                message: 'Error al agregar nota confidencial'
            });
        }
    }
    
    static async obtenerResumenExpediente(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos b√°sicos
            const tieneAcceso = await this.verificarAccesoExpediente(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para acceder a este expediente'
                });
            }
            
            const [resumen] = await sequelize.query(`
                SELECT 
                    p.id,
                    p.nombre,
                    p.apellido,
                    p.fecha_nacimiento,
                    p.genero,
                    p.telefono,
                    p.email,
                    p.estado,
                    e.motivo_consulta,
                    e.diagnostico_presuntivo,
                    e.riesgo_suicida,
                    a.psicologo_id,
                    u_psi.nombre as psicologo_nombre,
                    u_psi.apellido as psicologo_apellido,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'completada') as sesiones_completadas,
                    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'programada' AND fecha >= CURDATE()) as citas_pendientes,
                    (SELECT MAX(fecha) FROM citas WHERE paciente_id = p.id AND estado = 'completada') as ultima_sesion
                FROM pacientes p
                LEFT JOIN expedientes e ON p.id = e.paciente_id
                LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
                LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
                WHERE p.id = ?
            `, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            if (!resumen) {
                return res.status(404).json({
                    success: false,
                    message: 'Paciente no encontrado'
                });
            }
            
            res.json({
                success: true,
                data: resumen
            });
            
        } catch (error) {
            console.error('Error en obtenerResumenExpediente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener resumen de expediente'
            });
        }
    }
    
    // M√©todos auxiliares
    static async verificarAccesoExpediente(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        // Verificar si el usuario est√° asignado al paciente
        const [asignacion] = await sequelize.query(`
            SELECT 1 FROM asignaciones 
            WHERE paciente_id = ? 
            AND estado = 'activa'
            AND (psicologo_id = ? OR becario_id = ?)
        `, {
            replacements: [pacienteId, usuarioId, usuarioId],
            type: QueryTypes.SELECT
        });
        
        return !!asignacion;
    }
    
    static async verificarPermisoActualizarExpediente(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            // Verificar si es el psic√≥logo asignado
            const [asignacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE paciente_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
            `, {
                replacements: [pacienteId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!asignacion;
        }
        
        return false;
    }
}

module.exports = ExpedienteController;

/backend\src\controllers\fundacionController.js:
--------------------------------------------------------------------------------
const Fundacion = require('../models/fundacionModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class FundacionController {
    
    static async crearFundacion(req, res) {
        try {
            const fundacionData = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.create(fundacionData);
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                 VALUES (?, 'creacion', 'fundaciones', 'Crear fundaci√≥n', ?, NOW())`,
                { replacements: [usuarioId, `Nueva fundaci√≥n: ${fundacion.nombre}`] }
            );
            
            res.json({
                success: true,
                message: 'Fundaci√≥n creada exitosamente',
                data: fundacion
            });
            
        } catch (error) {
            console.error('Error en crearFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear fundaci√≥n',
                error: error.message
            });
        }
    }
    
    static async obtenerFundaciones(req, res) {
        try {
            const { activo } = req.query;
            const whereClause = {};
            
            if (activo !== undefined) {
                whereClause.activo = activo === 'true';
            }
            
            const fundaciones = await Fundacion.findAll({
                where: whereClause,
                order: [['nombre', 'ASC']]
            });
            
            res.json({
                success: true,
                data: fundaciones,
                count: fundaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerFundaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener fundaciones'
            });
        }
    }
    
    static async obtenerFundacion(req, res) {
        try {
            const { id } = req.params;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundaci√≥n no encontrada'
                });
            }
            
            // Obtener estad√≠sticas de la fundaci√≥n
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    COUNT(DISTINCT p.id) AS total_pacientes,
                    COUNT(DISTINCT u.id) AS total_profesionales,
                    COUNT(DISTINCT c.id) AS citas_mes_actual,
                    (SELECT COUNT(*) FROM altas a 
                     JOIN pacientes p ON a.paciente_id = p.id 
                     WHERE p.fundacion_id = :fundacionId 
                     AND MONTH(a.fecha_alta) = MONTH(CURDATE())) AS altas_mes_actual
                FROM fundaciones f
                LEFT JOIN pacientes p ON f.id = p.fundacion_id AND p.activo = TRUE
                LEFT JOIN users u ON f.id = u.fundacion_id AND u.activo = TRUE
                LEFT JOIN citas c ON p.id = c.paciente_id 
                    AND MONTH(c.fecha) = MONTH(CURDATE())
                WHERE f.id = :fundacionId
                GROUP BY f.id
            `, {
                replacements: { fundacionId: id },
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: {
                    fundacion: fundacion,
                    estadisticas: estadisticas || {}
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener fundaci√≥n'
            });
        }
    }
    
    static async actualizarFundacion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundaci√≥n no encontrada'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...fundacion.toJSON() };
            
            await fundacion.update(updates);
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                 VALUES (?, 'modificacion', 'fundaciones', 'Actualizar fundaci√≥n', ?, ?, ?, NOW())`,
                { 
                    replacements: [
                        usuarioId, 
                        `Fundaci√≥n actualizada: ${fundacion.nombre}`,
                        JSON.stringify(datosAntes),
                        JSON.stringify(fundacion.toJSON())
                    ] 
                }
            );
            
            res.json({
                success: true,
                message: 'Fundaci√≥n actualizada exitosamente',
                data: fundacion
            });
            
        } catch (error) {
            console.error('Error en actualizarFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar fundaci√≥n'
            });
        }
    }
    
    static async desactivarFundacion(req, res) {
        try {
            const { id } = req.params;
            const { motivo } = req.body;
            const usuarioId = req.user.id;
            
            const fundacion = await Fundacion.findByPk(id);
            
            if (!fundacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Fundaci√≥n no encontrada'
                });
            }
            
            // Verificar que no haya pacientes activos
            const [pacientesActivos] = await sequelize.query(
                `SELECT COUNT(*) as count FROM pacientes WHERE fundacion_id = ? AND activo = TRUE`,
                { replacements: [id], type: QueryTypes.SELECT }
            );
            
            if (pacientesActivos.count > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se puede desactivar la fundaci√≥n porque tiene pacientes activos'
                });
            }
            
            await fundacion.update({ activo: false });
            
            // Log
            await sequelize.query(
                `INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                 VALUES (?, 'modificacion', 'fundaciones', 'Desactivar fundaci√≥n', ?, NOW())`,
                { 
                    replacements: [
                        usuarioId, 
                        `Fundaci√≥n desactivada: ${fundacion.nombre}. Motivo: ${motivo}`
                    ] 
                }
            );
            
            res.json({
                success: true,
                message: 'Fundaci√≥n desactivada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en desactivarFundacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al desactivar fundaci√≥n'
            });
        }
    }
}

module.exports = FundacionController;

/backend\src\controllers\notificacionController.js:
--------------------------------------------------------------------------------
const Notificacion = require('../models/notificacionModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class NotificacionController {
    
    static async obtenerMisNotificaciones(req, res) {
        try {
            const usuarioId = req.user.id;
            const { leido, limit = 50, offset = 0 } = req.query;
            
            const whereClause = { usuario_id: usuarioId };
            
            if (leido !== undefined) {
                whereClause.leido = leido === 'true';
            }
            
            const notificaciones = await Notificacion.findAll({
                where: whereClause,
                order: [['created_at', 'DESC']],
                limit: parseInt(limit),
                offset: parseInt(offset)
            });
            
            // Contar no le√≠das
            const countNoLeidas = await Notificacion.count({
                where: { usuario_id: usuarioId, leido: false }
            });
            
            res.json({
                success: true,
                data: notificaciones,
                count: notificaciones.length,
                countNoLeidas,
                total: await Notificacion.count({ where: { usuario_id: usuarioId } })
            });
            
        } catch (error) {
            console.error('Error en obtenerMisNotificaciones:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener notificaciones'
            });
        }
    }
    
    static async marcarComoLeido(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const notificacion = await Notificacion.findOne({
                where: { id, usuario_id: usuarioId }
            });
            
            if (!notificacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Notificaci√≥n no encontrada'
                });
            }
            
            await notificacion.update({
                leido: true,
                leido_at: new Date()
            });
            
            res.json({
                success: true,
                message: 'Notificaci√≥n marcada como le√≠da'
            });
            
        } catch (error) {
            console.error('Error en marcarComoLeido:', error);
            res.status(500).json({
                success: false,
                message: 'Error al marcar notificaci√≥n como le√≠da'
            });
        }
    }
    
    static async marcarTodasComoLeidas(req, res) {
        try {
            const usuarioId = req.user.id;
            
            await Notificacion.update(
                { leido: true, leido_at: new Date() },
                { where: { usuario_id: usuarioId, leido: false } }
            );
            
            res.json({
                success: true,
                message: 'Todas las notificaciones marcadas como le√≠das'
            });
            
        } catch (error) {
            console.error('Error en marcarTodasComoLeidas:', error);
            res.status(500).json({
                success: false,
                message: 'Error al marcar notificaciones como le√≠das'
            });
        }
    }
    
    static async crearNotificacion(req, res) {
        try {
            const { usuario_id, tipo, titulo, mensaje, prioridad, datos_extra } = req.body;
            const creadorId = req.user.id;
            
            // Validar que el usuario receptor existe
            const [usuario] = await sequelize.query(
                'SELECT id FROM users WHERE id = ? AND activo = TRUE',
                { replacements: [usuario_id], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario receptor no encontrado o inactivo'
                });
            }
            
            const notificacion = await Notificacion.create({
                usuario_id,
                tipo,
                titulo,
                mensaje,
                prioridad: prioridad || 'media',
                datos_extra: datos_extra || null
            });
            
            res.json({
                success: true,
                message: 'Notificaci√≥n creada exitosamente',
                data: notificacion
            });
            
        } catch (error) {
            console.error('Error en crearNotificacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear notificaci√≥n'
            });
        }
    }
    
    static async eliminarNotificacion(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            
            const notificacion = await Notificacion.findOne({
                where: { id, usuario_id: usuarioId }
            });
            
            if (!notificacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Notificaci√≥n no encontrada'
                });
            }
            
            await notificacion.destroy();
            
            res.json({
                success: true,
                message: 'Notificaci√≥n eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en eliminarNotificacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar notificaci√≥n'
            });
        }
    }
    
    static async obtenerNotificacionesRecientes(req, res) {
        try {
            const usuarioId = req.user.id;
            const horas = parseInt(req.query.horas) || 24;
            
            const notificaciones = await Notificacion.findAll({
                where: {
                    usuario_id: usuarioId,
                    created_at: {
                        [sequelize.Op.gte]: new Date(Date.now() - horas * 60 * 60 * 1000)
                    }
                },
                order: [['created_at', 'DESC']],
                limit: 20
            });
            
            res.json({
                success: true,
                data: notificaciones,
                count: notificaciones.length
            });
            
        } catch (error) {
            console.error('Error en obtenerNotificacionesRecientes:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener notificaciones recientes'
            });
        }
    }
    
    // M√©todo para enviar notificaci√≥n de sistema
    static async enviarNotificacionSistema(usuarioId, tipo, titulo, mensaje, datosExtra = null) {
        try {
            await Notificacion.create({
                usuario_id: usuarioId,
                tipo,
                titulo,
                mensaje,
                prioridad: 'media',
                datos_extra: datosExtra
            });
            
            return true;
        } catch (error) {
            console.error('Error al enviar notificaci√≥n de sistema:', error);
            return false;
        }
    }
}

module.exports = NotificacionController;

/backend\src\controllers\observacionController.js:
--------------------------------------------------------------------------------
const ObservacionBecario = require('../models/observacionBecarioModel');
const User = require('../models/userModel');
const Cita = require('../models/citaModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class ObservacionController {
    
    static async crearObservacion(req, res) {
        try {
            const { becario_id, cita_id, tipo_observacion, aspecto_evaluado, 
                    calificacion, fortalezas, areas_mejora, recomendaciones, 
                    plan_accion, fecha_seguimiento, privada } = req.body;
            const supervisorId = req.user.id;
            
            // Verificar que el supervisor es psic√≥logo o coordinador
            const supervisor = await User.findByPk(supervisorId);
            if (!['psicologo', 'coordinador'].includes(supervisor.rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo psic√≥logos y coordinadores pueden crear observaciones'
                });
            }
            
            // Verificar que el becario existe y es becario
            const becario = await User.findOne({
                where: { id: becario_id, rol: 'becario', activo: true }
            });
            
            if (!becario) {
                return res.status(404).json({
                    success: false,
                    message: 'Becario no encontrado o inactivo'
                });
            }
            
            // Verificar que la cita existe si se especifica
            if (cita_id) {
                const cita = await Cita.findByPk(cita_id);
                if (!cita) {
                    return res.status(404).json({
                        success: false,
                        message: 'Cita no encontrada'
                    });
                }
                
                // Verificar que el becario est√° asignado a la cita
                if (cita.becario_id !== parseInt(becario_id)) {
                    return res.status(400).json({
                        success: false,
                        message: 'El becario no est√° asignado a esta cita'
                    });
                }
            }
            
            // Crear observaci√≥n
            const observacion = await ObservacionBecario.create({
                becario_id,
                supervisor_id: supervisorId,
                cita_id,
                fecha: new Date().toISOString().split('T')[0],
                tipo_observacion,
                aspecto_evaluado,
                calificacion,
                fortalezas,
                areas_mejora,
                recomendaciones,
                plan_accion,
                fecha_seguimiento,
                privada: privada || false
            });
            
            // Notificar al becario
            await sequelize.query(`
                INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                VALUES (?, 'observacion_nueva', 'Nueva observaci√≥n', 
                'Tienes una nueva observaci√≥n de tu supervisor. Revisa tu panel para m√°s detalles.', NOW())
            `, { replacements: [becario_id] });
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'observaciones', 'Crear observaci√≥n', ?, NOW())
            `, {
                replacements: [supervisorId, `Observaci√≥n creada para becario ${becario_id}`]
            });
            
            res.json({
                success: true,
                message: 'Observaci√≥n creada exitosamente',
                data: observacion
            });
            
        } catch (error) {
            console.error('Error en crearObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al crear observaci√≥n',
                error: error.message
            });
        }
    }
    
    static async obtenerObservacionesBecario(req, res) {
        try {
            const { becario_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tienePermisos = await this.verificarPermisosObservaciones(usuarioId, usuarioRol, becario_id);
            
            if (!tienePermisos) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver estas observaciones'
                });
            }
            
            const whereClause = { becario_id };
            
            // Si no es supervisor ni coordinador, solo mostrar no privadas o propias
            if (usuarioRol === 'becario' && parseInt(becario_id) !== usuarioId) {
                return res.status(403).json({
                    success: false,
                    message: 'Solo puedes ver tus propias observaciones'
                });
            }
            
            // Si es becario viendo sus propias observaciones, filtrar privadas de otros
            if (usuarioRol === 'becario') {
                whereClause.privada = false;
            }
            
            const observaciones = await ObservacionBecario.findAll({
                where: whereClause,
                include: [
                    {
                        model: User,
                        as: 'Supervisor',
                        attributes: ['id', 'nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora'],
                        include: [{
                            model: require('../models/pacienteModel'),
                            attributes: ['id', 'nombre', 'apellido']
                        }]
                    }
                ],
                order: [['fecha', 'DESC'], ['created_at', 'DESC']]
            });
            
            // Calcular promedio de calificaciones
            const promedio = observaciones.length > 0 
                ? observaciones.reduce((sum, obs) => sum + obs.calificacion, 0) / observaciones.length
                : 0;
            
            res.json({
                success: true,
                data: {
                    observaciones,
                    estadisticas: {
                        total: observaciones.length,
                        promedio: promedio.toFixed(2),
                        porAspecto: this.agruparPorAspecto(observaciones)
                    }
                }
            });
            
        } catch (error) {
            console.error('Error en obtenerObservacionesBecario:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener observaciones'
            });
        }
    }
    
    static async obtenerObservacionesSupervisor(req, res) {
        try {
            const supervisorId = req.user.id;
            const { becario_id, fecha_inicio, fecha_fin } = req.query;
            
            const whereClause = { supervisor_id: supervisorId };
            
            if (becario_id) {
                whereClause.becario_id = becario_id;
            }
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [sequelize.Op.between]: [fecha_inicio, fecha_fin]
                };
            }
            
            const observaciones = await ObservacionBecario.findAll({
                where: whereClause,
                include: [
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['id', 'nombre', 'apellido', 'email']
                    },
                    {
                        model: Cita,
                        attributes: ['id', 'fecha', 'hora']
                    }
                ],
                order: [['fecha', 'DESC']]
            });
            
            // Agrupar por becario para estad√≠sticas
            const estadisticasPorBecario = this.calcularEstadisticasPorBecario(observaciones);
            
            res.json({
                success: true,
                data: observaciones,
                estadisticas: estadisticasPorBecario
            });
            
        } catch (error) {
            console.error('Error en obtenerObservacionesSupervisor:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener observaciones'
            });
        }
    }
    
    static async actualizarObservacion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            
            const observacion = await ObservacionBecario.findByPk(id);
            
            if (!observacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Observaci√≥n no encontrada'
                });
            }
            
            // Verificar que es el supervisor creador
            if (observacion.supervisor_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'Solo el supervisor creador puede actualizar la observaci√≥n'
                });
            }
            
            // Campos que no se pueden modificar
            const camposBloqueados = ['becario_id', 'supervisor_id', 'cita_id', 'fecha'];
            for (const campo of camposBloqueados) {
                if (updates[campo]) {
                    delete updates[campo];
                }
            }
            
            if (Object.keys(updates).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos v√°lidos para actualizar'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...observacion.toJSON() };
            
            await observacion.update(updates);
            
            // Notificar al becario si hay cambios importantes
            if (updates.calificacion || updates.recomendaciones || updates.plan_accion) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'observacion_nueva', 'Observaci√≥n actualizada', 
                    'Tu supervisor ha actualizado una observaci√≥n. Revisa los cambios.', NOW())
                `, { replacements: [observacion.becario_id] });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'observaciones', 'Actualizar observaci√≥n', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Observaci√≥n actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(observacion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Observaci√≥n actualizada exitosamente',
                data: observacion
            });
            
        } catch (error) {
            console.error('Error en actualizarObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar observaci√≥n'
            });
        }
    }
    
    static async eliminarObservacion(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const observacion = await ObservacionBecario.findByPk(id);
            
            if (!observacion) {
                return res.status(404).json({
                    success: false,
                    message: 'Observaci√≥n no encontrada'
                });
            }
            
            // Solo coordinador o supervisor creador puede eliminar
            if (observacion.supervisor_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para eliminar esta observaci√≥n'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...observacion.toJSON() };
            
            await observacion.destroy();
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, created_at)
                VALUES (?, 'eliminacion', 'observaciones', 'Eliminar observaci√≥n', ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Observaci√≥n eliminada ID: ${id}`,
                    JSON.stringify(datosAntes)
                ]
            });
            
            res.json({
                success: true,
                message: 'Observaci√≥n eliminada exitosamente'
            });
            
        } catch (error) {
            console.error('Error en eliminarObservacion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al eliminar observaci√≥n'
            });
        }
    }
    
    // M√©todos auxiliares
    static async verificarPermisosObservaciones(usuarioId, usuarioRol, becarioId) {
        if (usuarioRol === 'coordinador') return true;
        
        if (usuarioRol === 'psicologo') {
            // Verificar si es supervisor del becario
            const [relacion] = await sequelize.query(`
                SELECT 1 FROM asignaciones 
                WHERE becario_id = ? 
                AND psicologo_id = ?
                AND estado = 'activa'
                LIMIT 1
            `, {
                replacements: [becarioId, usuarioId],
                type: QueryTypes.SELECT
            });
            
            return !!relacion;
        }
        
        if (usuarioRol === 'becario') {
            return parseInt(becarioId) === usuarioId;
        }
        
        return false;
    }
    
    static agruparPorAspecto(observaciones) {
        const agrupado = {};
        
        observaciones.forEach(obs => {
            if (!agrupado[obs.aspecto_evaluado]) {
                agrupado[obs.aspecto_evaluado] = {
                    total: 0,
                    suma: 0,
                    promedio: 0
                };
            }
            
            agrupado[obs.aspecto_evaluado].total++;
            agrupado[obs.aspecto_evaluado].suma += obs.calificacion;
            agrupado[obs.aspecto_evaluado].promedio = 
                agrupado[obs.aspecto_evaluado].suma / agrupado[obs.aspecto_evaluado].total;
        });
        
        return agrupado;
    }
    
    static calcularEstadisticasPorBecario(observaciones) {
        const estadisticas = {};
        
        observaciones.forEach(obs => {
            if (!estadisticas[obs.becario_id]) {
                estadisticas[obs.becario_id] = {
                    becario_id: obs.becario_id,
                    becario_nombre: obs.Becario ? `${obs.Becario.nombre} ${obs.Becario.apellido}` : 'N/A',
                    total_observaciones: 0,
                    promedio_calificacion: 0,
                    suma_calificacion: 0,
                    aspectos_evaluados: new Set(),
                    ultima_observacion: null
                };
            }
            
            const stats = estadisticas[obs.becario_id];
            stats.total_observaciones++;
            stats.suma_calificacion += obs.calificacion;
            stats.promedio_calificacion = stats.suma_calificacion / stats.total_observaciones;
            stats.aspectos_evaluados.add(obs.aspecto_evaluado);
            
            if (!stats.ultima_observacion || new Date(obs.fecha) > new Date(stats.ultima_observacion)) {
                stats.ultima_observacion = obs.fecha;
            }
        });
        
        // Convertir Set a Array
        Object.keys(estadisticas).forEach(key => {
            estadisticas[key].aspectos_evaluados = Array.from(estadisticas[key].aspectos_evaluados);
        });
        
        return estadisticas;
    }
}

module.exports = ObservacionController;

/backend\src\controllers\reporteController.js:
--------------------------------------------------------------------------------
// backend/src/controllers/reporteController.js - A√±ade este m√©todo
const { Parser } = require('json2csv');
const fs = require('fs');
const path = require('path');
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { Op } = require('sequelize');
const sequelize = require('../config/db');

class ReporteController {
    // M√©todo para exportar agenda a CSV
    static async exportarAgendaCSV(req, res) {
        try {
            const { 
                fecha_inicio, 
                fecha_fin, 
                psicologo_id, 
                tipo_consulta 
            } = req.body;

            // Construir condiciones de filtro
            const whereClause = {};
            
            if (fecha_inicio && fecha_fin) {
                whereClause.fecha = {
                    [Op.between]: [fecha_inicio, fecha_fin]
                };
            }
            
            if (psicologo_id) whereClause.psicologo_id = psicologo_id;
            if (tipo_consulta) whereClause.tipo_consulta = tipo_consulta;

            // Obtener citas con informaci√≥n relacionada
            const citas = await Cita.findAll({
                where: whereClause,
                include: [
                    {
                        model: Paciente,
                        attributes: ['nombre', 'apellido', 'telefono', 'email']
                    },
                    {
                        model: User,
                        as: 'Psicologo',
                        attributes: ['nombre', 'apellido', 'especialidad']
                    },
                    {
                        model: User,
                        as: 'Becario',
                        attributes: ['nombre', 'apellido']
                    }
                ],
                order: [
                    ['fecha', 'ASC'],
                    ['hora', 'ASC']
                ]
            });

            // Preparar datos para CSV
            const datosCSV = citas.map(cita => ({
                Fecha: cita.fecha,
                Hora: cita.hora,
                'Duraci√≥n (min)': cita.duracion,
                Paciente: cita.Paciente ? `${cita.Paciente.nombre} ${cita.Paciente.apellido}` : '',
                'Tel√©fono Paciente': cita.Paciente?.telefono || '',
                'Email Paciente': cita.Paciente?.email || '',
                Psic√≥logo: cita.Psicologo ? `${cita.Psicologo.nombre} ${cita.Psicologo.apellido}` : '',
                Especialidad: cita.Psicologo?.especialidad || '',
                Becario: cita.Becario ? `${cita.Becario.nombre} ${cita.Becario.apellido}` : '',
                'Tipo Consulta': cita.tipo_consulta === 'presencial' ? 'Presencial' : 'Virtual',
                Estado: cita.estado,
                Notas: cita.notas || '',
                'Motivo Cancelaci√≥n': cita.motivo_cancelacion || ''
            }));

            // Convertir a CSV
            const json2csvParser = new Parser();
            const csv = json2csvParser.parse(datosCSV);

            // Crear nombre de archivo
            const fechaActual = new Date().toISOString().split('T')[0];
            const nombreArchivo = `agenda_${fecha_inicio || fechaActual}_a_${fecha_fin || fechaActual}.csv`;

            // Configurar headers para descarga
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="${nombreArchivo}"`);
            
            res.send(csv);

        } catch (error) {
            console.error('Error exportando agenda a CSV:', error);
            res.status(500).json({
                success: false,
                message: 'Error al exportar agenda',
                error: error.message
            });
        }
    }

    // M√©todo para exportar disponibilidad a CSV
    static async exportarDisponibilidadCSV(req, res) {
        try {
            const { fecha } = req.body;
            const fechaConsulta = fecha || new Date().toISOString().split('T')[0];
            
            // Consulta de disponibilidad
            const disponibilidad = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as profesional,
                    u.rol,
                    u.especialidad,
                    d.dia_semana,
                    TIME_FORMAT(d.hora_inicio, '%H:%i') as hora_inicio,
                    TIME_FORMAT(d.hora_fin, '%H:%i') as hora_fin,
                    d.max_citas_dia,
                    (SELECT COUNT(*) FROM citas c 
                     WHERE c.psicologo_id = u.id 
                     AND c.fecha = ? 
                     AND c.estado IN ('programada', 'confirmada')) as citas_programadas
                FROM users u
                LEFT JOIN disponibilidades d ON u.id = d.usuario_id 
                    AND d.activo = TRUE
                WHERE u.rol IN ('psicologo', 'becario')
                AND u.activo = TRUE
                ORDER BY u.rol, u.apellido, u.nombre, d.dia_semana
            `, {
                replacements: [fechaConsulta],
                type: QueryTypes.SELECT
            });

            // Preparar datos para CSV
            const datosCSV = disponibilidad.map(item => ({
                Profesional: item.profesional,
                Rol: item.rol,
                Especialidad: item.especialidad || '',
                'D√≠a Semana': item.dia_semana || '',
                'Hora Inicio': item.hora_inicio || '',
                'Hora Fin': item.hora_fin || '',
                'M√°x. Citas/D√≠a': item.max_citas_dia || 8,
                'Citas Programadas': item.citas_programadas || 0,
                'Disponibilidad': item.citas_programadas >= (item.max_citas_dia || 8) ? 'Completo' : 'Disponible'
            }));

            // Convertir a CSV
            const json2csvParser = new Parser();
            const csv = json2csvParser.parse(datosCSV);

            // Configurar headers para descarga
            res.setHeader('Content-Type', 'text/csv');
            res.setHeader('Content-Disposition', `attachment; filename="disponibilidad_${fechaConsulta}.csv"`);
            
            res.send(csv);

        } catch (error) {
            console.error('Error exportando disponibilidad a CSV:', error);
            res.status(500).json({
                success: false,
                message: 'Error al exportar disponibilidad',
                error: error.message
            });
        }
    }

    static async generarReporteConflictos(req, res) {
        try {
            const { fecha_inicio, fecha_fin } = req.body;

            // Buscar citas solapadas
            const conflictos = await sequelize.query(`
                SELECT 
                    c1.id as cita1_id,
                    c1.paciente_id as paciente1_id,
                    p1.nombre as paciente1_nombre,
                    p1.apellido as paciente1_apellido,
                    c1.psicologo_id as psicologo1_id,
                    u1.nombre as psicologo1_nombre,
                    u1.apellido as psicologo1_apellido,
                    c1.fecha as fecha_conflicto,
                    c1.hora as hora_inicio1,
                    ADDTIME(c1.hora, SEC_TO_TIME(c1.duracion * 60)) as hora_fin1,
                    
                    c2.id as cita2_id,
                    c2.paciente_id as paciente2_id,
                    p2.nombre as paciente2_nombre,
                    p2.apellido as paciente2_apellido,
                    c2.psicologo_id as psicologo2_id,
                    u2.nombre as psicologo2_nombre,
                    u2.apellido as psicologo2_apellido,
                    c2.hora as hora_inicio2,
                    ADDTIME(c2.hora, SEC_TO_TIME(c2.duracion * 60)) as hora_fin2
                    
                FROM citas c1
                JOIN citas c2 ON 
                    c1.psicologo_id = c2.psicologo_id 
                    AND c1.fecha = c2.fecha
                    AND c1.id < c2.id
                    AND (
                        (c1.hora BETWEEN c2.hora AND ADDTIME(c2.hora, SEC_TO_TIME(c2.duracion * 60)))
                        OR 
                        (c2.hora BETWEEN c1.hora AND ADDTIME(c1.hora, SEC_TO_TIME(c1.duracion * 60)))
                    )
                JOIN pacientes p1 ON c1.paciente_id = p1.id
                JOIN pacientes p2 ON c2.paciente_id = p2.id
                JOIN users u1 ON c1.psicologo_id = u1.id
                JOIN users u2 ON c2.psicologo_id = u2.id
                WHERE c1.estado IN ('programada', 'confirmada')
                    AND c2.estado IN ('programada', 'confirmada')
                    ${fecha_inicio && fecha_fin ? 'AND c1.fecha BETWEEN ? AND ?' : ''}
                ORDER BY c1.fecha, c1.hora
            `, {
                replacements: fecha_inicio && fecha_fin ? [fecha_inicio, fecha_fin] : [],
                type: QueryTypes.SELECT
            });

            res.json({
                success: true,
                data: {
                    conflictos,
                    total_conflictos: conflictos.length,
                    periodo: fecha_inicio && fecha_fin ? `${fecha_inicio} a ${fecha_fin}` : 'Todo el per√≠odo'
                }
            });

        } catch (error) {
            console.error('Error generando reporte de conflictos:', error);
            res.status(500).json({
                success: false,
                message: 'Error al generar reporte de conflictos',
                error: error.message
            });
        }
    }
}

module.exports = ReporteController;

/backend\src\controllers\roleController.js:
--------------------------------------------------------------------------------
const sequelize = require('../config/db');
const { QueryTypes } = require('sequelize');

class RoleController {
    
    static async getMyPermissions(req, res) {
        try {
            const userId = req.user.id;
            
            const query = `
                SELECT p.nombre, p.descripcion, p.categoria, up.concedido
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
            `;
            
            const permissions = await sequelize.query(query, {
                replacements: [userId],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                data: permissions
            });
            
        } catch (error) {
            console.error('Error en getMyPermissions:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener permisos'
            });
        }
    }
    
    static async getUserRoleInfo(req, res) {
        try {
            const userId = req.user.id;
            
            const query = `
                SELECT 
                    u.id,
                    u.email,
                    u.nombre,
                    u.apellido,
                    u.rol,
                    u.especialidad,
                    (SELECT COUNT(*) FROM citas WHERE becario_id = u.id AND fecha = CURDATE()) as citas_hoy,
                    (SELECT COUNT(*) FROM asignaciones WHERE becario_id = u.id AND fecha_fin IS NULL) as pacientes_asignados
                FROM users u
                WHERE u.id = ?
            `;
            
            const [userInfo] = await sequelize.query(query, {
                replacements: [userId],
                type: QueryTypes.SELECT
            });
            
            if (!userInfo) {
                return res.status(404).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Agregar estad√≠sticas espec√≠ficas por rol
            let estadisticas = {};
            
            switch (userInfo.rol) {
                case 'coordinador':
                    const [coordinadorStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                            (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                            (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                            (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') as citas_completadas_hoy
                    `, { type: QueryTypes.SELECT });
                    estadisticas = coordinadorStats;
                    break;
                    
                case 'psicologo':
                    const [psicologoStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM asignaciones WHERE psicologo_id = ? AND fecha_fin IS NULL) as pacientes_asignados,
                            (SELECT COUNT(*) FROM citas WHERE psicologo_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM asignaciones WHERE psicologo_id = ? AND becario_id IS NOT NULL AND fecha_fin IS NULL) as becarios_asignados
                    `, {
                        replacements: [userId, userId, userId],
                        type: QueryTypes.SELECT
                    });
                    estadisticas = psicologoStats;
                    break;
                    
                case 'becario':
                    const [becarioStats] = await sequelize.query(`
                        SELECT 
                            (SELECT COUNT(*) FROM asignaciones WHERE becario_id = ? AND fecha_fin IS NULL) as pacientes_asignados,
                            (SELECT COUNT(*) FROM citas WHERE becario_id = ? AND fecha = CURDATE() AND estado IN ('programada', 'confirmada')) as citas_hoy,
                            (SELECT COUNT(*) FROM observaciones_becarios WHERE becario_id = ? AND fecha = CURDATE()) as observaciones_hoy
                    `, {
                        replacements: [userId, userId, userId],
                        type: QueryTypes.SELECT
                    });
                    estadisticas = becarioStats;
                    break;
            }
            
            res.json({
                success: true,
                data: {
                    user: userInfo,
                    estadisticas: estadisticas
                }
            });
            
        } catch (error) {
            console.error('Error en getUserRoleInfo:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener informaci√≥n del rol'
            });
        }
    }
    
    static async checkPermission(req, res) {
        try {
            const { permission } = req.params;
            const userId = req.user.id;
            
            const query = `
                SELECT EXISTS(
                    SELECT 1 FROM usuario_permisos up
                    JOIN permisos p ON up.permiso_id = p.id
                    WHERE up.usuario_id = ?
                    AND p.nombre = ?
                    AND up.concedido = TRUE
                ) as has_permission
            `;
            
            const [result] = await sequelize.query(query, {
                replacements: [userId, permission],
                type: QueryTypes.SELECT
            });
            
            res.json({
                success: true,
                hasPermission: result.has_permission === 1
            });
            
        } catch (error) {
            console.error('Error en checkPermission:', error);
            res.status(500).json({
                success: false,
                message: 'Error al verificar permiso'
            });
        }
    }
}

module.exports = RoleController;

/backend\src\controllers\sesionController.js:
--------------------------------------------------------------------------------
const Sesion = require('../models/sesionModel');
const Cita = require('../models/citaModel');
const Paciente = require('../models/pacienteModel');
const User = require('../models/userModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class SesionController {
    
    static async registrarSesion(req, res) {
        try {
            const { cita_id, desarrollo, conclusion, tareas_asignadas, 
                    emocion_predominante, riesgo_suicida, escalas_aplicadas, 
                    siguiente_cita, privado } = req.body;
            const usuarioId = req.user.id;
            
            // Verificar que la cita existe y est√° completada
            const cita = await Cita.findByPk(cita_id);
            
            if (!cita) {
                return res.status(404).json({
                    success: false,
                    message: 'Cita no encontrada'
                });
            }
            
            if (cita.estado !== 'completada') {
                return res.status(400).json({
                    success: false,
                    message: 'La cita debe estar en estado "completada" para registrar sesi√≥n'
                });
            }
            
            // Verificar que el usuario es el psic√≥logo asignado
            if (cita.psicologo_id !== usuarioId && req.user.rol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para registrar esta sesi√≥n'
                });
            }
            
            // Verificar que no exista ya una sesi√≥n para esta cita
            const sesionExistente = await Sesion.findOne({
                where: { cita_id }
            });
            
            if (sesionExistente) {
                return res.status(400).json({
                    success: false,
                    message: 'Ya existe una sesi√≥n registrada para esta cita'
                });
            }
            
            // Crear sesi√≥n
            const sesion = await Sesion.create({
                cita_id,
                psicologo_id: cita.psicologo_id,
                fecha: cita.fecha,
                hora_inicio: cita.hora,
                hora_fin: this.calcularHoraFin(cita.hora, cita.duracion),
                desarrollo,
                conclusion,
                tareas_asignadas,
                emocion_predominante,
                riesgo_suicida,
                escalas_aplicadas,
                siguiente_cita,
                privado: privado || false
            });
            
            // Actualizar expediente del paciente
            await this.actualizarExpediente(cita.paciente_id, {
                ultima_sesion: cita.fecha,
                psicologo_id: cita.psicologo_id,
                riesgo_suicida
            });
            
            // Notificar al becario si est√° asignado
            if (cita.becario_id) {
                await sequelize.query(`
                    INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                    VALUES (?, 'observacion_nueva', 'Sesi√≥n registrada', 
                    CONCAT('Se ha registrado la sesi√≥n del paciente: ', 
                    (SELECT CONCAT(nombre, ' ', apellido) FROM pacientes WHERE id = ?)), NOW())
                `, {
                    replacements: [cita.becario_id, cita.paciente_id]
                });
            }
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
                VALUES (?, 'creacion', 'sesiones', 'Registrar sesi√≥n', ?, NOW())
            `, {
                replacements: [usuarioId, `Sesi√≥n registrada para cita ${cita_id}`]
            });
            
            res.json({
                success: true,
                message: 'Sesi√≥n registrada exitosamente',
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en registrarSesion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al registrar sesi√≥n',
                error: error.message
            });
        }
    }
    
    static async obtenerSesionesPaciente(req, res) {
        try {
            const { paciente_id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            // Verificar permisos
            const tieneAcceso = await this.verificarAccesoSesiones(usuarioId, usuarioRol, paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver las sesiones de este paciente'
                });
            }
            
            const query = `
                SELECT 
                    s.*,
                    c.hora AS hora_cita,
                    c.tipo_consulta,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    u_bec.nombre AS becario_nombre,
                    u_bec.apellido AS becario_apellido
                FROM sesiones s
                JOIN citas c ON s.cita_id = c.id
                JOIN users u_psi ON s.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.paciente_id = ?
                ORDER BY s.fecha DESC, s.hora_inicio DESC
            `;
            
            const sesiones = await sequelize.query(query, {
                replacements: [paciente_id],
                type: QueryTypes.SELECT
            });
            
            // Filtrar sesiones privadas si no es el psic√≥logo
            const sesionesFiltradas = sesiones.filter(sesion => {
                if (sesion.privado && sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                    return false;
                }
                return true;
            });
            
            res.json({
                success: true,
                data: sesionesFiltradas,
                count: sesionesFiltradas.length
            });
            
        } catch (error) {
            console.error('Error en obtenerSesionesPaciente:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener sesiones del paciente'
            });
        }
    }
    
    static async obtenerSesionDetalle(req, res) {
        try {
            const { id } = req.params;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const query = `
                SELECT 
                    s.*,
                    c.paciente_id,
                    c.hora AS hora_cita,
                    c.tipo_consulta,
                    p.nombre AS paciente_nombre,
                    p.apellido AS paciente_apellido,
                    u_psi.nombre AS psicologo_nombre,
                    u_psi.apellido AS psicologo_apellido,
                    u_bec.nombre AS becario_nombre,
                    u_bec.apellido AS becario_apellido
                FROM sesiones s
                JOIN citas c ON s.cita_id = c.id
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON s.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE s.id = ?
            `;
            
            const [sesion] = await sequelize.query(query, {
                replacements: [id],
                type: QueryTypes.SELECT
            });
            
            if (!sesion) {
                return res.status(404).json({
                    success: false,
                    message: 'Sesi√≥n no encontrada'
                });
            }
            
            // Verificar acceso a sesi√≥n privada
            if (sesion.privado && sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver esta sesi√≥n privada'
                });
            }
            
            // Verificar acceso general al paciente
            const tieneAcceso = await this.verificarAccesoSesiones(usuarioId, usuarioRol, sesion.paciente_id);
            
            if (!tieneAcceso) {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para ver esta sesi√≥n'
                });
            }
            
            res.json({
                success: true,
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en obtenerSesionDetalle:', error);
            res.status(500).json({
                success: false,
                message: 'Error al obtener detalle de sesi√≥n'
            });
        }
    }
    
    static async actualizarSesion(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            const usuarioId = req.user.id;
            const usuarioRol = req.user.rol;
            
            const sesion = await Sesion.findByPk(id);
            
            if (!sesion) {
                return res.status(404).json({
                    success: false,
                    message: 'Sesi√≥n no encontrada'
                });
            }
            
            // Verificar permisos (solo psic√≥logo asignado o coordinador)
            if (sesion.psicologo_id !== usuarioId && usuarioRol !== 'coordinador') {
                return res.status(403).json({
                    success: false,
                    message: 'No tiene permisos para actualizar esta sesi√≥n'
                });
            }
            
            // Campos que no se pueden modificar
            const camposBloqueados = ['cita_id', 'psicologo_id', 'fecha', 'hora_inicio', 'hora_fin'];
            for (const campo of camposBloqueados) {
                if (updates[campo]) {
                    delete updates[campo];
                }
            }
            
            if (Object.keys(updates).length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'No se proporcionaron campos v√°lidos para actualizar'
                });
            }
            
            // Obtener datos antes para log
            const datosAntes = { ...sesion.toJSON() };
            
            await sesion.update(updates);
            
            // Log
            await sequelize.query(`
                INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, datos_antes, datos_despues, created_at)
                VALUES (?, 'modificacion', 'sesiones', 'Actualizar sesi√≥n', ?, ?, ?, NOW())
            `, {
                replacements: [
                    usuarioId,
                    `Sesi√≥n actualizada ID: ${id}`,
                    JSON.stringify(datosAntes),
                    JSON.stringify(sesion.toJSON())
                ]
            });
            
            res.json({
                success: true,
                message: 'Sesi√≥n actualizada exitosamente',
                data: sesion
            });
            
        } catch (error) {
            console.error('Error en actualizarSesion:', error);
            res.status(500).json({
                success: false,
                message: 'Error al actualizar sesi√≥n'
            });
        }
    }
    
    // M√©todos auxiliares
    static calcularHoraFin(horaInicio, duracionMinutos) {
        const [horas, minutos] = horaInicio.split(':').map(Number);
        const fecha = new Date();
        fecha.setHours(horas, minutos + duracionMinutos, 0, 0);
        return fecha.toTimeString().slice(0, 8);
    }
    
    static async verificarAccesoSesiones(usuarioId, usuarioRol, pacienteId) {
        if (usuarioRol === 'coordinador') return true;
        
        const query = `
            SELECT 1 FROM asignaciones 
            WHERE paciente_id = ? 
            AND estado = 'activa'
            AND (psicologo_id = ? OR becario_id = ?)
        `;
        
        const [result] = await sequelize.query(query, {
            replacements: [pacienteId, usuarioId, usuarioId],
            type: QueryTypes.SELECT
        });
        
        return !!result;
    }
    
    static async actualizarExpediente(pacienteId, datos) {
        await sequelize.query(`
            UPDATE expedientes 
            SET riesgo_suicida = ?, 
                updated_at = NOW()
            WHERE paciente_id = ?
        `, {
            replacements: [datos.riesgo_suicida, pacienteId]
        });
    }
}

module.exports = SesionController;

/backend\src\db\db.sql:
--------------------------------------------------------------------------------
CREATE DATABASE IF NOT EXISTS psicogestion_db;
USE psicogestion_db;

CREATE TABLE fundaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(255) NOT NULL UNIQUE,
    direccion TEXT,
    telefono VARCHAR(20),
    email VARCHAR(255),
    responsable VARCHAR(255),
    activo BOOLEAN DEFAULT TRUE,
    convenio_inicio DATE,
    convenio_fin DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    rol ENUM('coordinador', 'psicologo', 'becario') NOT NULL DEFAULT 'becario',
    especialidad VARCHAR(100),
    fundacion_id INT,
    activo BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (fundacion_id) REFERENCES fundaciones(id) ON DELETE SET NULL
);

CREATE TABLE pacientes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    email VARCHAR(255),
    telefono VARCHAR(20),
    fecha_nacimiento DATE,
    genero ENUM('masculino', 'femenino', 'otro', 'prefiero_no_decir'),
    direccion TEXT,
    estado VARCHAR(50) DEFAULT 'activo',
    activo BOOLEAN DEFAULT TRUE,
    notas TEXT,
    fundacion_id INT,
    ultimo_no_aprobado DATE NULL DEFAULT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (fundacion_id) REFERENCES fundaciones(id) ON DELETE SET NULL,
    INDEX idx_activo (activo),
    INDEX idx_apellido_nombre (apellido, nombre),
    INDEX idx_ultimo_no_aprobado (ultimo_no_aprobado)
);

CREATE TABLE expedientes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL UNIQUE,
    psicologo_id INT,
    motivo_consulta TEXT,
    historia_personal TEXT,
    historia_familiar TEXT,
    antecedentes_medicos TEXT,
    antecedentes_psiquiatricos TEXT,
    diagnostico_presuntivo VARCHAR(500),
    diagnostico_definitivo VARCHAR(500),
    tratamiento_actual TEXT,
    medicamentos JSON,
    alergias TEXT,
    factores_riesgo JSON,
    redes_apoyo TEXT,
    emergencia_contacto VARCHAR(255),
    emergencia_telefono VARCHAR(20),
    consentimiento_informado BOOLEAN DEFAULT FALSE,
    fecha_consentimiento DATE,
    restricciones_acceso JSON,
    notas_confidenciales TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE asignaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    psicologo_id INT NOT NULL,
    becario_id INT,
    fecha_inicio DATE NOT NULL DEFAULT (CURRENT_DATE),
    fecha_fin DATE,
    motivo_fin VARCHAR(255),
    estado ENUM('activa', 'finalizada', 'suspendida') DEFAULT 'activa',
    notas TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_paciente_estado (paciente_id, estado),
    INDEX idx_psicologo_estado (psicologo_id, estado),
    INDEX idx_becario (becario_id)
);

CREATE TABLE citas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    psicologo_id INT,
    becario_id INT,
    fecha DATE NOT NULL,
    hora TIME NOT NULL,
    tipo_consulta ENUM('presencial', 'virtual') DEFAULT 'presencial',
    estado ENUM('programada', 'confirmada', 'completada', 'cancelada') DEFAULT 'programada',
    notas TEXT,
    motivo_cancelacion VARCHAR(255),
    duracion INT DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_fecha_estado (fecha, estado),
    INDEX idx_psicologo_fecha (psicologo_id, fecha),
    INDEX idx_becario (becario_id),
    INDEX idx_paciente_id (paciente_id)
);

CREATE TABLE sesiones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    cita_id INT NOT NULL UNIQUE,
    psicologo_id INT NOT NULL,
    fecha DATE NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fin TIME NOT NULL,
    tipo_sesion ENUM('evaluacion', 'terapia', 'seguimiento', 'crisis') DEFAULT 'terapia',
    objetivo TEXT,
    desarrollo TEXT,
    conclusion TEXT,
    tareas_asignadas TEXT,
    emocion_predominante VARCHAR(100),
    riesgo_suicida ENUM('ninguno', 'bajo', 'moderado', 'alto') DEFAULT 'ninguno',
    escalas_aplicadas JSON,
    siguiente_cita DATE,
    privado BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (cita_id) REFERENCES citas(id) ON DELETE CASCADE,
    FOREIGN KEY (psicologo_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_cita_id (cita_id),
    INDEX idx_psicologo_fecha (psicologo_id, fecha),
    INDEX idx_fecha (fecha)
);

CREATE TABLE notificaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    tipo ENUM('cita_programada', 'cita_modificada', 'cita_cancelada', 'asignacion_nueva', 'observacion_nueva', 'alerta_sistema', 'reporte_generado') NOT NULL,
    titulo VARCHAR(255) NOT NULL,
    mensaje TEXT NOT NULL,
    leido BOOLEAN DEFAULT FALSE,
    leido_at TIMESTAMP NULL,
    accion_url VARCHAR(500),
    prioridad ENUM('baja', 'media', 'alta', 'urgente') DEFAULT 'media',
    datos_extra JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_leido (usuario_id, leido),
    INDEX idx_created_at (created_at),
    INDEX idx_tipo (tipo)
);

CREATE TABLE altas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    paciente_id INT NOT NULL,
    usuario_id INT NOT NULL,
    tipo_alta ENUM('terapeutica', 'abandono', 'traslado', 'graduacion', 'no_continua', 'otro', 'no_aprobado') NOT NULL,
    fecha_alta DATE NOT NULL DEFAULT (CURRENT_DATE),
    motivo_detallado TEXT,
    recomendaciones TEXT,
    sesiones_totales INT,
    evaluacion_final ENUM('excelente', 'buena', 'regular', 'mala'),
    seguimiento_recomendado BOOLEAN DEFAULT FALSE,
    fecha_seguimiento DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (paciente_id) REFERENCES pacientes(id) ON DELETE CASCADE,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_paciente_id (paciente_id),
    INDEX idx_fecha_alta (fecha_alta),
    INDEX idx_tipo_alta (tipo_alta)
);

CREATE TABLE reportes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    tipo_reporte ENUM('mensual', 'trimestral', 'semestral', 'anual', 'personalizado', 'paciente', 'becario', 'psicologo') NOT NULL,
    nombre VARCHAR(255) NOT NULL,
    descripcion TEXT,
    parametros JSON,
    fecha_inicio DATE,
    fecha_fin DATE,
    formato ENUM('pdf', 'excel', 'csv', 'html') DEFAULT 'pdf',
    archivo_url VARCHAR(500),
    archivo_tamano INT,
    estado ENUM('pendiente', 'generando', 'completado', 'error') DEFAULT 'pendiente',
    compartido_con JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_id (usuario_id),
    INDEX idx_tipo_reporte_estado (tipo_reporte, estado),
    INDEX idx_created_at (created_at)
);

CREATE TABLE observaciones_becarios (
    id INT PRIMARY KEY AUTO_INCREMENT,
    becario_id INT NOT NULL,
    supervisor_id INT NOT NULL,
    cita_id INT,
    fecha DATE NOT NULL DEFAULT (CURRENT_DATE),
    tipo_observacion ENUM('sesion_observada', 'retroalimentacion', 'evaluacion_periodica', 'incidencia', 'reconocimiento') DEFAULT 'sesion_observada',
    aspecto_evaluado ENUM('empatia', 'tecnicas', 'documentacion', 'puntualidad', 'profesionalismo', 'etica') NOT NULL,
    calificacion INT NOT NULL CHECK (calificacion BETWEEN 1 AND 10),
    fortalezas TEXT,
    areas_mejora TEXT,
    recomendaciones TEXT,
    plan_accion TEXT,
    fecha_seguimiento DATE,
    privada BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (becario_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (supervisor_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (cita_id) REFERENCES citas(id) ON DELETE SET NULL,
    INDEX idx_becario_fecha (becario_id, fecha),
    INDEX idx_supervisor (supervisor_id),
    INDEX idx_tipo_observacion (tipo_observacion)
);

CREATE TABLE disponibilidades (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    dia_semana ENUM('lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo') NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fin TIME NOT NULL,
    tipo_disponibilidad ENUM('regular', 'extraordinaria', 'limitada') DEFAULT 'regular',
    activo BOOLEAN DEFAULT TRUE,
    fecha_inicio_vigencia DATE NOT NULL DEFAULT (CURRENT_DATE),
    fecha_fin_vigencia DATE,
    notas TEXT,
    max_citas_dia INT DEFAULT 8,
    intervalo_citas INT DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_usuario_dia_activo (usuario_id, dia_semana, activo),
    INDEX idx_fecha_vigencia (fecha_inicio_vigencia, fecha_fin_vigencia)
);

CREATE TABLE logs_sistema (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT,
    tipo_log ENUM('login', 'logout', 'creacion', 'modificacion', 'eliminacion', 'error', 'seguridad', 'backup', 'reporte', 'sistema') NOT NULL,
    modulo VARCHAR(100) NOT NULL,
    accion VARCHAR(255) NOT NULL,
    descripcion TEXT,
    datos_antes JSON,
    datos_despues JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    severidad ENUM('info', 'advertencia', 'error', 'critico') DEFAULT 'info',
    resuelto BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_tipo_log_fecha (tipo_log, created_at),
    INDEX idx_usuario_id (usuario_id),
    INDEX idx_modulo (modulo),
    INDEX idx_severidad_resuelto (severidad, resuelto)
);

CREATE TABLE permisos (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL UNIQUE,
    descripcion TEXT,
    categoria ENUM('administracion', 'pacientes', 'citas', 'reportes', 'configuracion', 'usuarios') NOT NULL,
    nivel_requerido ENUM('basico', 'intermedio', 'avanzado', 'administrador') DEFAULT 'basico',
    activo BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE usuario_permisos (
    id INT PRIMARY KEY AUTO_INCREMENT,
    usuario_id INT NOT NULL,
    permiso_id INT NOT NULL,
    concedido BOOLEAN DEFAULT FALSE,
    concedido_por INT,
    fecha_concesion TIMESTAMP NULL,
    fecha_expiracion TIMESTAMP NULL,
    motivo TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (permiso_id) REFERENCES permisos(id) ON DELETE CASCADE,
    FOREIGN KEY (concedido_por) REFERENCES users(id) ON DELETE SET NULL,
    UNIQUE KEY idx_usuario_permiso (usuario_id, permiso_id)
);

CREATE TABLE backups (
    id INT PRIMARY KEY AUTO_INCREMENT,
    tipo ENUM('completo', 'incremental') NOT NULL,
    ruta VARCHAR(500) NOT NULL,
    tamano BIGINT,
    base_backup_id INT,
    cambios INT DEFAULT 0,
    estado ENUM('pendiente', 'generando', 'completado', 'error', 'eliminado') DEFAULT 'pendiente',
    ultima_restauracion TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (base_backup_id) REFERENCES backups(id) ON DELETE SET NULL
);

INSERT INTO permisos (nombre, descripcion, categoria, nivel_requerido) VALUES
('ver_panel_coordinacion', 'Ver panel de coordinaci√≥n', 'administracion', 'avanzado'),
('gestionar_usuarios', 'Gestionar usuarios (alta/baja/edici√≥n)', 'usuarios', 'avanzado'),
('gestionar_fundaciones', 'Gestionar fundaciones', 'administracion', 'avanzado'),
('gestionar_pacientes', 'Gestionar pacientes', 'pacientes', 'intermedio'),
('gestionar_asignaciones', 'Asignar pacientes a psic√≥logos/becarios', 'pacientes', 'intermedio'),
('ver_agenda_global', 'Ver agenda global completa', 'citas', 'intermedio'),
('generar_reportes', 'Generar reportes estad√≠sticos', 'reportes', 'avanzado'),
('gestionar_altas', 'Gestionar altas de pacientes', 'pacientes', 'intermedio'),
('ver_expedientes_completos', 'Ver expedientes completos de pacientes', 'pacientes', 'avanzado'),
('configurar_sistema', 'Configurar par√°metros del sistema', 'configuracion', 'administrador'),
('ver_panel_psicologo', 'Ver panel principal de psic√≥logo', 'administracion', 'basico'),
('ver_mis_pacientes', 'Ver pacientes asignados', 'pacientes', 'basico'),
('gestionar_mis_citas', 'Gestionar mis propias citas', 'citas', 'basico'),
('registrar_sesiones', 'Registrar contenido de sesiones', 'citas', 'intermedio'),
('supervisar_becarios', 'Supervisar becarios asignados', 'usuarios', 'intermedio'),
('crear_observaciones', 'Crear observaciones de becarios', 'usuarios', 'intermedio'),
('ver_expedientes_asignados', 'Ver expedientes de pacientes asignados', 'pacientes', 'intermedio'),
('dar_altas_pacientes', 'Dar de alta a pacientes', 'pacientes', 'intermedio'),
('ver_panel_becario', 'Ver panel principal de becario', 'administracion', 'basico'),
('ver_citas_dia', 'Ver citas del d√≠a', 'citas', 'basico'),
('gestionar_citas_asignadas', 'Gestionar citas asignadas', 'citas', 'basico'),
('ver_pacientes_asignados', 'Ver pacientes asignados', 'pacientes', 'basico'),
('ver_observaciones_propias', 'Ver observaciones propias', 'usuarios', 'basico'),
('configurar_disponibilidad', 'Configurar disponibilidad personal', 'configuracion', 'basico');

INSERT INTO fundaciones (nombre, telefono, email, responsable) VALUES
('Fundaci√≥n Salud Mental Comunitaria', '555-1234', 'contacto@fsmc.org', 'Dra. Mar√≠a Gonz√°lez'),
('Asociaci√≥n de Psicolog√≠a Aplicada', '555-5678', 'info@asocpsicologia.edu', 'Lic. Carlos Rodr√≠guez');

INSERT INTO users (email, password, nombre, apellido, telefono, rol, especialidad, fundacion_id) VALUES
('coordinador@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Ana', 'Mart√≠nez', '555-1111', 'coordinador', 'Coordinaci√≥n Cl√≠nica', 1),
('psicologo1@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Luis', 'Fern√°ndez', '555-2222', 'psicologo', 'Terapia Cognitivo-Conductual', 1),
('becario1@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Juan', 'P√©rez', '555-3333', 'becario', 'Practicante de Psicolog√≠a', 1),
('becario2@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Sof√≠a', 'Ram√≠rez', '555-4444', 'becario', 'Practicante de Psicolog√≠a', 2),
('psicologo2@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Laura', 'Guti√©rrez', '555-5555', 'psicologo', 'Terapia Familiar', 1),
('becario3@psicogestion.com', '$2b$12$hae1TqJNVYIumXT7aPXKCO/lVf418E5.nXUCem30mFsG5itFuLDjq', 'Pedro', 'Hern√°ndez', '555-6666', 'becario', 'Practicante de Psicolog√≠a', 1);

INSERT INTO pacientes (nombre, apellido, fecha_nacimiento, genero, telefono, email) VALUES 
('Carlos', 'G√≥mez', '1998-05-15', 'masculino', '555-0011', 'carlos@gmail.com'),
('Mariana', 'L√≥pez', '1995-08-22', 'femenino', '555-0022', 'mariana@hotmail.com'),
('Roberto', 'S√°nchez', '2000-02-10', 'masculino', '555-0033', 'roberto@yahoo.com');

INSERT INTO expedientes (paciente_id, psicologo_id, motivo_consulta) VALUES
(1, 2, 'Ansiedad acad√©mica con s√≠ntomas de estr√©s elevado'),
(2, 2, 'Estr√©s laboral cr√≥nico con afectaci√≥n del sue√±o'),
(3, 2, 'Dificultades de adaptaci√≥n al entorno universitario');

INSERT INTO asignaciones (paciente_id, psicologo_id, becario_id, fecha_inicio) VALUES
(1, 2, 3, CURDATE()),
(2, 2, 4, CURDATE()),
(3, 2, NULL, CURDATE());

INSERT INTO citas (paciente_id, psicologo_id, becario_id, fecha, hora, estado, tipo_consulta, notas) VALUES
(1, 2, 3, DATE_ADD(CURDATE(), INTERVAL 1 DAY), '10:00:00', 'programada', 'presencial', 'Primera consulta'),
(2, 2, 4, DATE_ADD(CURDATE(), INTERVAL 2 DAY), '11:00:00', 'confirmada', 'virtual', 'Seguimiento'),
(3, 2, NULL, DATE_ADD(CURDATE(), INTERVAL 3 DAY), '09:00:00', 'programada', 'presencial', 'Evaluaci√≥n inicial');

INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje) VALUES
(3, 'cita_programada', 'Nueva cita asignada', 'Tienes una nueva cita con Carlos G√≥mez para ma√±ana a las 10:00 AM'),
(4, 'cita_modificada', 'Cita modificada', 'La cita con Mariana L√≥pez ha sido cambiada a modalidad virtual');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'coordinador'
AND p.nivel_requerido IN ('basico', 'intermedio', 'avanzado', 'administrador');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'psicologo'
AND p.nivel_requerido IN ('basico', 'intermedio');

INSERT INTO usuario_permisos (usuario_id, permiso_id, concedido, concedido_por, fecha_concesion)
SELECT u.id, p.id, TRUE, 1, NOW()
FROM users u
CROSS JOIN permisos p
WHERE u.rol = 'becario'
AND p.nivel_requerido = 'basico';

CREATE VIEW vista_citas_hoy AS
SELECT 
    c.id,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    c.fecha,
    TIME_FORMAT(c.hora, '%H:%i') AS hora,
    c.estado,
    c.tipo_consulta,
    u_psi.nombre AS psicologo_nombre,
    u_bec.nombre AS becario_nombre
FROM citas c
JOIN pacientes p ON c.paciente_id = p.id
JOIN users u_psi ON c.psicologo_id = u_psi.id
LEFT JOIN users u_bec ON c.becario_id = u_bec.id
WHERE c.fecha = CURDATE()
AND c.estado IN ('programada', 'confirmada')
ORDER BY c.hora;

CREATE VIEW vista_pacientes_asignados AS
SELECT 
    a.id,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    p.telefono,
    p.email,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    CONCAT(ub.nombre, ' ', ub.apellido) AS becario,
    a.fecha_inicio,
    a.estado AS estado_asignacion,
    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado = 'completada') AS sesiones_completadas,
    (SELECT COUNT(*) FROM citas WHERE paciente_id = p.id AND estado IN ('programada', 'confirmada') AND fecha >= CURDATE()) AS citas_pendientes
FROM asignaciones a
JOIN pacientes p ON a.paciente_id = p.id
JOIN users u ON a.psicologo_id = u.id
LEFT JOIN users ub ON a.becario_id = ub.id
WHERE p.activo = TRUE AND a.estado = 'activa';

CREATE VIEW vista_resumen_coordinacion AS
SELECT 
    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) AS becarios_activos,
    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) AS psicologos_activos,
    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) AS pacientes_activos,
    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado IN ('programada', 'confirmada')) AS citas_hoy,
    (SELECT COUNT(*) FROM citas WHERE fecha = CURDATE() AND estado = 'completada') AS citas_completadas_hoy,
    (SELECT COUNT(*) FROM altas WHERE MONTH(fecha_alta) = MONTH(CURDATE())) AS altas_mes_actual;

CREATE VIEW vista_historial_sesiones AS
SELECT 
    s.id,
    s.fecha,
    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    s.desarrollo AS contenido_sesion,
    s.conclusion AS observaciones,
    s.tareas_asignadas,
    s.siguiente_cita AS proxima_sesion
FROM sesiones s
JOIN citas c ON s.cita_id = c.id
JOIN pacientes p ON c.paciente_id = p.id
JOIN users u ON s.psicologo_id = u.id
ORDER BY s.fecha DESC;

CREATE VIEW vista_estadisticas_psicologos AS
SELECT 
    u.id,
    CONCAT(u.nombre, ' ', u.apellido) AS psicologo,
    COUNT(DISTINCT a.paciente_id) AS pacientes_asignados,
    COUNT(c.id) AS total_citas,
    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS citas_completadas,
    ROUND(AVG(CASE WHEN c.estado = 'completada' THEN c.duracion END), 1) AS duracion_promedio,
    COUNT(DISTINCT a.becario_id) AS becarios_supervisados
FROM users u
LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
LEFT JOIN citas c ON u.id = c.psicologo_id AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
WHERE u.rol = 'psicologo' AND u.activo = TRUE
GROUP BY u.id, u.nombre, u.apellido;

CREATE VIEW vista_disponibilidad_semanal AS
SELECT 
    u.id,
    CONCAT(u.nombre, ' ', u.apellido) AS profesional,
    u.rol,
    d.dia_semana,
    TIME_FORMAT(d.hora_inicio, '%H:%i') AS hora_inicio,
    TIME_FORMAT(d.hora_fin, '%H:%i') AS hora_fin,
    d.max_citas_dia,
    (SELECT COUNT(*) FROM citas c 
     WHERE (c.psicologo_id = u.id OR c.becario_id = u.id)
     AND c.fecha = CURDATE()
     AND c.estado IN ('programada', 'confirmada')) AS citas_hoy
FROM users u
LEFT JOIN disponibilidades d ON u.id = d.usuario_id AND d.activo = TRUE
WHERE u.rol IN ('psicologo', 'becario') AND u.activo = TRUE
ORDER BY u.rol, u.apellido, FIELD(d.dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo');

DELIMITER $$
CREATE PROCEDURE sp_obtener_citas_por_fecha_becario(
    IN p_fecha DATE,
    IN p_becario_id INT
)
BEGIN
    SELECT 
        c.*,
        CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
        p.telefono AS paciente_telefono,
        p.email AS paciente_email,
        u_psi.nombre AS psicologo_nombre,
        u_bec.nombre AS becario_nombre,
        c.duracion AS duracion_minutos,
        c.notas AS motivo
    FROM citas c
    JOIN pacientes p ON c.paciente_id = p.id
    LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
    LEFT JOIN users u_bec ON c.becario_id = u_bec.id
    WHERE c.fecha = p_fecha
    AND (c.becario_id = p_becario_id OR p_becario_id IS NULL)
    ORDER BY c.hora;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE sp_generar_reporte_mensual(
    IN p_mes INT,
    IN p_anio INT,
    IN p_psicologo_id INT
)
BEGIN
    SELECT 
        p.id,
        CONCAT(p.nombre, ' ', p.apellido) AS paciente,
        COUNT(c.id) AS total_sesiones,
        SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS sesiones_completadas,
        SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) AS sesiones_canceladas,
        SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) AS sesiones_programadas,
        MIN(c.fecha) AS primera_sesion_mes,
        MAX(c.fecha) AS ultima_sesion_mes
    FROM pacientes p
    LEFT JOIN citas c ON p.id = c.paciente_id 
        AND MONTH(c.fecha) = p_mes 
        AND YEAR(c.fecha) = p_anio
        AND (c.psicologo_id = p_psicologo_id OR p_psicologo_id IS NULL)
    WHERE p.activo = TRUE
    GROUP BY p.id, p.nombre, p.apellido
    ORDER BY p.apellido, p.nombre;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_insert_alta
AFTER INSERT ON altas
FOR EACH ROW
BEGIN
    UPDATE pacientes 
    SET estado = CONCAT('alta_', NEW.tipo_alta),
        activo = FALSE,
        updated_at = NOW()
    WHERE id = NEW.paciente_id;
    
    UPDATE citas 
    SET estado = 'cancelada',
        motivo_cancelacion = CONCAT('Paciente dado de alta (', NEW.tipo_alta, ')'),
        updated_at = NOW()
    WHERE paciente_id = NEW.paciente_id 
    AND fecha >= CURDATE()
    AND estado IN ('programada', 'confirmada');
    
    UPDATE asignaciones 
    SET estado = 'finalizada',
        fecha_fin = CURDATE(),
        motivo_fin = CONCAT('Paciente dado de alta (', NEW.tipo_alta, ')')
    WHERE paciente_id = NEW.paciente_id 
    AND estado = 'activa';
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_update_cita
AFTER UPDATE ON citas
FOR EACH ROW
BEGIN
    DECLARE paciente_nombre VARCHAR(200);
    DECLARE paciente_email VARCHAR(255);
    
    IF OLD.fecha != NEW.fecha OR OLD.hora != NEW.hora OR OLD.tipo_consulta != NEW.tipo_consulta THEN
        
        SELECT CONCAT(nombre, ' ', apellido), email INTO paciente_nombre, paciente_email
        FROM pacientes WHERE id = NEW.paciente_id;
        
        IF NEW.psicologo_id IS NOT NULL THEN
            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
            VALUES (
                NEW.psicologo_id,
                'cita_modificada',
                'Cita modificada',
                CONCAT('La cita con ', paciente_nombre, ' ha sido modificada. Nueva fecha: ', NEW.fecha, ' ', TIME_FORMAT(NEW.hora, '%H:%i')),
                NOW()
            );
        END IF;
        
        IF NEW.becario_id IS NOT NULL THEN
            INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
            VALUES (
                NEW.becario_id,
                'cita_modificada',
                'Cita modificada',
                CONCAT('La cita con ', paciente_nombre, ' ha sido modificada. Nueva fecha: ', NEW.fecha, ' ', TIME_FORMAT(NEW.hora, '%H:%i')),
                NOW()
            );
        END IF;
        
        INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
        VALUES (
            NEW.psicologo_id,
            'modificacion',
            'citas',
            'Actualizar cita',
            CONCAT('Cita ', NEW.id, ' modificada para paciente ', paciente_nombre),
            NOW()
        );
    END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_after_insert_sesion
AFTER INSERT ON sesiones
FOR EACH ROW
BEGIN
    UPDATE expedientes 
    SET riesgo_suicida = NEW.riesgo_suicida,
        updated_at = NOW()
    WHERE paciente_id = (SELECT paciente_id FROM citas WHERE id = NEW.cita_id);
END$$
DELIMITER ;

CREATE INDEX idx_pacientes_activo ON pacientes(activo);
CREATE INDEX idx_citas_psicologo_fecha ON citas(psicologo_id, fecha, estado);
CREATE INDEX idx_sesiones_cita ON sesiones(cita_id);
CREATE INDEX idx_asignaciones_psicologo ON asignaciones(psicologo_id, fecha_fin);
CREATE INDEX idx_users_rol_activo ON users(rol, activo);
CREATE INDEX idx_expediente_paciente ON expedientes(paciente_id);
CREATE INDEX idx_expediente_psicologo ON expedientes(psicologo_id);
CREATE INDEX idx_reportes_usuario ON reportes(usuario_id, estado);
CREATE INDEX idx_reportes_tipo ON reportes(tipo_reporte, created_at);
CREATE INDEX idx_disponibilidades_vigencia ON disponibilidades(fecha_inicio_vigencia, fecha_fin_vigencia);
CREATE INDEX idx_logs_severidad ON logs_sistema(severidad, resuelto);
CREATE INDEX idx_observaciones_fecha_seguimiento ON observaciones_becarios(fecha_seguimiento);

CREATE USER IF NOT EXISTS 'psicogestion_user'@'localhost' IDENTIFIED BY 'SecurePass123!';
GRANT ALL PRIVILEGES ON psicogestion_db.* TO 'psicogestion_user'@'localhost';
GRANT EXECUTE ON PROCEDURE psicogestion_db.sp_obtener_citas_por_fecha_becario TO 'psicogestion_user'@'localhost';
GRANT EXECUTE ON PROCEDURE psicogestion_db.sp_generar_reporte_mensual TO 'psicogestion_user'@'localhost';
FLUSH PRIVILEGES;

/backend\src\doc\swagger.json:
--------------------------------------------------------------------------------
{
  "swagger": "2.0",
  "info": {
    "version": "1.0.1",
    "title": "API Documentation con Auth",
    "description": "API documentation including Authentication endpoint"
  },
  "host": "localhost:3000",
  "basePath": "/",
  "schemes": [
    "http"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/": {
      "get": {
        "summary": "Root endpoint",
        "description": "Returns a basic message to confirm the server is running.",
        "responses": {
          "200": {
            "description": "Server is running"
          }
        }
      }
    },
    "/api/auth/login": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "User Login",
        "description": "Authenticate user with email and password to receive a JWT token.",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "User credentials",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LoginCredentials"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Login successful, token returned",
            "schema": {
              "$ref": "#/definitions/LoginResponse"
            }
          },
          "400": {
            "description": "Missing email or password"
          },
          "401": {
            "description": "Invalid credentials"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    }
  },
  "definitions": {
    "LoginCredentials": {
      "type": "object",
      "required": [
        "email",
        "password"
      ],
      "properties": {
        "email": {
          "type": "string",
          "example": "test@example.com"
        },
        "password": {
          "type": "string",
          "example": "123456"
        }
      }
    },
    "LoginResponse": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "example": "Login exitoso"
        },
        "token": {
          "type": "string",
          "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
        },
        "user": {
          "type": "object",
          "properties": {
            "id": { "type": "integer", "example": 1 },
            "email": { "type": "string", "example": "test@example.com" }
          }
        }
      }
    }
  }
}

/backend\src\middlewares\authMiddleware.js:
--------------------------------------------------------------------------------


const jwt = require('jsonwebtoken');

const verifyToken = (req, res, next) => {
    // 1. Obtener el token del header "Authorization"
    // Se espera el formato: "Bearer <token_aqui>"
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Obtener la segunda parte

    if (!token) {
        return res.status(403).json({ message: 'Acceso denegado. Token no proporcionado.' });
    }

    try {
        // 2. Verificar el token usando la clave secreta
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // 3. Si es v√°lido, guardamos los datos del usuario (payload) en la request
        // para que las siguientes rutas puedan usarlo (ej. req.user.id)
        req.user = decoded;
        
        // 4. Continuar con la siguiente funci√≥n
        next();
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
             return res.status(401).json({ message: 'El token ha expirado.' });
        }
        return res.status(401).json({ message: 'Token inv√°lido.' });
    }
};

module.exports = verifyToken;

/backend\src\middlewares\logMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const logMiddleware = (tipoLog, modulo, accion) => {
    return async (req, res, next) => {
        const startTime = Date.now();
        
        // Guardar referencia a la funci√≥n original de res.json
        const originalJson = res.json;
        
        // Sobrescribir res.json para capturar la respuesta
        res.json = function(data) {
            // Restaurar la funci√≥n original
            res.json = originalJson;
            
            // Calcular tiempo de respuesta
            const responseTime = Date.now() - startTime;
            
            // Registrar el log en segundo plano (no bloquear la respuesta)
            registrarLogAsync({
                usuario_id: req.user?.id || null,
                tipo_log: tipoLog,
                modulo: modulo,
                accion: accion,
                descripcion: `${accion} - ${req.method} ${req.originalUrl}`,
                ip_address: req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress,
                user_agent: req.headers['user-agent'],
                datos_extra: {
                    method: req.method,
                    url: req.originalUrl,
                    query_params: req.query,
                    body_params: req.body,
                    response_status: res.statusCode,
                    response_time_ms: responseTime,
                    success: data?.success || false
                },
                severidad: res.statusCode >= 500 ? 'error' : 
                          res.statusCode >= 400 ? 'advertencia' : 'info'
            }).catch(console.error);
            
            // Llamar a la funci√≥n original
            return originalJson.call(this, data);
        };
        
        next();
    };
};

// Funci√≥n as√≠ncrona para registrar logs
async function registrarLogAsync(logData) {
    try {
        await sequelize.query(`
            INSERT INTO logs_sistema (
                usuario_id, tipo_log, modulo, accion, descripcion,
                ip_address, user_agent, datos_extra, severidad, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
        `, {
            replacements: [
                logData.usuario_id,
                logData.tipo_log,
                logData.modulo,
                logData.accion,
                logData.descripcion,
                logData.ip_address,
                logData.user_agent,
                JSON.stringify(logData.datos_extra),
                logData.severidad
            ]
        });
    } catch (error) {
        console.error('Error al registrar log:', error);
    }
}

// Middleware para logs de autenticaci√≥n
const logAuthMiddleware = logMiddleware('login', 'autenticacion', 'Login usuario');

// Middleware para logs de creaci√≥n
const logCreacionMiddleware = (modulo) => logMiddleware('creacion', modulo, 'Crear registro');

// Middleware para logs de modificaci√≥n
const logModificacionMiddleware = (modulo) => logMiddleware('modificacion', modulo, 'Modificar registro');

// Middleware para logs de eliminaci√≥n
const logEliminacionMiddleware = (modulo) => logMiddleware('eliminacion', modulo, 'Eliminar registro');

// Middleware para logs de consulta
const logConsultaMiddleware = (modulo) => logMiddleware('consulta', modulo, 'Consultar registros');

// Middleware para logs de reportes
const logReporteMiddleware = logMiddleware('reporte', 'reportes', 'Generar reporte');

// Middleware para logs de errores
const logErrorMiddleware = (error, req, res, next) => {
    registrarLogAsync({
        usuario_id: req.user?.id || null,
        tipo_log: 'error',
        modulo: 'sistema',
        accion: 'Error en solicitud',
        descripcion: `Error: ${error.message}`,
        ip_address: req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress,
        user_agent: req.headers['user-agent'],
        datos_extra: {
            method: req.method,
            url: req.originalUrl,
            error_stack: error.stack,
            error_message: error.message
        },
        severidad: 'error'
    }).catch(console.error);
    
    next(error);
};

// Middleware para auditor√≠a de datos sensibles
const auditoriaMiddleware = (modulo, camposSensibles = []) => {
    return async (req, res, next) => {
        // Guardar datos originales para comparaci√≥n posterior
        if (req.method === 'PUT' || req.method === 'PATCH') {
            const datosOriginales = await obtenerDatosOriginales(req);
            req._datosOriginales = datosOriginales;
        }
        
        next();
    };
};

async function obtenerDatosOriginales(req) {
    // Esta funci√≥n obtendr√≠a los datos originales de la base de datos
    // Implementaci√≥n espec√≠fica seg√∫n el m√≥dulo
    return {};
}

module.exports = {
    logMiddleware,
    logAuthMiddleware,
    logCreacionMiddleware,
    logModificacionMiddleware,
    logEliminacionMiddleware,
    logConsultaMiddleware,
    logReporteMiddleware,
    logErrorMiddleware,
    auditoriaMiddleware,
    registrarLogAsync
};

/backend\src\middlewares\permisoMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const permisoMiddleware = (permisoNombre) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar si el usuario tiene el permiso espec√≠fico
            const query = `
                SELECT up.concedido 
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND p.nombre = ?
                AND up.concedido = TRUE
            `;
            
            const result = await sequelize.query(query, {
                replacements: [usuarioId, permisoNombre],
                type: QueryTypes.SELECT
            });
            
            if (result.length > 0) {
                return next();
            }
            
            // Si no tiene permiso espec√≠fico, verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            // Permisos por defecto seg√∫n rol
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            if (permisosPorRol[usuario.rol]?.includes(permisoNombre)) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: `No tiene el permiso necesario: ${permisoNombre}`
            });
            
        } catch (error) {
            console.error('Error en permisoMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

// Middleware para verificar m√∫ltiples permisos (al menos uno)
const algunPermisoMiddleware = (permisos) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar permisos del usuario
            const query = `
                SELECT p.nombre
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
                AND p.nombre IN (?)
            `;
            
            const resultados = await sequelize.query(query, {
                replacements: [usuarioId, permisos],
                type: QueryTypes.SELECT
            });
            
            if (resultados.length > 0) {
                return next();
            }
            
            // Verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            // Verificar si alg√∫n permiso requerido est√° en los permisos del rol
            const tieneAlgunPermiso = permisos.some(permiso => 
                permisosPorRol[usuario.rol]?.includes(permiso)
            );
            
            if (tieneAlgunPermiso) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene los permisos necesarios para esta acci√≥n'
            });
            
        } catch (error) {
            console.error('Error en algunPermisoMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

// Middleware para verificar todos los permisos
const todosPermisosMiddleware = (permisos) => {
    return async (req, res, next) => {
        try {
            const usuarioId = req.user.id;
            
            // Consultar permisos del usuario
            const query = `
                SELECT p.nombre
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND up.concedido = TRUE
                AND p.nombre IN (?)
            `;
            
            const resultados = await sequelize.query(query, {
                replacements: [usuarioId, permisos],
                type: QueryTypes.SELECT
            });
            
            const permisosObtenidos = resultados.map(r => r.nombre);
            
            // Verificar si tiene todos los permisos requeridos
            const tieneTodos = permisos.every(permiso => 
                permisosObtenidos.includes(permiso)
            );
            
            if (tieneTodos) {
                return next();
            }
            
            // Verificar por rol
            const [usuario] = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!usuario) {
                return res.status(403).json({
                    success: false,
                    message: 'Usuario no encontrado'
                });
            }
            
            const permisosPorRol = {
                coordinador: [
                    'ver_panel_coordinacion',
                    'gestionar_usuarios',
                    'gestionar_fundaciones',
                    'gestionar_pacientes',
                    'gestionar_asignaciones',
                    'ver_agenda_global',
                    'generar_reportes',
                    'ver_estadisticas',
                    'gestionar_altas',
                    'ver_expedientes_completos',
                    'configurar_sistema'
                ],
                psicologo: [
                    'ver_panel_psicologo',
                    'ver_mis_pacientes',
                    'gestionar_mis_citas',
                    'registrar_sesiones',
                    'supervisar_becarios',
                    'crear_observaciones',
                    'ver_expedientes_asignados',
                    'dar_altas_pacientes'
                ],
                becario: [
                    'ver_panel_becario',
                    'ver_citas_dia',
                    'gestionar_citas_asignadas',
                    'ver_pacientes_asignados',
                    'ver_observaciones_propias',
                    'configurar_disponibilidad'
                ]
            };
            
            // Verificar si todos los permisos requeridos est√°n en los permisos del rol
            const tieneTodosPorRol = permisos.every(permiso => 
                permisosPorRol[usuario.rol]?.includes(permiso)
            );
            
            if (tieneTodosPorRol) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene todos los permisos necesarios para esta acci√≥n'
            });
            
        } catch (error) {
            console.error('Error en todosPermisosMiddleware:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

module.exports = {
    permisoMiddleware,
    algunPermisoMiddleware,
    todosPermisosMiddleware
};

/backend\src\middlewares\roleMiddleware.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

const checkPermission = (permisoNombre) => {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            // Consultar si el usuario tiene el permiso
            const query = `
                SELECT up.concedido 
                FROM usuario_permisos up
                JOIN permisos p ON up.permiso_id = p.id
                WHERE up.usuario_id = ?
                AND p.nombre = ?
            `;
            
            const result = await sequelize.query(query, {
                replacements: [userId, permisoNombre],
                type: QueryTypes.SELECT
            });
            
            if (result.length > 0 && result[0].concedido) {
                return next();
            }
            
            // Si no tiene permiso espec√≠fico, verificar por rol b√°sico
            const user = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [userId], type: QueryTypes.SELECT }
            );
            
            const userRole = user[0]?.rol;
            
            // Permisos por rol (fallback)
            const rolePermissions = {
                'coordinador': [
                    'ver_panel_coordinacion', 'gestionar_usuarios', 'gestionar_pacientes',
                    'gestionar_asignaciones', 'ver_agenda_global', 'generar_reportes',
                    'gestionar_altas'
                ],
                'psicologo': [
                    'ver_panel_psicologo', 'ver_mis_pacientes', 'ver_expedientes',
                    'registrar_sesiones', 'gestionar_mis_citas', 'supervisar_becarios'
                ],
                'becario': [
                    'ver_panel_becario', 'ver_citas_dia', 'gestionar_citas_asignadas',
                    'ver_pacientes_asignados', 'registrar_observaciones', 'ver_notificaciones'
                ]
            };
            
            if (userRole && rolePermissions[userRole]?.includes(permisoNombre)) {
                return next();
            }
            
            return res.status(403).json({
                success: false,
                message: 'No tiene permisos para acceder a esta funcionalidad'
            });
            
        } catch (error) {
            console.error('Error en checkPermission:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar permisos'
            });
        }
    };
};

const requireRole = (roles) => {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            const user = await sequelize.query(
                'SELECT rol FROM users WHERE id = ?',
                { replacements: [userId], type: QueryTypes.SELECT }
            );
            
            if (user.length === 0 || !roles.includes(user[0].rol)) {
                return res.status(403).json({
                    success: false,
                    message: 'Acceso denegado para este rol'
                });
            }
            
            next();
        } catch (error) {
            console.error('Error en requireRole:', error);
            return res.status(500).json({
                success: false,
                message: 'Error al verificar rol'
            });
        }
    };
};

module.exports = { checkPermission, requireRole };

/backend\src\middlewares\validacionMiddleware.js:
--------------------------------------------------------------------------------
const { body, param, query, validationResult } = require('express-validator');

// Validaciones comunes
const validacionesComunes = {
    email: body('email').isEmail().normalizeEmail(),
    telefono: body('telefono').optional().isMobilePhone('any-MX'),
    fecha: body('fecha').isDate().toDate(),
    hora: body('hora').matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/),
    numeroPositivo: body().custom((value, { path }) => {
        if (typeof value === 'number' && value > 0) return true;
        throw new Error(`${path} debe ser un n√∫mero positivo`);
    })
};

// Validaciones para pacientes
const validarPaciente = [
    body('nombre').notEmpty().trim().isLength({ min: 2, max: 100 }),
    body('apellido').notEmpty().trim().isLength({ min: 2, max: 100 }),
    validacionesComunes.email.optional(),
    validacionesComunes.telefono,
    body('fecha_nacimiento').optional().isDate(),
    body('genero').optional().isIn(['masculino', 'femenino', 'otro', 'prefiero_no_decir']),
    body('direccion').optional().trim(),
    body('estado').optional().isIn(['activo', 'inactivo', 'pendiente']),
    body('activo').optional().isBoolean(),
    body('notas').optional().trim(),
    body('fundacion_id').optional().isInt()
];

// Validaciones para citas
const validarCita = [
    body('paciente_id').isInt(),
    body('psicologo_id').optional().isInt(),
    body('becario_id').optional().isInt(),
    validacionesComunes.fecha,
    validacionesComunes.hora,
    body('tipo_consulta').isIn(['presencial', 'virtual']),
    body('estado').optional().isIn(['programada', 'confirmada', 'completada', 'cancelada']),
    body('duracion').optional().isInt({ min: 15, max: 120 }),
    body('notas').optional().trim()
];

// Validaciones para sesiones
const validarSesion = [
    body('cita_id').isInt(),
    body('desarrollo').notEmpty().trim(),
    body('conclusion').optional().trim(),
    body('tareas_asignadas').optional().trim(),
    body('emocion_predominante').optional().trim(),
    body('riesgo_suicida').optional().isIn(['ninguno', 'bajo', 'moderado', 'alto']),
    body('escalas_aplicadas').optional().isJSON(),
    body('siguiente_cita').optional().isDate(),
    body('privado').optional().isBoolean()
];

// Validaciones para usuarios
const validarUsuario = [
    validacionesComunes.email,
    body('password').isLength({ min: 6 }),
    body('nombre').notEmpty().trim().isLength({ min: 2, max: 100 }),
    body('apellido').notEmpty().trim().isLength({ min: 2, max: 100 }),
    validacionesComunes.telefono.optional(),
    body('rol').isIn(['coordinador', 'psicologo', 'becario']),
    body('especialidad').optional().trim(),
    body('fundacion_id').optional().isInt(),
    body('activo').optional().isBoolean()
];

// Validaciones para observaciones de becarios
const validarObservacion = [
    body('becario_id').isInt(),
    body('cita_id').optional().isInt(),
    body('tipo_observacion').isIn(['sesion_observada', 'retroalimentacion', 'evaluacion_periodica', 'incidencia', 'reconocimiento']),
    body('aspecto_evaluado').isIn(['empatia', 'tecnicas', 'documentacion', 'puntualidad', 'profesionalismo', 'etica']),
    body('calificacion').isInt({ min: 1, max: 10 }),
    body('fortalezas').optional().trim(),
    body('areas_mejora').optional().trim(),
    body('recomendaciones').optional().trim(),
    body('plan_accion').optional().trim(),
    body('fecha_seguimiento').optional().isDate(),
    body('privada').optional().isBoolean()
];

// Validaciones para disponibilidad
const validarDisponibilidad = [
    body('dia_semana').isIn(['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo']),
    validacionesComunes.hora.custom((value, { req }) => {
        const horaInicio = value;
        const horaFin = req.body.hora_fin;
        
        if (!horaFin) return true;
        
        const [h1, m1] = horaInicio.split(':').map(Number);
        const [h2, m2] = horaFin.split(':').map(Number);
        
        if (h2 < h1 || (h2 === h1 && m2 <= m1)) {
            throw new Error('La hora de fin debe ser mayor que la hora de inicio');
        }
        
        return true;
    }),
    body('hora_fin').matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/),
    body('tipo_disponibilidad').optional().isIn(['regular', 'extraordinaria', 'limitada']),
    body('max_citas_dia').optional().isInt({ min: 1, max: 12 }),
    body('intervalo_citas').optional().isInt({ min: 15, max: 120 }),
    body('fecha_fin_vigencia').optional().isDate()
];

// Validaciones para altas
const validarAlta = [
    body('paciente_id').isInt(),
    body('tipo_alta').isIn(['terapeutica', 'abandono', 'traslado', 'graduacion', 'no_continua', 'otro']),
    body('motivo_detallado').optional().trim(),
    body('recomendaciones').optional().trim(),
    body('evaluacion_final').optional().isIn(['excelente', 'buena', 'regular', 'mala']),
    body('seguimiento_recomendado').optional().isBoolean(),
    body('fecha_seguimiento').optional().isDate()
];

// Validaciones para reportes
const validarReporte = [
    query('mes').optional().isInt({ min: 1, max: 12 }),
    query('anio').optional().isInt({ min: 2000, max: 2100 }),
    query('fecha_inicio').optional().isDate(),
    query('fecha_fin').optional().isDate(),
    query('formato').optional().isIn(['pdf', 'excel', 'csv', 'html']),
    query('tipo').optional().isIn(['citas', 'pacientes', 'sesiones', 'becarios'])
];

// Middleware de validaci√≥n
const validarResultados = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            success: false,
            message: 'Errores de validaci√≥n',
            errors: errors.array().map(err => ({
                campo: err.param,
                mensaje: err.msg,
                valor: err.value
            }))
        });
    }
    next();
};

// Validaciones de par√°metros de ruta
const validarId = [
    param('id').isInt(),
    validarResultados
];

const validarPacienteId = [
    param('paciente_id').isInt(),
    validarResultados
];

const validarUsuarioId = [
    param('usuario_id').isInt(),
    validarResultados
];

// Exportar todas las validaciones
module.exports = {
    validacionesComunes,
    validarPaciente,
    validarCita,
    validarSesion,
    validarUsuario,
    validarObservacion,
    validarDisponibilidad,
    validarAlta,
    validarReporte,
    validarResultados,
    validarId,
    validarPacienteId,
    validarUsuarioId
};

/backend\src\models\altaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Alta = sequelize.define('Alta', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_alta: {
        type: DataTypes.ENUM(
            'terapeutica',
            'abandono',
            'traslado',
            'graduacion',
            'no_continua',
            'otro'
        ),
        allowNull: false
    },
    fecha_alta: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    motivo_detallado: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    recomendaciones: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    sesiones_totales: {
        type: DataTypes.INTEGER,
        allowNull: true
    },
    evaluacion_final: {
        type: DataTypes.ENUM('excelente', 'buena', 'regular', 'mala'),
        allowNull: true
    },
    seguimiento_recomendado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    fecha_seguimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    }
}, {
    tableName: 'altas',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['paciente_id']
        },
        {
            fields: ['fecha_alta']
        },
        {
            fields: ['tipo_alta']
        }
    ]
});

Alta.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Alta.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Alta;

/backend\src\models\asignacionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Asignacion = sequelize.define('Asignacion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    fecha_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    motivo_fin: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    estado: {
        type: DataTypes.ENUM('activa', 'finalizada', 'suspendida'),
        defaultValue: 'activa'
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    }
}, {
    tableName: 'asignaciones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['paciente_id', 'estado']
        },
        {
            fields: ['psicologo_id', 'estado']
        },
        {
            fields: ['becario_id']
        }
    ]
});

// Relaciones
Asignacion.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Asignacion.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });
Asignacion.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });

module.exports = Asignacion;

/backend\src\models\citaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Cita = sequelize.define('Cita', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        }
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false
    },
    hora: {
        type: DataTypes.TIME,
        allowNull: false,
        get() {
            // Obtener la hora sin segundos
            const rawValue = this.getDataValue('hora');
            return rawValue ? rawValue.substring(0, 5) : null;
        }
    },
    tipo_consulta: {
        type: DataTypes.ENUM('presencial', 'virtual'),
        allowNull: false,
        defaultValue: 'presencial'
    },
    estado: {
        type: DataTypes.ENUM('programada', 'confirmada', 'completada', 'cancelada'),
        allowNull: false,
        defaultValue: 'programada'
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    motivo_cancelacion: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    duracion: {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 50,
        comment: 'Duraci√≥n en minutos'
    },
    // Mant√©n compatibilidad con duracion_minutos
    duracion_minutos: {
        type: DataTypes.VIRTUAL,
        get() {
            return this.getDataValue('duracion');
        }
    }
}, {
    tableName: 'citas',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['fecha', 'estado']
        },
        {
            fields: ['psicologo_id', 'fecha']
        },
        {
            fields: ['becario_id']
        },
        {
            fields: ['paciente_id']
        }
    ]
});

// Relaciones
Cita.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Cita.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });
Cita.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });

module.exports = Cita;

/backend\src\models\disponibilidadModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Disponibilidad = sequelize.define('Disponibilidad', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    dia_semana: {
        type: DataTypes.ENUM(
            'lunes',
            'martes',
            'miercoles',
            'jueves',
            'viernes',
            'sabado',
            'domingo'
        ),
        allowNull: false
    },
    hora_inicio: {
        type: DataTypes.TIME,
        allowNull: false
    },
    hora_fin: {
        type: DataTypes.TIME,
        allowNull: false
    },
    tipo_disponibilidad: {
        type: DataTypes.ENUM('regular', 'extraordinaria', 'limitada'),
        defaultValue: 'regular'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    },
    fecha_inicio_vigencia: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    fecha_fin_vigencia: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    max_citas_dia: {
        type: DataTypes.INTEGER,
        defaultValue: 8,
        validate: {
            min: 1,
            max: 12
        }
    },
    intervalo_citas: {
        type: DataTypes.INTEGER,
        defaultValue: 50,
        comment: 'Duraci√≥n est√°ndar en minutos'
    }
}, {
    tableName: 'disponibilidades',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['usuario_id', 'dia_semana', 'activo']
        },
        {
            fields: ['fecha_inicio_vigencia', 'fecha_fin_vigencia']
        }
    ]
});

Disponibilidad.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Disponibilidad;

/backend\src\models\expedienteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Paciente = require('./pacienteModel');
const User = require('./userModel');

const Expediente = sequelize.define('Expediente', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    paciente_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Paciente,
            key: 'id'
        },
        unique: true
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    motivo_consulta: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    historia_personal: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    historia_familiar: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    antecedentes_medicos: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    antecedentes_psiquiatricos: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    diagnostico_presuntivo: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    diagnostico_definitivo: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    tratamiento_actual: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    medicamentos: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con medicamentos y dosis'
    },
    alergias: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    factores_riesgo: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con factores de riesgo identificados'
    },
    redes_apoyo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    emergencia_contacto: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    emergencia_telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    consentimiento_informado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    fecha_consentimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    restricciones_acceso: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con IDs de usuarios con acceso restringido'
    },
    notas_confidenciales: {
        type: DataTypes.TEXT,
        allowNull: true,
        comment: 'Solo visible para psic√≥logo asignado'
    }
}, {
    tableName: 'expedientes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

Expediente.belongsTo(Paciente, { foreignKey: 'paciente_id' });
Expediente.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });

module.exports = Expediente;

/backend\src\models\fundacionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const Fundacion = sequelize.define('Fundacion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: true
    },
    direccion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: true,
        validate: {
            isEmail: true
        }
    },
    responsable: {
        type: DataTypes.STRING(255),
        allowNull: true
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    },
    convenio_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    convenio_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    }
}, {
    tableName: 'fundaciones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

module.exports = Fundacion;

/backend\src\models\logSistemaModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const LogSistema = sequelize.define('LogSistema', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_log: {
        type: DataTypes.ENUM(
            'login',
            'logout',
            'creacion',
            'modificacion',
            'eliminacion',
            'error',
            'seguridad',
            'backup',
            'reporte',
            'sistema'
        ),
        allowNull: false
    },
    modulo: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    accion: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    datos_antes: {
        type: DataTypes.JSON,
        allowNull: true
    },
    datos_despues: {
        type: DataTypes.JSON,
        allowNull: true
    },
    ip_address: {
        type: DataTypes.STRING(45),
        allowNull: true
    },
    user_agent: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    severidad: {
        type: DataTypes.ENUM('info', 'advertencia', 'error', 'critico'),
        defaultValue: 'info'
    },
    resuelto: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    }
}, {
    tableName: 'logs_sistema',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['tipo_log', 'created_at']
        },
        {
            fields: ['usuario_id']
        },
        {
            fields: ['modulo']
        },
        {
            fields: ['severidad', 'resuelto']
        }
    ]
});

LogSistema.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = LogSistema;

/backend\src\models\notificacionModel.js:
--------------------------------------------------------------------------------


/backend\src\models\observacionBecarioModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');
const Cita = require('./citaModel');

const ObservacionBecario = sequelize.define('ObservacionBecario', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    becario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    supervisor_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    cita_id: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: Cita,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false,
        defaultValue: DataTypes.NOW
    },
    tipo_observacion: {
        type: DataTypes.ENUM(
            'sesion_observada',
            'retroalimentacion',
            'evaluacion_periodica',
            'incidencia',
            'reconocimiento'
        ),
        defaultValue: 'sesion_observada'
    },
    aspecto_evaluado: {
        type: DataTypes.ENUM(
            'empatia',
            'tecnicas',
            'documentacion',
            'puntualidad',
            'profesionalismo',
            'etica'
        ),
        allowNull: false
    },
    calificacion: {
        type: DataTypes.INTEGER,
        allowNull: false,
        validate: {
            min: 1,
            max: 10
        }
    },
    fortalezas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    areas_mejora: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    recomendaciones: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    plan_accion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    fecha_seguimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    privada: {
        type: DataTypes.BOOLEAN,
        defaultValue: false,
        comment: 'Solo visible para supervisor y becario'
    }
}, {
    tableName: 'observaciones_becarios',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['becario_id', 'fecha']
        },
        {
            fields: ['supervisor_id']
        },
        {
            fields: ['tipo_observacion']
        }
    ]
});

ObservacionBecario.belongsTo(User, { as: 'Becario', foreignKey: 'becario_id' });
ObservacionBecario.belongsTo(User, { as: 'Supervisor', foreignKey: 'supervisor_id' });
ObservacionBecario.belongsTo(Cita, { foreignKey: 'cita_id' });

module.exports = ObservacionBecario;

/backend\src\models\pacienteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const Paciente = sequelize.define('Paciente', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: true,
        validate: {
            isEmail: true
        }
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    fecha_nacimiento: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    genero: {
        type: DataTypes.ENUM('masculino', 'femenino', 'otro', 'prefiero_no_decir'),
        allowNull: true
    },
    direccion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    estado: {
        type: DataTypes.STRING(50),
        allowNull: false,
        defaultValue: 'activo'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    },
    notas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    }
}, {
    tableName: 'pacientes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['activo']
        },
        {
            fields: ['apellido', 'nombre']
        }
    ]
});

module.exports = Paciente;

/backend\src\models\permisoModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Permiso = sequelize.define('Permiso', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false,
        unique: true
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    categoria: {
        type: DataTypes.ENUM(
            'administracion',
            'pacientes',
            'citas',
            'reportes',
            'configuracion',
            'usuarios'
        ),
        allowNull: false
    },
    nivel_requerido: {
        type: DataTypes.ENUM('basico', 'intermedio', 'avanzado', 'administrador'),
        defaultValue: 'basico'
    },
    activo: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    }
}, {
    tableName: 'permisos',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

const UsuarioPermiso = sequelize.define('UsuarioPermiso', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    permiso_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Permiso,
            key: 'id'
        }
    },
    concedido: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    },
    concedido_por: {
        type: DataTypes.INTEGER,
        allowNull: true,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha_concesion: {
        type: DataTypes.DATE,
        allowNull: true
    },
    fecha_expiracion: {
        type: DataTypes.DATE,
        allowNull: true
    },
    motivo: {
        type: DataTypes.TEXT,
        allowNull: true
    }
}, {
    tableName: 'usuario_permisos',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            unique: true,
            fields: ['usuario_id', 'permiso_id']
        }
    ]
});

// Relaciones
UsuarioPermiso.belongsTo(User, { as: 'Usuario', foreignKey: 'usuario_id' });
UsuarioPermiso.belongsTo(User, { as: 'ConcedidoPor', foreignKey: 'concedido_por' });
UsuarioPermiso.belongsTo(Permiso, { foreignKey: 'permiso_id' });

module.exports = { Permiso, UsuarioPermiso };

/backend\src\models\reporteModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const User = require('./userModel');

const Reporte = sequelize.define('Reporte', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    usuario_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    tipo_reporte: {
        type: DataTypes.ENUM(
            'mensual',
            'trimestral',
            'semestral',
            'anual',
            'personalizado',
            'paciente',
            'becario',
            'psicologo'
        ),
        allowNull: false
    },
    nombre: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    descripcion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    parametros: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con par√°metros del reporte'
    },
    fecha_inicio: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    fecha_fin: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    formato: {
        type: DataTypes.ENUM('pdf', 'excel', 'csv', 'html'),
        defaultValue: 'pdf'
    },
    archivo_url: {
        type: DataTypes.STRING(500),
        allowNull: true
    },
    archivo_tamano: {
        type: DataTypes.INTEGER,
        allowNull: true,
        comment: 'Tama√±o en bytes'
    },
    estado: {
        type: DataTypes.ENUM('pendiente', 'generando', 'completado', 'error'),
        defaultValue: 'pendiente'
    },
    compartido_con: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con IDs de usuarios con acceso'
    }
}, {
    tableName: 'reportes',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['usuario_id']
        },
        {
            fields: ['tipo_reporte', 'estado']
        },
        {
            fields: ['created_at']
        }
    ]
});

Reporte.belongsTo(User, { foreignKey: 'usuario_id' });

module.exports = Reporte;

/backend\src\models\sesionModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Cita = require('./citaModel');
const User = require('./userModel');

const Sesion = sequelize.define('Sesion', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    cita_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: Cita,
            key: 'id'
        },
        unique: true
    },
    psicologo_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
            model: User,
            key: 'id'
        }
    },
    fecha: {
        type: DataTypes.DATEONLY,
        allowNull: false
    },
    hora_inicio: {
        type: DataTypes.TIME,
        allowNull: false
    },
    hora_fin: {
        type: DataTypes.TIME,
        allowNull: false
    },
    tipo_sesion: {
        type: DataTypes.ENUM('evaluacion', 'terapia', 'seguimiento', 'crisis'),
        defaultValue: 'terapia'
    },
    objetivo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    desarrollo: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    conclusion: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    tareas_asignadas: {
        type: DataTypes.TEXT,
        allowNull: true
    },
    emocion_predominante: {
        type: DataTypes.STRING(100),
        allowNull: true
    },
    riesgo_suicida: {
        type: DataTypes.ENUM('ninguno', 'bajo', 'moderado', 'alto'),
        defaultValue: 'ninguno'
    },
    escalas_aplicadas: {
        type: DataTypes.JSON,
        allowNull: true,
        comment: 'JSON con escalas aplicadas y puntajes'
    },
    siguiente_cita: {
        type: DataTypes.DATEONLY,
        allowNull: true
    },
    privado: {
        type: DataTypes.BOOLEAN,
        defaultValue: false,
        comment: 'Si solo psic√≥logo puede ver'
    }
}, {
    tableName: 'sesiones',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true,
    indexes: [
        {
            fields: ['cita_id']
        },
        {
            fields: ['psicologo_id', 'fecha']
        },
        {
            fields: ['fecha']
        }
    ]
});

// Relaciones
Sesion.belongsTo(Cita, { foreignKey: 'cita_id' });
Sesion.belongsTo(User, { as: 'Psicologo', foreignKey: 'psicologo_id' });

module.exports = Sesion;

/backend\src\models\userModel.js:
--------------------------------------------------------------------------------
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');

const User = sequelize.define('User', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    email: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: {
            msg: 'El correo electr√≥nico ya est√° registrado'
        },
        validate: {
            isEmail: {
                msg: 'Debe proporcionar un correo electr√≥nico v√°lido'
            },
            notEmpty: true
        }
    },
    password: {
        type: DataTypes.STRING(255),
        allowNull: false,
        validate: {
            notEmpty: true
        }
    },
    nombre: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    apellido: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    telefono: {
        type: DataTypes.STRING(20),
        allowNull: true
    },
    rol: {
        type: DataTypes.ENUM('coordinador', 'psicologo', 'becario'),
        allowNull: false,
        defaultValue: 'becario'
    },
    especialidad: {
        type: DataTypes.STRING(100),
        allowNull: true
    },
    fundacion_id: {
        type: DataTypes.INTEGER,
        allowNull: true
    },
    activo: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true
    }
}, {
    tableName: 'users',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    underscored: true
});

module.exports = User;

/backend\src\routes\agendaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AgendaController = require('../controllers/agendaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Obtener agendas
router.get('/global', AgendaController.obtenerAgendaGlobal);
router.get('/diaria', AgendaController.obtenerAgendaDiaria);
router.get('/mensual', AgendaController.obtenerCalendarioMensual);
router.get('/disponibilidad-profesionales', AgendaController.obtenerDisponibilidadProfesionales);

// Reprogramar citas
router.put('/cita/:id/reprogramar', requireRole(['psicologo', 'becario', 'coordinador']), AgendaController.reprogramarCita);

module.exports = router;

/backend\src\routes\altaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AltaController = require('../controllers/altaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Dar de alta paciente
router.post('/', requireRole(['psicologo', 'coordinador']), AltaController.darAltaPaciente);

// Obtener altas
router.get('/', requireRole(['coordinador', 'psicologo']), AltaController.obtenerAltas);
router.get('/estadisticas', requireRole(['coordinador']), AltaController.obtenerEstadisticasAltas);
router.get('/:id', requireRole(['coordinador', 'psicologo']), AltaController.obtenerAltaDetalle);

module.exports = router;

/backend\src\routes\asignacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AsignacionController = require('../controllers/asignacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Rutas para coordinadores
router.post('/', requireRole(['coordinador']), AsignacionController.crearAsignacion);
router.get('/', requireRole(['coordinador']), AsignacionController.obtenerAsignacionesActivas);
router.put('/:id/finalizar', requireRole(['coordinador', 'psicologo']), AsignacionController.finalizarAsignacion);
router.get('/paciente/:paciente_id/historial', requireRole(['coordinador', 'psicologo']), AsignacionController.obtenerHistorialAsignaciones);

// Rutas para psic√≥logos y becarios
router.get('/mis-pacientes', requireRole(['psicologo', 'becario']), AsignacionController.obtenerMisPacientes);

module.exports = router;

/backend\src\routes\authRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const AuthController = require('../controllers/authController');
const verifyToken = require('../middlewares/authMiddleware');

router.post('/login', AuthController.login);
router.get('/me', verifyToken, AuthController.getMe);

module.exports = router;

/backend\src\routes\citaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const CitaController = require('../controllers/citaController');
const verifyToken = require('../middlewares/authMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Rutas de consulta
router.get('/citas-por-fecha', CitaController.obtenerCitasPorFecha);
router.get('/reporte-mensual', CitaController.generarReporteMensual);
router.get('/estadisticas', CitaController.obtenerEstadisticas);

// Rutas de modificaci√≥n
router.post('/alta-paciente', CitaController.darAltaPaciente);
router.put('/cita/:id', CitaController.actualizarCita);
router.post('/nueva', CitaController.crearNuevaCita);

module.exports = router;

/backend\src\routes\dashboardRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const DashboardController = require('../controllers/dashboardController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Dashboards por rol
router.get('/coordinador', requireRole(['coordinador']), DashboardController.obtenerDashboardCoordinador);
router.get('/psicologo', requireRole(['psicologo']), DashboardController.obtenerDashboardPsicologo);
router.get('/becario', requireRole(['becario']), DashboardController.obtenerDashboardBecario);

// M√©tricas globales
router.get('/metricas-globales', requireRole(['coordinador']), DashboardController.obtenerMetricasGlobales);

module.exports = router;

/backend\src\routes\disponibilidadRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const DisponibilidadController = require('../controllers/disponibilidadController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Gesti√≥n de disponibilidad personal
router.post('/', requireRole(['psicologo', 'becario']), DisponibilidadController.crearDisponibilidad);
router.get('/mi-disponibilidad', requireRole(['psicologo', 'becario']), DisponibilidadController.obtenerMiDisponibilidad);
router.put('/:id', requireRole(['psicologo', 'becario']), DisponibilidadController.actualizarDisponibilidad);
router.put('/:id/desactivar', requireRole(['psicologo', 'becario']), DisponibilidadController.desactivarDisponibilidad);

// Consulta de disponibilidad
router.get('/usuario/:usuario_id', requireRole(['coordinador', 'psicologo']), DisponibilidadController.obtenerDisponibilidadUsuario);
router.get('/horarios-disponibles', requireRole(['coordinador', 'psicologo', 'becario']), DisponibilidadController.obtenerHorariosDisponibles);

module.exports = router;

/backend\src\routes\estadisticaRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const EstadisticaController = require('../controllers/estadisticaController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Estad√≠sticas generales
router.get('/generales', requireRole(['coordinador']), EstadisticaController.obtenerEstadisticasGenerales);
router.get('/reporte-comparativo', requireRole(['coordinador']), EstadisticaController.obtenerReporteComparativo);

// Estad√≠sticas por rol/profesional
router.get('/psicologo', requireRole(['coordinador', 'psicologo']), EstadisticaController.obtenerEstadisticasPsicologo);
router.get('/becario', requireRole(['coordinador', 'psicologo', 'becario']), EstadisticaController.obtenerEstadisticasBecario);
router.get('/paciente/:paciente_id', requireRole(['coordinador', 'psicologo']), EstadisticaController.obtenerEstadisticasPaciente);

module.exports = router;

/backend\src\routes\expedienteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ExpedienteController = require('../controllers/expedienteController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Obtener expedientes
router.get('/paciente/:paciente_id/completo', requireRole(['psicologo', 'becario', 'coordinador']), ExpedienteController.obtenerExpedienteCompleto);
router.get('/paciente/:paciente_id/resumen', requireRole(['psicologo', 'becario', 'coordinador']), ExpedienteController.obtenerResumenExpediente);

// Crear y actualizar expedientes
router.post('/paciente/:paciente_id', requireRole(['psicologo', 'coordinador']), ExpedienteController.crearExpediente);
router.put('/paciente/:paciente_id', requireRole(['psicologo', 'coordinador']), ExpedienteController.actualizarExpediente);

// Notas confidenciales
router.post('/paciente/:paciente_id/nota-confidencial', requireRole(['psicologo', 'coordinador']), ExpedienteController.agregarNotaConfidencial);

module.exports = router;

/backend\src\routes\fundacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const FundacionController = require('../controllers/fundacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Rutas para coordinadores
router.post('/', requireRole(['coordinador']), FundacionController.crearFundacion);
router.get('/', requireRole(['coordinador', 'psicologo']), FundacionController.obtenerFundaciones);
router.get('/:id', requireRole(['coordinador', 'psicologo']), FundacionController.obtenerFundacion);
router.put('/:id', requireRole(['coordinador']), FundacionController.actualizarFundacion);
router.put('/:id/desactivar', requireRole(['coordinador']), FundacionController.desactivarFundacion);

module.exports = router;

/backend\src\routes\notificacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const NotificacionController = require('../controllers/notificacionController');
const verifyToken = require('../middlewares/authMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Obtener notificaciones del usuario
router.get('/', NotificacionController.obtenerMisNotificaciones);
router.get('/recientes', NotificacionController.obtenerNotificacionesRecientes);

// Marcar notificaciones como le√≠das
router.put('/:id/leer', NotificacionController.marcarComoLeido);
router.put('/leer-todas', NotificacionController.marcarTodasComoLeidas);

// Crear notificaci√≥n (solo coordinadores)
router.post('/', verifyToken, NotificacionController.crearNotificacion);

// Eliminar notificaci√≥n
router.delete('/:id', NotificacionController.eliminarNotificacion);

module.exports = router;

/backend\src\routes\observacionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ObservacionController = require('../controllers/observacionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Crear observaci√≥n (solo psic√≥logos y coordinadores)
router.post('/', requireRole(['psicologo', 'coordinador']), ObservacionController.crearObservacion);

// Obtener observaciones
router.get('/becario/:becario_id', requireRole(['psicologo', 'becario', 'coordinador']), ObservacionController.obtenerObservacionesBecario);
router.get('/supervisor', requireRole(['psicologo', 'coordinador']), ObservacionController.obtenerObservacionesSupervisor);

// Actualizar y eliminar observaciones
router.put('/:id', requireRole(['psicologo', 'coordinador']), ObservacionController.actualizarObservacion);
router.delete('/:id', requireRole(['psicologo', 'coordinador']), ObservacionController.eliminarObservacion);

module.exports = router;

/backend\src\routes\pacienteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');
const Paciente = require('../models/pacienteModel');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db'); // A√ëADE ESTA IMPORTACI√ìN

// Listar pacientes (solo coordinadores)
router.get('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const pacientes = await Paciente.findAll({
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });

    const mapped = pacientes.map(p => ({
      id: p.id,
      nombre: p.nombre,
      apellido: p.apellido,
      email: p.email,
      telefono: p.telefono,
      fecha_nacimiento: p.fecha_nacimiento,
      genero: p.genero,
      direccion: p.direccion,
      estado: p.estado,
      activo: p.activo,
      notas: p.notas,
      fundacion_id: p.fundacion_id,
      fecha_ingreso: p.created_at,
      fecha_alta: p.deleted_at || null
    }));

    res.json(mapped);
  } catch (error) {
    console.error('Error al listar pacientes:', error);
    res.status(500).json({ message: 'Error al obtener pacientes' });
  }
});

// Crear paciente (solo coordinadores)
router.post('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const data = req.body;
    if (!data.nombre || !data.apellido || !data.motivo_consulta) {
      return res.status(400).json({ message: 'Faltan datos requeridos' });
    }

    const paciente = await Paciente.create({
      nombre: data.nombre,
      apellido: data.apellido,
      email: data.email || null,
      telefono: data.telefono || null,
      fecha_nacimiento: data.fecha_nacimiento || null,
      genero: data.genero || null,
      direccion: data.direccion || null,
      estado: data.estado || 'activo',
      activo: typeof data.activo === 'boolean' ? data.activo : true,
      notas: data.antecedentes || null,
      fundacion_id: data.fundacion_id || null
    });

    res.status(201).json({
      id: paciente.id,
      nombre: paciente.nombre,
      apellido: paciente.apellido,
      email: paciente.email,
      telefono: paciente.telefono,
      fecha_nacimiento: paciente.fecha_nacimiento,
      genero: paciente.genero,
      direccion: paciente.direccion,
      estado: paciente.estado,
      activo: paciente.activo,
      fecha_ingreso: paciente.created_at,
      sesiones_completadas: 0
    });
  } catch (error) {
    console.error('Error al crear paciente:', error);
    res.status(500).json({ message: 'Error al crear paciente' });
  }
});

// Actualizar paciente (solo coordinadores)
router.put('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const paciente = await Paciente.findByPk(id);
    if (!paciente) return res.status(404).json({ message: 'Paciente no encontrado' });

    const data = req.body;
    const updated = await paciente.update({
      nombre: data.nombre ?? paciente.nombre,
      apellido: data.apellido ?? paciente.apellido,
      email: data.email ?? paciente.email,
      telefono: data.telefono ?? paciente.telefono,
      fecha_nacimiento: data.fecha_nacimiento ?? paciente.fecha_nacimiento,
      genero: data.genero ?? paciente.genero,
      direccion: data.direccion ?? paciente.direccion,
      estado: data.estado ?? paciente.estado,
      activo: typeof data.activo === 'boolean' ? data.activo : paciente.activo,
      notas: data.antecedentes ?? paciente.notas,
      fundacion_id: data.fundacion_id ?? paciente.fundacion_id
    });

    res.json({
      id: updated.id,
      nombre: updated.nombre,
      apellido: updated.apellido,
      email: updated.email,
      telefono: updated.telefono,
      fecha_nacimiento: updated.fecha_nacimiento,
      genero: updated.genero,
      direccion: updated.direccion,
      estado: updated.estado,
      activo: updated.activo,
      fecha_ingreso: updated.created_at
    });
  } catch (error) {
    console.error('Error al actualizar paciente:', error);
    res.status(500).json({ message: 'Error al actualizar paciente' });
  }
});

// Eliminar paciente (soft-delete) (solo coordinadores)
router.delete('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const paciente = await Paciente.findByPk(id);
    if (!paciente) return res.status(404).json({ message: 'Paciente no encontrado' });

    await paciente.update({ activo: false, estado: 'alta_terapeutica' });

    res.json({ message: 'Paciente inactivado correctamente', id: paciente.id });
  } catch (error) {
    console.error('Error al eliminar paciente:', error);
    res.status(500).json({ message: 'Error al eliminar paciente' });
  }
});

// Obtener pacientes activos
router.get('/activos', verifyToken, requireRole(['coordinador', 'psicologo']), async (req, res) => {
    try {
        const query = `
            SELECT 
                p.*,
                CONCAT(p.nombre, ' ', p.apellido) as nombre_completo,
                TIMESTAMPDIFF(YEAR, p.fecha_nacimiento, CURDATE()) as edad,
                COUNT(DISTINCT c.id) as sesiones_completadas,
                CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                a.fecha_inicio,
                e.motivo_consulta
            FROM pacientes p
            LEFT JOIN expedientes e ON p.id = e.paciente_id
            LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
            LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
            LEFT JOIN users u_bec ON a.becario_id = u_bec.id
            LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
            WHERE p.activo = true
            GROUP BY p.id, e.id, u_psi.id, u_bec.id, a.id
            ORDER BY p.apellido, p.nombre
        `;
        
        const pacientes = await sequelize.query(query, {
            type: QueryTypes.SELECT
        });
        
        res.json({
            success: true,
            data: pacientes
        });
        
    } catch (error) {
        console.error('Error al obtener pacientes activos:', error);
        res.status(500).json({
            success: false,
            message: 'Error al obtener pacientes activos',
            error: error.message
        });
    }
});

router.get('/candidatos-alta', verifyToken, requireRole(['coordinador', 'psicologo']), async (req, res) => {
    try {
        console.log('üîç Solicitando candidatos a alta...');
        
        // Query CORREGIDA - solo agrupa por las columnas del SELECT
        const query = `
            SELECT 
                p.id,
                CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                TIMESTAMPDIFF(YEAR, p.fecha_nacimiento, CURDATE()) as edad,
                e.motivo_consulta,
                DATE(p.created_at) as fecha_ingreso,
                COUNT(DISTINCT c.id) as sesiones_completadas,
                CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                CASE 
                    WHEN COUNT(DISTINCT c.id) >= 15 THEN 85
                    WHEN COUNT(DISTINCT c.id) >= 10 THEN 70
                    WHEN COUNT(DISTINCT c.id) >= 5 THEN 50
                    ELSE 30
                END as progreso_estimado
            FROM pacientes p
            LEFT JOIN expedientes e ON p.id = e.paciente_id
            LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
            LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
            LEFT JOIN users u_bec ON a.becario_id = u_bec.id
            LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
            WHERE p.activo = true
            -- EXCLUIR pacientes marcados como no aprobados en los √∫ltimos 30 d√≠as
            AND (p.ultimo_no_aprobado IS NULL OR p.ultimo_no_aprobado < DATE_SUB(CURDATE(), INTERVAL 30 DAY))
            GROUP BY p.id, e.motivo_consulta, u_psi.nombre, u_psi.apellido, u_bec.nombre, u_bec.apellido
            HAVING COUNT(DISTINCT c.id) >= 3
            ORDER BY COUNT(DISTINCT c.id) DESC
            LIMIT 10
        `;
        
        console.log('üìä Ejecutando query de candidatos a alta...');
        const candidatos = await sequelize.query(query, {
            type: QueryTypes.SELECT
        });
        
        console.log(`‚úÖ Candidatos encontrados: ${candidatos.length}`);
        
        // Para debugging: mostrar qu√© pacientes se encontraron
        if (candidatos.length > 0) {
            console.log('üìã Lista de candidatos encontrados:');
            candidatos.forEach((c, i) => {
                console.log(`${i + 1}. ${c.paciente_nombre} - ${c.sesiones_completadas} sesiones`);
            });
        }
        
        res.json({
            success: true,
            data: candidatos
        });
        
    } catch (error) {
        console.error('‚ùå Error CR√çTICO al obtener candidatos a alta:', error);
        console.error('üìå Mensaje de error:', error.message);
        console.error('üìå Stack trace:', error.stack);
        
        // Para debugging: probar una query m√°s simple
        try {
            console.log('üîÑ Probando query alternativa...');
            const querySimple = `
                SELECT p.id, CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre, 
                       p.ultimo_no_aprobado
                FROM pacientes p
                WHERE p.activo = true
                LIMIT 5
            `;
            const prueba = await sequelize.query(querySimple, { type: QueryTypes.SELECT });
            console.log('üîç Resultado de prueba:', prueba);
        } catch (err) {
            console.error('‚ùå Error en query de prueba:', err.message);
        }
        
        res.status(500).json({
            success: false,
            message: 'Error al obtener candidatos a alta: ' + error.message,
            debug: process.env.NODE_ENV === 'development' ? {
                error: error.message,
                stack: error.stack
            } : undefined
        });
    }
});

// Obtener paciente por ID con detalles
router.get('/:id', verifyToken, requireRole(['coordinador', 'psicologo']), async (req, res) => {
    try {
        const { id } = req.params;
        
        const query = `
            SELECT 
                p.*,
                CONCAT(p.nombre, ' ', p.apellido) as nombre_completo,
                TIMESTAMPDIFF(YEAR, p.fecha_nacimiento, CURDATE()) as edad,
                COUNT(DISTINCT c.id) as sesiones_completadas,
                CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                a.fecha_inicio,
                a.estado as estado_asignacion,
                e.motivo_consulta,
                e.diagnostico_presuntivo,
                e.riesgo_suicida
            FROM pacientes p
            LEFT JOIN expedientes e ON p.id = e.paciente_id
            LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
            LEFT JOIN users u_psi ON a.psicologo_id = u_psi.id
            LEFT JOIN users u_bec ON a.becario_id = u_bec.id
            LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
            WHERE p.id = ?
            GROUP BY p.id, e.id, u_psi.id, u_bec.id, a.id
        `;
        
        const [paciente] = await sequelize.query(query, {
            replacements: [id],
            type: QueryTypes.SELECT
        });
        
        if (!paciente) {
            return res.status(404).json({
                success: false,
                message: 'Paciente no encontrado'
            });
        }
        
        res.json({
            success: true,
            data: paciente
        });
        
    } catch (error) {
        console.error('Error al obtener paciente:', error);
        res.status(500).json({
            success: false,
            message: 'Error al obtener paciente'
        });
    }
});

// backend/src/routes/pacienteRoutes.js - Agrega este endpoint
router.post('/:id/marcar-no-aprobado', verifyToken, requireRole(['coordinador', 'psicologo']), async (req, res) => {
    try {
        const { id } = req.params;
        const { motivo } = req.body;
        
        // Registrar en logs o en una tabla espec√≠fica
        await sequelize.query(`
            INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
            VALUES (?, 'modificacion', 'altas', 'No aprobar alta paciente', ?, NOW())
        `, {
            replacements: [req.user.id, `Paciente ${id} no aprobado para alta - Motivo: ${motivo || 'Sin motivo especificado'}`]
        });
        
        // Tambi√©n podr√≠as crear una notificaci√≥n para el psic√≥logo
        const [pacienteInfo] = await sequelize.query(`
            SELECT CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                   a.psicologo_id
            FROM pacientes p
            LEFT JOIN asignaciones a ON p.id = a.paciente_id AND a.estado = 'activa'
            WHERE p.id = ?
        `, {
            replacements: [id],
            type: QueryTypes.SELECT
        });
        
        if (pacienteInfo && pacienteInfo.psicologo_id) {
            await sequelize.query(`
                INSERT INTO notificaciones (usuario_id, tipo, titulo, mensaje, created_at)
                VALUES (?, 'observacion_nueva', 'Paciente no aprobado para alta', 
                        CONCAT('El paciente ', ?, ' no fue aprobado para alta terap√©utica. Continuar tratamiento.'), NOW())
            `, {
                replacements: [pacienteInfo.psicologo_id, pacienteInfo.paciente_nombre]
            });
        }
        
        res.json({
            success: true,
            message: 'Paciente marcado como no aprobado para alta'
        });
        
    } catch (error) {
        console.error('Error al marcar paciente como no aprobado:', error);
        res.status(500).json({
            success: false,
            message: 'Error al procesar la solicitud'
        });
    }
});

router.post('/:id/no-aprobar-alta', verifyToken, requireRole(['coordinador', 'psicologo']), async (req, res) => {
    try {
        const { id } = req.params;
        const { motivo } = req.body || {}; // Agregar campo para motivo
        
        console.log(`üìù Marcando paciente ${id} como no aprobado...`);
        
        // Verificar que el paciente existe y est√° activo
        const paciente = await Paciente.findByPk(id);
        
        if (!paciente || !paciente.activo) {
            return res.status(404).json({
                success: false,
                message: 'Paciente no encontrado o ya inactivo'
            });
        }
        
        // 1. Obtener estad√≠sticas del paciente
        const [estadisticas] = await sequelize.query(`
            SELECT 
                COUNT(*) as total_sesiones,
                COUNT(CASE WHEN estado = 'completada' THEN 1 END) as sesiones_completadas
            FROM citas 
            WHERE paciente_id = ?
            AND estado IN ('completada', 'cancelada')
        `, {
            replacements: [id],
            type: QueryTypes.SELECT
        });
        
        // 2. Crear registro en la tabla altas con tipo 'no_aprobado'
        await sequelize.query(`
            INSERT INTO altas (
                paciente_id, 
                usuario_id, 
                tipo_alta, 
                fecha_alta, 
                motivo_detallado, 
                sesiones_totales,
                created_at
            ) VALUES (?, ?, ?, CURDATE(), ?, ?, NOW())
        `, {
            replacements: [
                id,
                req.user.id,
                'no_aprobado',  // Nuevo tipo de alta
                motivo || 'Paciente no aprobado para alta terap√©utica por el coordinador',
                estadisticas?.sesiones_completadas || 0
            ]
        });
        
        // 3. Actualizar la columna ultimo_no_aprobado (para no mostrarlo en candidatos)
        await sequelize.query(`
            UPDATE pacientes 
            SET ultimo_no_aprobado = CURDATE()
            WHERE id = ?
        `, {
            replacements: [id]
        });
        
        // 4. Registrar en logs
        await sequelize.query(`
            INSERT INTO logs_sistema (usuario_id, tipo_log, modulo, accion, descripcion, created_at)
            VALUES (?, 'modificacion', 'altas', 'No aprobar alta', ?, NOW())
        `, {
            replacements: [req.user.id, `Paciente ${id} (${paciente.nombre} ${paciente.apellido}) NO APROBADO para alta`]
        });
        
        // 5. Obtener el ID del registro de alta creado
        const [altaCreada] = await sequelize.query(`
            SELECT * FROM altas 
            WHERE paciente_id = ? 
            AND tipo_alta = 'no_aprobado'
            ORDER BY created_at DESC 
            LIMIT 1
        `, {
            replacements: [id],
            type: QueryTypes.SELECT
        });
        
        console.log(`‚úÖ Paciente ${id} registrado como NO APROBADO en tabla altas`);
        
        res.json({
            success: true,
            message: 'Paciente registrado como no aprobado para alta',
            data: {
                paciente_id: id,
                alta_id: altaCreada?.id,
                fecha_no_aprobado: new Date().toISOString().split('T')[0],
                paciente_nombre: `${paciente.nombre} ${paciente.apellido}`,
                tipo_alta: 'no_aprobado'
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error al marcar paciente como no aprobado:', error);
        console.error('üìå Detalles del error:', error.message);
        res.status(500).json({
            success: false,
            message: 'Error al procesar la solicitud: ' + error.message
        });
    }
});
module.exports = router;

/backend\src\routes\reporteRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const ReporteController = require('../controllers/reporteController');
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Exportar agenda a CSV
router.post('/exportar-agenda-csv', ReporteController.exportarAgendaCSV);

// Exportar disponibilidad a CSV
router.post('/exportar-disponibilidad-csv', ReporteController.exportarDisponibilidadCSV);

// Generar reporte de conflictos
router.post('/reporte-conflictos', ReporteController.generarReporteConflictos);

router.get('/altas', verifyToken, requireRole(['coordinador']), async (req, res) => {
    try {
        const { formato = 'excel', fecha_inicio, fecha_fin } = req.query;
        
        let query = `
            SELECT 
                a.*,
                CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                p.fecha_nacimiento,
                p.genero,
                p.telefono,
                CONCAT(u.nombre, ' ', u.apellido) as profesional_alta,
                e.motivo_consulta,
                COUNT(DISTINCT c.id) as sesiones_completadas
            FROM altas a
            JOIN pacientes p ON a.paciente_id = p.id
            JOIN users u ON a.usuario_id = u.id
            LEFT JOIN expedientes e ON p.id = e.paciente_id
            LEFT JOIN citas c ON p.id = c.paciente_id AND c.estado = 'completada'
            WHERE 1=1
        `;
        
        const replacements = [];
        
        if (fecha_inicio) {
            query += ` AND a.fecha_alta >= ?`;
            replacements.push(fecha_inicio);
        }
        
        if (fecha_fin) {
            query += ` AND a.fecha_alta <= ?`;
            replacements.push(fecha_fin);
        }
        
        query += ` GROUP BY a.id, p.id, u.id, e.id
                  ORDER BY a.fecha_alta DESC`;
        
        const altas = await sequelize.query(query, {
            replacements,
            type: QueryTypes.SELECT
        });
        
        // Para una implementaci√≥n real, aqu√≠ generar√≠as el archivo Excel/PDF
        // Por ahora, simulamos la URL
        const archivoUrl = `/temp/reporte-altas-${Date.now()}.${formato}`;
        
        res.json({
            success: true,
            data: {
                archivo_url: archivoUrl,
                total_registros: altas.length,
                fecha_generacion: new Date().toISOString()
            }
        });
        
    } catch (error) {
        console.error('Error generando reporte de altas:', error);
        res.status(500).json({
            success: false,
            message: 'Error al generar reporte de altas'
        });
    }
});
module.exports = router;

/backend\src\routes\roleRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const RoleController = require('../controllers/roleController');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Obtener permisos del usuario actual
router.get('/my-permissions', RoleController.getMyPermissions);

// Obtener informaci√≥n espec√≠fica del rol
router.get('/my-role-info', RoleController.getUserRoleInfo);

// Verificar permiso espec√≠fico
router.get('/check-permission/:permission', RoleController.checkPermission);

module.exports = router;

/backend\src\routes\sesionRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const SesionController = require('../controllers/sesionController');
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');

// Todas las rutas requieren autenticaci√≥n
router.use(verifyToken);

// Registrar sesi√≥n (solo psic√≥logos y coordinadores)
router.post('/', requireRole(['psicologo', 'coordinador']), SesionController.registrarSesion);

// Obtener sesiones
router.get('/paciente/:paciente_id', requireRole(['psicologo', 'becario', 'coordinador']), SesionController.obtenerSesionesPaciente);
router.get('/:id', requireRole(['psicologo', 'becario', 'coordinador']), SesionController.obtenerSesionDetalle);

// Actualizar sesi√≥n (solo psic√≥logo creador o coordinador)
router.put('/:id', requireRole(['psicologo', 'coordinador']), SesionController.actualizarSesion);

module.exports = router;

/backend\src\routes\userRoutes.js:
--------------------------------------------------------------------------------
const express = require('express');
const router = express.Router();
const verifyToken = require('../middlewares/authMiddleware');
const { requireRole } = require('../middlewares/roleMiddleware');
const bcrypt = require('bcryptjs');
const User = require('../models/userModel');

// Obtener todos los becarios
router.get('/becarios', verifyToken, async (req, res) => {
  try {
    const becarios = await User.findAll({
      where: { rol: 'becario', activo: true },
      attributes: ['id', 'nombre', 'apellido', 'email'],
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });
    
    res.json(becarios);
  } catch (error) {
    res.status(500).json({ message: 'Error al obtener becarios' });
  }
});

// Obtener todos los usuarios (coordinadores pueden acceder)
router.get('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: ['id', 'nombre', 'apellido', 'email', 'telefono', 'rol', 'especialidad', 'fundacion_id', 'activo', 'created_at'],
      order: [['apellido', 'ASC'], ['nombre', 'ASC']]
    });

    // Mapear created_at a fecha_registro para compatibilidad con frontend
    const mapped = users.map(u => ({
      id: u.id,
      nombre: u.nombre,
      apellido: u.apellido,
      email: u.email,
      telefono: u.telefono,
      rol: u.rol,
      especialidad: u.especialidad,
      fundacion_id: u.fundacion_id,
      activo: u.activo,
      fecha_registro: u.created_at
    }));

    res.json(mapped);
  } catch (error) {
    console.error('Error al listar usuarios:', error);
    res.status(500).json({ message: 'Error al obtener usuarios' });
  }
});

// Crear nuevo usuario (solo coordinadores)
router.post('/', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const { nombre, apellido, email, telefono, rol, especialidad, fundacion_id, activo, password } = req.body;

    if (!nombre || !apellido || !email || !password) {
      return res.status(400).json({ message: 'Faltan datos requeridos' });
    }

    // Hashear contrase√±a
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(password, salt);

    const newUser = await User.create({
      nombre,
      apellido,
      email,
      telefono,
      rol: rol || 'becario',
      especialidad,
      fundacion_id: fundacion_id || null,
      activo: typeof activo === 'boolean' ? activo : true,
      password: hashed
    });

    res.status(201).json({
      id: newUser.id,
      nombre: newUser.nombre,
      apellido: newUser.apellido,
      email: newUser.email,
      telefono: newUser.telefono,
      rol: newUser.rol,
      especialidad: newUser.especialidad,
      fundacion_id: newUser.fundacion_id,
      activo: newUser.activo,
      fecha_registro: newUser.created_at
    });

  } catch (error) {
    console.error('Error al crear usuario:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: 'El correo ya est√° registrado' });
    }
    res.status(500).json({ message: 'Error al crear usuario' });
  }
});

// Actualizar usuario (solo coordinadores)
router.put('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const { nombre, apellido, email, telefono, rol, especialidad, fundacion_id, activo, password } = req.body;

    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: 'Usuario no encontrado' });
    }

    const updatedFields = {
      nombre: nombre ?? user.nombre,
      apellido: apellido ?? user.apellido,
      email: email ?? user.email,
      telefono: telefono ?? user.telefono,
      rol: rol ?? user.rol,
      especialidad: especialidad ?? user.especialidad,
      fundacion_id: fundacion_id ?? user.fundacion_id,
      activo: typeof activo === 'boolean' ? activo : user.activo
    };

    // Si env√≠an password, hashearla
    if (password) {
      const salt = await bcrypt.genSalt(10);
      updatedFields.password = await bcrypt.hash(password, salt);
    }

    await user.update(updatedFields);

    res.json({
      id: user.id,
      nombre: user.nombre,
      apellido: user.apellido,
      email: user.email,
      telefono: user.telefono,
      rol: user.rol,
      especialidad: user.especialidad,
      fundacion_id: user.fundacion_id,
      activo: user.activo,
      fecha_registro: user.created_at
    });
  } catch (error) {
    console.error('Error al actualizar usuario:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: 'El correo ya est√° registrado' });
    }
    res.status(500).json({ message: 'Error al actualizar usuario' });
  }
});

// Eliminar usuario (soft-delete colocando activo=false) (solo coordinadores)
router.delete('/:id', verifyToken, requireRole(['coordinador']), async (req, res) => {
  try {
    const id = req.params.id;
    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: 'Usuario no encontrado' });
    }

    // Soft-delete
    await user.update({ activo: false });

    res.json({ message: 'Usuario eliminado (inactivado) correctamente', id: user.id });
  } catch (error) {
    console.error('Error al eliminar usuario:', error);
    res.status(500).json({ message: 'Error al eliminar usuario' });
  }
});

module.exports = router;

/backend\src\services\api.js:
--------------------------------------------------------------------------------
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  static async get(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async post(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async put(url, data) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
    return this.handleResponse(response);
  }

  static async delete(url) {
    const response = await fetch(`${API_BASE_URL}${url}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });
    return this.handleResponse(response);
  }

  static async handleResponse(response) {
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Error en la petici√≥n');
    }
    return response.json();
  }
  static async getDashboardCoordinador() {
    return this.get('/dashboard/coordinador');
  }

  static async getMetricasGlobales(periodo = 'mes') {
    return this.get(`/dashboard/metricas-globales?periodo=${periodo}`);
  }

  static async getEstadisticas() {
    return this.get('/estadisticas/generales');
  }
}

export default ApiService;

/backend\src\services\backupService.js:
--------------------------------------------------------------------------------
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class BackupService {
    
    static async realizarBackupCompleto() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupDir = path.join(__dirname, '..', '..', 'backups', timestamp);
            
            // Crear directorio de backup
            await fs.mkdir(backupDir, { recursive: true });
            
            console.log(`üîÑ Iniciando backup completo: ${timestamp}`);
            
            // 1. Backup de base de datos
            const dbBackup = await this.realizarBackupBaseDatos(backupDir);
            
            // 2. Backup de archivos subidos
            const filesBackup = await this.realizarBackupArchivos(backupDir);
            
            // 3. Backup de configuraci√≥n
            const configBackup = await this.realizarBackupConfiguracion(backupDir);
            
            // 4. Generar archivo de metadatos
            await this.generarMetadataBackup(backupDir, {
                timestamp,
                dbBackup,
                filesBackup,
                configBackup,
                sistema: 'PsicoGesti√≥n',
                version: '1.0.0'
            });
            
            // 5. Comprimir backup
            const compressedPath = await this.comprimirBackup(backupDir);
            
            // 6. Limpiar backup sin comprimir
            await fs.rm(backupDir, { recursive: true, force: true });
            
            // 7. Registrar en base de datos
            await this.registrarBackupEnBD({
                tipo: 'completo',
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size,
                estado: 'completado'
            });
            
            console.log(`‚úÖ Backup completado: ${compressedPath}`);
            return {
                success: true,
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size
            };
            
        } catch (error) {
            console.error('‚ùå Error en backup completo:', error);
            throw error;
        }
    }
    
    static async realizarBackupBaseDatos(backupDir) {
        try {
            const dbConfig = {
                host: process.env.DB_HOST,
                user: process.env.DB_USER,
                password: process.env.DB_PASSWORD,
                database: process.env.DB_NAME
            };
            
            const dumpFile = path.join(backupDir, 'database.sql');
            
            // Comando mysqldump
            const command = `mysqldump --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} > "${dumpFile}"`;
            
            await execPromise(command);
            
            // Verificar que el archivo se cre√≥
            const stats = await fs.stat(dumpFile);
            
            console.log(`‚úÖ Backup de base de datos creado: ${dumpFile} (${stats.size} bytes)`);
            
            return {
                archivo: dumpFile,
                tamano: stats.size,
                tablas: await this.obtenerInfoTablas()
            };
            
        } catch (error) {
            console.error('‚ùå Error en backup de base de datos:', error);
            throw error;
        }
    }
    
    static async realizarBackupArchivos(backupDir) {
        try {
            const archivosDir = path.join(__dirname, '..', '..', 'uploads');
            const backupArchivosDir = path.join(backupDir, 'archivos');
            
            // Verificar si existe el directorio de archivos
            try {
                await fs.access(archivosDir);
            } catch {
                console.log('‚ö†Ô∏è  No hay archivos subidos para backup');
                return { archivos: 0, tamano: 0 };
            }
            
            // Copiar archivos recursivamente
            await this.copiarDirectorioRecursivo(archivosDir, backupArchivosDir);
            
            // Calcular estad√≠sticas
            const { totalArchivos, totalTamano } = await this.calcularEstadisticasArchivos(backupArchivosDir);
            
            console.log(`‚úÖ Backup de archivos creado: ${totalArchivos} archivos (${totalTamano} bytes)`);
            
            return {
                directorio: backupArchivosDir,
                archivos: totalArchivos,
                tamano: totalTamano
            };
            
        } catch (error) {
            console.error('‚ùå Error en backup de archivos:', error);
            throw error;
        }
    }
    
    static async realizarBackupConfiguracion(backupDir) {
        try {
            const configDir = path.join(backupDir, 'configuracion');
            await fs.mkdir(configDir, { recursive: true });
            
            // Archivos de configuraci√≥n importantes
            const archivosConfig = [
                '.env',
                'package.json',
                'package-lock.json',
                'server.js'
            ];
            
            let archivosCopiados = 0;
            
            for (const archivo of archivosConfig) {
                const sourcePath = path.join(__dirname, '..', '..', archivo);
                const destPath = path.join(configDir, archivo);
                
                try {
                    await fs.copyFile(sourcePath, destPath);
                    archivosCopiados++;
                } catch (error) {
                    console.warn(`‚ö†Ô∏è  No se pudo copiar ${archivo}: ${error.message}`);
                }
            }
            
            // Crear archivo con informaci√≥n del sistema
            const systemInfo = {
                node_version: process.version,
                platform: process.platform,
                arch: process.arch,
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                fecha: new Date().toISOString()
            };
            
            await fs.writeFile(
                path.join(configDir, 'system-info.json'),
                JSON.stringify(systemInfo, null, 2)
            );
            
            console.log(`‚úÖ Backup de configuraci√≥n creado: ${archivosCopiados} archivos`);
            
            return {
                directorio: configDir,
                archivos: archivosCopiados + 1, // +1 por system-info.json
                tamano: await this.calcularTamanoDirectorio(configDir)
            };
            
        } catch (error) {
            console.error('‚ùå Error en backup de configuraci√≥n:', error);
            throw error;
        }
    }
    
    static async realizarBackupIncremental() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupDir = path.join(__dirname, '..', '..', 'backups', `incremental-${timestamp}`);
            
            await fs.mkdir(backupDir, { recursive: true });
            
            console.log(`üîÑ Iniciando backup incremental: ${timestamp}`);
            
            // Obtener √∫ltimo backup completo
            const ultimoBackup = await this.obtenerUltimoBackup('completo');
            
            // Backup solo de cambios desde el √∫ltimo backup completo
            const cambios = await this.obtenerCambiosDesdeUltimoBackup(ultimoBackup?.fecha);
            
            // Guardar cambios
            const cambiosFile = path.join(backupDir, 'cambios.json');
            await fs.writeFile(cambiosFile, JSON.stringify(cambios, null, 2));
            
            // Backup de nuevos archivos
            const nuevosArchivos = await this.realizarBackupArchivosNuevos(backupDir, cambios.archivos_nuevos);
            
            // Comprimir backup incremental
            const compressedPath = await this.comprimirBackup(backupDir);
            
            // Limpiar
            await fs.rm(backupDir, { recursive: true, force: true });
            
            // Registrar en BD
            await this.registrarBackupEnBD({
                tipo: 'incremental',
                ruta: compressedPath,
                tamano: (await fs.stat(compressedPath)).size,
                base_backup_id: ultimoBackup?.id,
                cambios: cambios.cantidad_cambios,
                estado: 'completado'
            });
            
            console.log(`‚úÖ Backup incremental completado: ${compressedPath}`);
            return {
                success: true,
                ruta: compressedPath,
                cambios: cambios.cantidad_cambios
            };
            
        } catch (error) {
            console.error('‚ùå Error en backup incremental:', error);
            throw error;
        }
    }
    
    static async restaurarBackup(backupId) {
        try {
            // Obtener informaci√≥n del backup
            const [backupInfo] = await sequelize.query(
                'SELECT * FROM backups WHERE id = ? AND estado = "completado"',
                { replacements: [backupId], type: QueryTypes.SELECT }
            );
            
            if (!backupInfo) {
                throw new Error('Backup no encontrado o incompleto');
            }
            
            console.log(`üîÑ Iniciando restauraci√≥n del backup: ${backupInfo.ruta}`);
            
            // 1. Descomprimir backup
            const tempDir = await this.descomprimirBackup(backupInfo.ruta);
            
            // 2. Verificar integridad
            await this.verificarIntegridadBackup(tempDir);
            
            // 3. Restaurar base de datos
            if (backupInfo.tipo === 'completo') {
                await this.restaurarBaseDatosCompleta(tempDir);
                await this.restaurarArchivosCompletos(tempDir);
                await this.restaurarConfiguracion(tempDir);
            } else {
                // Restaurar incremental sobre √∫ltimo backup completo
                await this.restaurarBackupIncremental(tempDir, backupInfo.base_backup_id);
            }
            
            // 4. Limpiar directorio temporal
            await fs.rm(tempDir, { recursive: true, force: true });
            
            // 5. Actualizar estado del backup
            await sequelize.query(
                'UPDATE backups SET ultima_restauracion = NOW() WHERE id = ?',
                { replacements: [backupId] }
            );
            
            console.log('‚úÖ Restauraci√≥n completada exitosamente');
            return { success: true };
            
        } catch (error) {
            console.error('‚ùå Error en restauraci√≥n:', error);
            throw error;
        }
    }
    
    static async verificarBackups() {
        try {
            const backupsDir = path.join(__dirname, '..', '..', 'backups');
            
            // Verificar que exista el directorio
            await fs.access(backupsDir);
            
            // Obtener lista de backups
            const archivos = await fs.readdir(backupsDir);
            const backups = archivos.filter(archivo => archivo.endsWith('.zip'));
            
            // Verificar integridad de cada backup
            const resultados = [];
            
            for (const backup of backups) {
                const backupPath = path.join(backupsDir, backup);
                const stats = await fs.stat(backupPath);
                
                const resultado = {
                    archivo: backup,
                    tamano: stats.size,
                    modificado: stats.mtime,
                    valido: await this.verificarIntegridadArchivo(backupPath)
                };
                
                resultados.push(resultado);
            }
            
            // Verificar en base de datos
            const [backupsDB] = await sequelize.query(
                'SELECT COUNT(*) as total, SUM(tamano) as total_tamano FROM backups WHERE estado = "completado"',
                { type: QueryTypes.SELECT }
            );
            
            return {
                backups_fs: resultados,
                backups_db: backupsDB,
                espacio_total: await this.calcularEspacioDisco(backupsDir),
                recomendaciones: this.generarRecomendacionesBackup(resultados)
            };
            
        } catch (error) {
            console.error('‚ùå Error al verificar backups:', error);
            throw error;
        }
    }
    
    static async limpiarBackupsAntiguos(dias = 30) {
        try {
            const backupsDir = path.join(__dirname, '..', '..', 'backups');
            const fechaLimite = new Date(Date.now() - dias * 24 * 60 * 60 * 1000);
            
            const archivos = await fs.readdir(backupsDir);
            let eliminados = 0;
            let espacioLiberado = 0;
            
            for (const archivo of archivos) {
                if (archivo.endsWith('.zip')) {
                    const archivoPath = path.join(backupsDir, archivo);
                    const stats = await fs.stat(archivoPath);
                    
                    if (stats.mtime < fechaLimite) {
                        await fs.unlink(archivoPath);
                        eliminados++;
                        espacioLiberado += stats.size;
                        
                        // Actualizar estado en BD
                        await sequelize.query(
                            'UPDATE backups SET estado = "eliminado" WHERE ruta LIKE ?',
                            { replacements: [`%${archivo}%`] }
                        );
                    }
                }
            }
            
            console.log(`üßπ Limpieza de backups: ${eliminados} eliminados, ${this.formatearBytes(espacioLiberado)} liberados`);
            
            return {
                eliminados,
                espacio_liberado: espacioLiberado,
                espacio_formateado: this.formatearBytes(espacioLiberado)
            };
            
        } catch (error) {
            console.error('‚ùå Error al limpiar backups antiguos:', error);
            throw error;
        }
    }
    
    // M√©todos auxiliares
    static async obtenerInfoTablas() {
        const [tablas] = await sequelize.query(`
            SELECT 
                TABLE_NAME as tabla,
                TABLE_ROWS as filas,
                DATA_LENGTH as tamano_datos,
                INDEX_LENGTH as tamano_indices,
                CREATE_TIME as creada,
                UPDATE_TIME as actualizada
            FROM information_schema.TABLES
            WHERE TABLE_SCHEMA = ?
            ORDER BY TABLE_NAME
        `, {
            replacements: [process.env.DB_NAME],
            type: QueryTypes.SELECT
        });
        
        return tablas;
    }
    
    static async copiarDirectorioRecursivo(origen, destino) {
        await fs.mkdir(destino, { recursive: true });
        
        const elementos = await fs.readdir(origen, { withFileTypes: true });
        
        for (const elemento of elementos) {
            const sourcePath = path.join(origen, elemento.name);
            const destPath = path.join(destino, elemento.name);
            
            if (elemento.isDirectory()) {
                await this.copiarDirectorioRecursivo(sourcePath, destPath);
            } else {
                await fs.copyFile(sourcePath, destPath);
            }
        }
    }
    
    static async calcularEstadisticasArchivos(directorio) {
        let totalArchivos = 0;
        let totalTamano = 0;
        
        async function calcularRecursivo(dir) {
            const elementos = await fs.readdir(dir, { withFileTypes: true });
            
            for (const elemento of elementos) {
                const elementoPath = path.join(dir, elemento.name);
                
                if (elemento.isDirectory()) {
                    await calcularRecursivo(elementoPath);
                } else {
                    const stats = await fs.stat(elementoPath);
                    totalArchivos++;
                    totalTamano += stats.size;
                }
            }
        }
        
        await calcularRecursivo(directorio);
        return { totalArchivos, totalTamano };
    }
    
    static async calcularTamanoDirectorio(directorio) {
        const { totalTamano } = await this.calcularEstadisticasArchivos(directorio);
        return totalTamano;
    }
    
    static async generarMetadataBackup(backupDir, metadata) {
        const metadataFile = path.join(backupDir, 'metadata.json');
        await fs.writeFile(metadataFile, JSON.stringify(metadata, null, 2));
    }
    
    static async comprimirBackup(directorio) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const zipFile = path.join(path.dirname(directorio), `backup-${timestamp}.zip`);
        
        const command = `cd "${path.dirname(directorio)}" && zip -r "${zipFile}" "${path.basename(directorio)}"`;
        
        await execPromise(command);
        return zipFile;
    }
    
    static async registrarBackupEnBD(datos) {
        await sequelize.query(`
            INSERT INTO backups (tipo, ruta, tamano, base_backup_id, cambios, estado, created_at)
            VALUES (?, ?, ?, ?, ?, ?, NOW())
        `, {
            replacements: [
                datos.tipo,
                datos.ruta,
                datos.tamano,
                datos.base_backup_id || null,
                datos.cambios || 0,
                datos.estado
            ]
        });
    }
    
    static async obtenerUltimoBackup(tipo) {
        const [backup] = await sequelize.query(`
            SELECT * FROM backups 
            WHERE tipo = ? AND estado = 'completado'
            ORDER BY created_at DESC 
            LIMIT 1
        `, {
            replacements: [tipo],
            type: QueryTypes.SELECT
        });
        
        return backup;
    }
    
    static async obtenerCambiosDesdeUltimoBackup(fechaUltimoBackup) {
        if (!fechaUltimoBackup) {
            return { cantidad_cambios: 0, archivos_nuevos: [] };
        }
        
        // Obtener citas nuevas/modificadas
        const [citasCambiadas] = await sequelize.query(`
            SELECT COUNT(*) as cantidad FROM citas 
            WHERE created_at > ? OR updated_at > ?
        `, {
            replacements: [fechaUltimoBackup, fechaUltimoBackup],
            type: QueryTypes.SELECT
        });
        
        // Obtener pacientes nuevos/modificados
        const [pacientesCambiados] = await sequelize.query(`
            SELECT COUNT(*) as cantidad FROM pacientes 
            WHERE created_at > ? OR updated_at > ?
        `, {
            replacements: [fechaUltimoBackup, fechaUltimoBackup],
            type: QueryTypes.SELECT
        });
        
        // Obtener archivos nuevos (simplificado)
        const archivosNuevos = await this.obtenerArchivosNuevosDesde(fechaUltimoBackup);
        
        return {
            cantidad_cambios: (citasCambiadas?.cantidad || 0) + (pacientesCambiados?.cantidad || 0),
            citas_nuevas: citasCambiadas?.cantidad || 0,
            pacientes_nuevos: pacientesCambiados?.cantidad || 0,
            archivos_nuevos: archivosNuevos
        };
    }
    
    static async obtenerArchivosNuevosDesde(fecha) {
        // Esta funci√≥n necesitar√≠a un sistema de tracking de archivos
        // Por ahora retorna array vac√≠o
        return [];
    }
    
    static async realizarBackupArchivosNuevos(backupDir, archivosNuevos) {
        if (!archivosNuevos || archivosNuevos.length === 0) {
            return { archivos: 0, tamano: 0 };
        }
        
        const archivosDir = path.join(backupDir, 'archivos_nuevos');
        await fs.mkdir(archivosDir, { recursive: true });
        
        let totalCopiados = 0;
        
        for (const archivo of archivosNuevos) {
            try {
                const sourcePath = path.join(__dirname, '..', '..', 'uploads', archivo);
                const destPath = path.join(archivosDir, archivo);
                
                await fs.copyFile(sourcePath, destPath);
                totalCopiados++;
            } catch (error) {
                console.warn(`‚ö†Ô∏è  No se pudo copiar archivo ${archivo}: ${error.message}`);
            }
        }
        
        return {
            directorio: archivosDir,
            archivos: totalCopiados,
            tamano: await this.calcularTamanoDirectorio(archivosDir)
        };
    }
    
    static async descomprimirBackup(backupPath) {
        const tempDir = path.join(__dirname, '..', '..', 'temp-restore', Date.now().toString());
        await fs.mkdir(tempDir, { recursive: true });
        
        const command = `unzip "${backupPath}" -d "${tempDir}"`;
        await execPromise(command);
        
        // Buscar el directorio descomprimido
        const elementos = await fs.readdir(tempDir, { withFileTypes: true });
        const directorioDescomprimido = elementos.find(e => e.isDirectory())?.name;
        
        if (!directorioDescomprimido) {
            throw new Error('No se encontr√≥ directorio descomprimido');
        }
        
        return path.join(tempDir, directorioDescomprimido);
    }
    
    static async verificarIntegridadBackup(directorio) {
        // Verificar archivos esenciales
        const archivosEsenciales = ['database.sql', 'metadata.json'];
        
        for (const archivo of archivosEsenciales) {
            const archivoPath = path.join(directorio, archivo);
            try {
                await fs.access(archivoPath);
            } catch {
                throw new Error(`Archivo esencial faltante: ${archivo}`);
            }
        }
        
        // Verificar metadata
        const metadataPath = path.join(directorio, 'metadata.json');
        const metadataContent = await fs.readFile(metadataPath, 'utf8');
        const metadata = JSON.parse(metadataContent);
        
        if (!metadata.sistema || !metadata.version) {
            throw new Error('Metadata inv√°lida');
        }
        
        console.log('‚úÖ Integridad del backup verificada');
        return true;
    }
    
    static async verificarIntegridadArchivo(backupPath) {
        try {
            // Verificar que el archivo existe y es legible
            await fs.access(backupPath);
            
            // Verificar estructura ZIP b√°sica
            const command = `unzip -t "${backupPath}"`;
            await execPromise(command);
            
            return true;
        } catch (error) {
            return false;
        }
    }
    
    static async restaurarBaseDatosCompleta(directorioBackup) {
        const dbFile = path.join(directorioBackup, 'database.sql');
        
        if (!await fs.access(dbFile).then(() => true).catch(() => false)) {
            throw new Error('Archivo de base de datos no encontrado en backup');
        }
        
        const dbConfig = {
            host: process.env.DB_HOST,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME
        };
        
        // Primero crear una copia de seguridad actual (por si acaso)
        const backupActual = await this.realizarBackupBaseDatos(path.join(__dirname, '..', '..', 'temp'));
        
        try {
            // Restaurar base de datos
            const command = `mysql --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} < "${dbFile}"`;
            await execPromise(command);
            
            console.log('‚úÖ Base de datos restaurada');
        } catch (error) {
            // Restaurar backup actual en caso de error
            console.error('‚ùå Error al restaurar base de datos, restaurando backup anterior...');
            const restoreCommand = `mysql --host=${dbConfig.host} --user=${dbConfig.user} --password=${dbConfig.password} ${dbConfig.database} < "${backupActual.archivo}"`;
            await execPromise(restoreCommand);
            throw error;
        }
    }
    
    static async restaurarArchivosCompletos(directorioBackup) {
        const archivosDir = path.join(directorioBackup, 'archivos');
        
        if (await fs.access(archivosDir).then(() => true).catch(() => false)) {
            const uploadsDir = path.join(__dirname, '..', '..', 'uploads');
            
            // Crear backup de archivos actuales
            await fs.rename(uploadsDir, `${uploadsDir}.backup.${Date.now()}`);
            
            // Restaurar archivos del backup
            await this.copiarDirectorioRecursivo(archivosDir, uploadsDir);
            
            console.log('‚úÖ Archivos restaurados');
        }
    }
    
    static async restaurarConfiguracion(directorioBackup) {
        const configDir = path.join(directorioBackup, 'configuracion');
        
        if (await fs.access(configDir).then(() => true).catch(() => false)) {
            // Solo restaurar archivos espec√≠ficos si es necesario
            console.log('‚ö†Ô∏è  Configuraci√≥n disponible para restauraci√≥n manual');
        }
    }
    
    static async restaurarBackupIncremental(directorioBackup, baseBackupId) {
        // Implementaci√≥n de restauraci√≥n incremental
        // Requiere l√≥gica m√°s compleja de aplicaci√≥n de cambios
        console.log('üîÑ Restaurando backup incremental...');
        // Por ahora, solo log
    }
    
    static async calcularEspacioDisco(directorio) {
        const command = `df -h "${directorio}" | tail -1 | awk '{print $4}'`;
        try {
            const { stdout } = await execPromise(command);
            return stdout.trim();
        } catch {
            return 'Desconocido';
        }
    }
    
    static generarRecomendacionesBackup(backups) {
        const recomendaciones = [];
        
        if (backups.length === 0) {
            recomendaciones.push('No hay backups existentes. Se recomienda crear un backup completo inmediatamente.');
        }
        
        if (backups.length > 10) {
            recomendaciones.push('Muchos backups almacenados. Considere eliminar los m√°s antiguos.');
        }
        
        const backupsInvalidos = backups.filter(b => !b.valido);
        if (backupsInvalidos.length > 0) {
            recomendaciones.push(`Hay ${backupsInvalidos.length} backups inv√°lidos. Considere eliminarlos.`);
        }
        
        return recomendaciones;
    }
    
    static formatearBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

module.exports = BackupService;

/backend\src\services\calendarioService.js:
--------------------------------------------------------------------------------
const { google } = require('googleapis');
const { OAuth2 } = google.auth;
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class CalendarioService {
    
    static oAuth2Client = null;
    static calendar = null;
    
    static async inicializar() {
        try {
            if (!process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET || !process.env.GOOGLE_REDIRECT_URI) {
                console.warn('Credenciales de Google Calendar no configuradas');
                return false;
            }
            
            this.oAuth2Client = new OAuth2(
                process.env.GOOGLE_CLIENT_ID,
                process.env.GOOGLE_CLIENT_SECRET,
                process.env.GOOGLE_REDIRECT_URI
            );
            
            // Configurar tokens si existen
            if (process.env.GOOGLE_ACCESS_TOKEN && process.env.GOOGLE_REFRESH_TOKEN) {
                this.oAuth2Client.setCredentials({
                    access_token: process.env.GOOGLE_ACCESS_TOKEN,
                    refresh_token: process.env.GOOGLE_REFRESH_TOKEN
                });
            }
            
            this.calendar = google.calendar({ version: 'v3', auth: this.oAuth2Client });
            
            console.log('‚úÖ Servicio de Google Calendar inicializado');
            return true;
            
        } catch (error) {
            console.error('‚ùå Error al inicializar Google Calendar:', error);
            return false;
        }
    }
    
    static async sincronizarCitaConGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no est√° inicializado');
                return false;
            }
            
            // Obtener datos de la cita
            const [cita] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                    u_psi.email as psicologo_email,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                    u_bec.email as becario_email
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = ?
            `, {
                replacements: [citaId],
                type: QueryTypes.SELECT
            });
            
            if (!cita) {
                throw new Error('Cita no encontrada');
            }
            
            // Crear evento en Google Calendar
            const evento = {
                summary: `Sesi√≥n psicol√≥gica - ${cita.paciente_nombre}`,
                description: this.generarDescripcionEvento(cita),
                start: {
                    dateTime: `${cita.fecha}T${cita.hora}:00`,
                    timeZone: 'America/Mexico_City'
                },
                end: {
                    dateTime: this.calcularHoraFin(cita.fecha, cita.hora, cita.duracion_minutos || 50),
                    timeZone: 'America/Mexico_City'
                },
                attendees: this.obtenerAsistentes(cita),
                reminders: {
                    useDefault: false,
                    overrides: [
                        { method: 'email', minutes: 24 * 60 }, // 1 d√≠a antes
                        { method: 'popup', minutes: 30 } // 30 minutos antes
                    ]
                },
                colorId: cita.tipo_consulta === 'virtual' ? '5' : '2' // Color diferente para virtual
            };
            
            const response = await this.calendar.events.insert({
                calendarId: 'primary',
                resource: evento,
                sendUpdates: 'all'
            });
            
            // Guardar ID del evento en la cita
            await sequelize.query(
                'UPDATE citas SET google_calendar_event_id = ? WHERE id = ?',
                { replacements: [response.data.id, citaId] }
            );
            
            console.log(`‚úÖ Cita ${citaId} sincronizada con Google Calendar: ${response.data.htmlLink}`);
            return response.data;
            
        } catch (error) {
            console.error('‚ùå Error al sincronizar cita con Google Calendar:', error);
            throw error;
        }
    }
    
    static async actualizarEventoGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no est√° inicializado');
                return false;
            }
            
            // Obtener cita con ID del evento
            const [cita] = await sequelize.query(
                'SELECT google_calendar_event_id FROM citas WHERE id = ?',
                { replacements: [citaId], type: QueryTypes.SELECT }
            );
            
            if (!cita || !cita.google_calendar_event_id) {
                // Si no tiene evento, crear uno nuevo
                return await this.sincronizarCitaConGoogleCalendar(citaId);
            }
            
            // Obtener datos actualizados de la cita
            const [citaActualizada] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    p.email as paciente_email,
                    CONCAT(u_psi.nombre, ' ', u_psi.apellido) as psicologo_nombre,
                    u_psi.email as psicologo_email,
                    CONCAT(u_bec.nombre, ' ', u_bec.apellido) as becario_nombre,
                    u_bec.email as becario_email
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = ?
            `, {
                replacements: [citaId],
                type: QueryTypes.SELECT
            });
            
            // Actualizar evento
            const evento = {
                summary: `Sesi√≥n psicol√≥gica - ${citaActualizada.paciente_nombre}`,
                description: this.generarDescripcionEvento(citaActualizada),
                start: {
                    dateTime: `${citaActualizada.fecha}T${citaActualizada.hora}:00`,
                    timeZone: 'America/Mexico_City'
                },
                end: {
                    dateTime: this.calcularHoraFin(citaActualizada.fecha, citaActualizada.hora, citaActualizada.duracion_minutos || 50),
                    timeZone: 'America/Mexico_City'
                },
                attendees: this.obtenerAsistentes(citaActualizada),
                colorId: citaActualizada.tipo_consulta === 'virtual' ? '5' : '2'
            };
            
            const response = await this.calendar.events.update({
                calendarId: 'primary',
                eventId: cita.google_calendar_event_id,
                resource: evento,
                sendUpdates: 'all'
            });
            
            console.log(`‚úÖ Evento de cita ${citaId} actualizado en Google Calendar`);
            return response.data;
            
        } catch (error) {
            console.error('‚ùå Error al actualizar evento en Google Calendar:', error);
            throw error;
        }
    }
    
    static async eliminarEventoGoogleCalendar(citaId) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no est√° inicializado');
                return false;
            }
            
            // Obtener ID del evento
            const [cita] = await sequelize.query(
                'SELECT google_calendar_event_id FROM citas WHERE id = ?',
                { replacements: [citaId], type: QueryTypes.SELECT }
            );
            
            if (!cita || !cita.google_calendar_event_id) {
                return true; // No hay evento que eliminar
            }
            
            // Eliminar evento
            await this.calendar.events.delete({
                calendarId: 'primary',
                eventId: cita.google_calendar_event_id,
                sendUpdates: 'all'
            });
            
            // Limpiar ID del evento en la cita
            await sequelize.query(
                'UPDATE citas SET google_calendar_event_id = NULL WHERE id = ?',
                { replacements: [citaId] }
            );
            
            console.log(`‚úÖ Evento de cita ${citaId} eliminado de Google Calendar`);
            return true;
            
        } catch (error) {
            console.error('‚ùå Error al eliminar evento de Google Calendar:', error);
            throw error;
        }
    }
    
    static async obtenerDisponibilidadProfesional(usuarioId, fecha) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no est√° inicializado');
                return null;
            }
            
            // Obtener email del profesional
            const [profesional] = await sequelize.query(
                'SELECT email FROM users WHERE id = ?',
                { replacements: [usuarioId], type: QueryTypes.SELECT }
            );
            
            if (!profesional || !profesional.email) {
                throw new Error('Profesional no encontrado o sin email');
            }
            
            // Obtener eventos del profesional para la fecha
            const inicio = new Date(`${fecha}T00:00:00`);
            const fin = new Date(`${fecha}T23:59:59`);
            
            const response = await this.calendar.events.list({
                calendarId: profesional.email,
                timeMin: inicio.toISOString(),
                timeMax: fin.toISOString(),
                singleEvents: true,
                orderBy: 'startTime'
            });
            
            return response.data.items.map(evento => ({
                inicio: evento.start.dateTime || evento.start.date,
                fin: evento.end.dateTime || evento.end.date,
                titulo: evento.summary,
                descripcion: evento.description
            }));
            
        } catch (error) {
            console.error('‚ùå Error al obtener disponibilidad de Google Calendar:', error);
            throw error;
        }
    }
    
    static async sincronizarAgendaCompleta(psicologoId, fechaInicio, fechaFin) {
        try {
            if (!this.calendar) {
                console.warn('Google Calendar no est√° inicializado');
                return false;
            }
            
            // Obtener citas del psic√≥logo en el rango de fechas
            const citas = await sequelize.query(`
                SELECT 
                    c.id,
                    c.fecha,
                    c.hora,
                    c.duracion_minutos,
                    c.tipo_consulta,
                    c.estado,
                    CONCAT(p.nombre, ' ', p.apellido) as paciente_nombre,
                    c.google_calendar_event_id
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                WHERE c.psicologo_id = ?
                AND c.fecha BETWEEN ? AND ?
                AND c.estado IN ('programada', 'confirmada')
                ORDER BY c.fecha, c.hora
            `, {
                replacements: [psicologoId, fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            const resultados = {
                creados: 0,
                actualizados: 0,
                errores: 0
            };
            
            // Sincronizar cada cita
            for (const cita of citas) {
                try {
                    if (cita.google_calendar_event_id) {
                        await this.actualizarEventoGoogleCalendar(cita.id);
                        resultados.actualizados++;
                    } else {
                        await this.sincronizarCitaConGoogleCalendar(cita.id);
                        resultados.creados++;
                    }
                } catch (error) {
                    console.error(`‚ùå Error al sincronizar cita ${cita.id}:`, error.message);
                    resultados.errores++;
                }
            }
            
            console.log(`‚úÖ Agenda sincronizada: ${resultados.creados} creados, ${resultados.actualizados} actualizados, ${resultados.errores} errores`);
            return resultados;
            
        } catch (error) {
            console.error('‚ùå Error al sincronizar agenda completa:', error);
            throw error;
        }
    }
    
    // M√©todos auxiliares
    static generarDescripcionEvento(cita) {
        let descripcion = `Sesi√≥n psicol√≥gica con ${cita.paciente_nombre}\n`;
        descripcion += `Tipo: ${cita.tipo_consulta === 'virtual' ? 'Virtual' : 'Presencial'}\n`;
        descripcion += `Estado: ${cita.estado}\n`;
        descripcion += `Psic√≥logo: ${cita.psicologo_nombre}\n`;
        
        if (cita.becario_nombre) {
            descripcion += `Becario: ${cita.becario_nombre}\n`;
        }
        
        if (cita.notas) {
            descripcion += `\nNotas: ${cita.notas}\n`;
        }
        
        descripcion += `\nID de cita: ${cita.id}`;
        return descripcion;
    }
    
    static calcularHoraFin(fecha, hora, duracionMinutos) {
        const [horas, minutos] = hora.split(':').map(Number);
        const fechaHora = new Date(`${fecha}T${hora.padStart(5, '0')}:00`);
        fechaHora.setMinutes(fechaHora.getMinutes() + duracionMinutos);
        
        return fechaHora.toISOString();
    }
    
    static obtenerAsistentes(cita) {
        const asistentes = [];
        
        // Paciente
        if (cita.paciente_email) {
            asistentes.push({ email: cita.paciente_email, displayName: cita.paciente_nombre });
        }
        
        // Psic√≥logo
        if (cita.psicologo_email) {
            asistentes.push({ email: cita.psicologo_email, displayName: cita.psicologo_nombre });
        }
        
        // Becario
        if (cita.becario_email) {
            asistentes.push({ email: cita.becario_email, displayName: cita.becario_nombre });
        }
        
        return asistentes;
    }
    
    static async obtenerUrlAutorizacion() {
        if (!this.oAuth2Client) {
            throw new Error('OAuth2 no inicializado');
        }
        
        const url = this.oAuth2Client.generateAuthUrl({
            access_type: 'offline',
            scope: [
                'https://www.googleapis.com/auth/calendar',
                'https://www.googleapis.com/auth/calendar.events'
            ]
        });
        
        return url;
    }
    
    static async intercambiarCodigoPorToken(codigo) {
        if (!this.oAuth2Client) {
            throw new Error('OAuth2 no inicializado');
        }
        
        const { tokens } = await this.oAuth2Client.getToken(codigo);
        this.oAuth2Client.setCredentials(tokens);
        
        return tokens;
    }
}

// Inicializar al cargar el m√≥dulo
CalendarioService.inicializar().catch(console.error);

module.exports = CalendarioService;

/backend\src\services\dashboardService.js:
--------------------------------------------------------------------------------
// frontend/src/services/dashboardService.js
import ApiService from './api';

class DashboardService {
  static async obtenerDashboardCoordinador() {
    try {
      const response = await ApiService.getDashboardCoordinador();
      return response.data;
    } catch (error) {
      console.error('Error obteniendo dashboard coordinador:', error);
      throw error;
    }
  }

  static async obtenerMetricasGlobales(periodo = 'mes') {
    try {
      const response = await ApiService.getMetricasGlobales(periodo);
      return response.data;
    } catch (error) {
      console.error('Error obteniendo m√©tricas globales:', error);
      throw error;
    }
  }

  static async obtenerEstadisticas() {
    try {
      const response = await ApiService.getEstadisticas();
      return response.data;
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas:', error);
      throw error;
    }
  }

  // M√©todo para transformar los datos del backend al formato que usa el frontend
  static transformarDatosCoordinador(datosBackend) {
    const { estadisticas, top_psicologos, alertas, evolucion_mensual, citas_por_dia } = datosBackend;
    
    // Transformar estad√≠sticas principales
    const estadisticasTransformadas = {
      becariosActivos: estadisticas.becarios_activos || 0,
      psicologosActivos: estadisticas.psicologos_activos || 0,
      pacientesActivos: estadisticas.pacientes_activos || 0,
      citasHoy: estadisticas.citas_hoy || 0,
      citasCompletadasHoy: estadisticas.citas_completadas_hoy || 0,
      altasMesActual: estadisticas.altas_mes || 0
    };

    // Transformar actividad reciente (puedes obtener esto de otra fuente o simularlo)
    const actividadReciente = this.generarActividadReciente(datosBackend);

    // Transformar distribuci√≥n de citas por psic√≥logo
    const distribucionPsicologos = top_psicologos.map(psicologo => ({
      nombre: psicologo.nombre_completo,
      citas: psicologo.total_citas || 0,
      color: this.asignarColor(psicologo.id)
    }));

    // Transformar alertas
    const alertasTransformadas = alertas.map(alerta => ({
      tipo: alerta.tipo,
      descripcion: alerta.descripcion,
      cantidad: alerta.cantidad
    }));

    return {
      estadisticas: estadisticasTransformadas,
      actividadReciente,
      distribucionPsicologos,
      alertas: alertasTransformadas,
      evolucionMensual: evolucion_mensual,
      citasPorDia: citas_por_dia
    };
  }

  static asignarColor(id) {
    const colores = ['var(--grnb)', 'var(--blu)', 'var(--yy)', 'var(--grnd)', 'var(--grnl)', 'var(--rr)'];
    return colores[id % colores.length];
  }

  static generarActividadReciente(datosBackend) {
    // Aqu√≠ puedes implementar l√≥gica para generar actividad reciente
    // basada en los datos del backend, logs, o mantenerlo simulado
    // por ahora devolver√© datos de ejemplo transformados
    const actividades = [];
    
    // Ejemplo: si hay nuevas altas hoy
    if (datosBackend.estadisticas.altas_hoy > 0) {
      actividades.push({
        id: 1,
        tipo: 'alta_paciente',
        descripcion: `${datosBackend.estadisticas.altas_hoy} paciente(s) dado(s) de alta hoy`,
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      });
    }

    // Ejemplo: si hay pacientes nuevos hoy
    if (datosBackend.estadisticas.pacientes_nuevos_hoy > 0) {
      actividades.push({
        id: 2,
        tipo: 'nuevo_paciente',
        descripcion: `${datosBackend.estadisticas.pacientes_nuevos_hoy} nuevo(s) paciente(s) registrado(s) hoy`,
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      });
    }

    return actividades.length > 0 ? actividades : [
      {
        id: 1,
        tipo: 'sistema',
        descripcion: 'Dashboard sincronizado con datos reales',
        fecha: new Date().toISOString(),
        usuario: 'Sistema'
      }
    ];
  }
}

export default DashboardService;

/backend\src\services\databaseService.js:
--------------------------------------------------------------------------------
const sequelize = require('../config/db');
const { QueryTypes } = require('sequelize');

class DatabaseService {
    
    static async obtenerCitasPorFechaBecario(fecha, becarioId = null) {
        try {
            let query = `
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    p.email AS paciente_email,
                    u_psi.nombre AS psicologo_nombre,
                    u_bec.nombre AS becario_nombre,
                    c.duracion_minutos AS duracion,  -- Cambia duracion_minutos a duracion
                    c.motivo AS notas,               -- Cambia motivo a notas
                    TIME_FORMAT(c.hora, '%H:%i') AS hora_formatted  -- Formatea la hora
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_psi ON c.psicologo_id = u_psi.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE DATE(c.fecha) = :fecha
            `;
            
            const params = { fecha };
            
            if (becarioId !== null && becarioId !== undefined) {
                query += ` AND c.becario_id = :becarioId`;
                params.becarioId = becarioId;
            }
            
            query += ` ORDER BY c.hora`;
            
            const results = await sequelize.query(query, {
                replacements: params,
                type: QueryTypes.SELECT
            });
            
            // Mapea los resultados para usar los nombres correctos
            return results.map(row => {
                return {
                    ...row,
                    hora: row.hora_formatted,  // Usa la hora formateada
                    duracion: row.duracion || 50,
                    notas: row.notas || ''
                };
            });
            
        } catch (error) {
            console.error('Error en obtenerCitasPorFechaBecario:', error);
            throw error;
        }
    }
    // En /src/services/databaseService.js
    static async crearNuevaCita(datosCita) {
        const transaction = await sequelize.transaction();
        
        try {
            console.log('üîß Creando nueva cita con datos:', datosCita);
            
            // 1. Buscar o crear el paciente
            let paciente;
            
            // Primero intentar buscar por nombre y apellido
            const [pacienteExistente] = await sequelize.query(`
                SELECT id FROM pacientes 
                WHERE LOWER(nombre) = LOWER(:nombre) 
                AND LOWER(apellido) = LOWER(:apellido)
                LIMIT 1
            `, {
                replacements: {
                    nombre: datosCita.paciente.nombre.trim(),
                    apellido: datosCita.paciente.apellido.trim()
                },
                transaction
            });
            
            if (pacienteExistente && pacienteExistente.length > 0) {
                // Usar paciente existente
                paciente = pacienteExistente[0];
                console.log('‚úÖ Usando paciente existente:', paciente);
            } else {
                // Crear nuevo paciente
                console.log('üìã Creando nuevo paciente');
                const [resultadoPaciente] = await sequelize.query(`
                    INSERT INTO pacientes (
                        nombre, apellido, email, telefono, estado, activo, created_at
                    ) VALUES (
                        :nombre, :apellido, :email, :telefono, 'activo', TRUE, NOW()
                    )
                    `, {
                    replacements: {
                        nombre: datosCita.paciente.nombre.trim(),
                        apellido: datosCita.paciente.apellido.trim(),
                        email: datosCita.paciente.email || null,
                        telefono: datosCita.paciente.telefono || null
                    },
                    transaction
                    });

                    const [[pacienteInsertado]] = await sequelize.query(
                    'SELECT LAST_INSERT_ID() AS id',
                    { transaction }
                    );

                    paciente = { id: pacienteInsertado.id };

                console.log('‚úÖ Nuevo paciente creado con ID:', paciente.id);
            }
            
            // 2. Verificar que el becario existe si se especific√≥
            if (datosCita.becario_id) {
                const [becario] = await sequelize.query(`
                    SELECT id FROM users WHERE id = :becario_id AND rol = 'becario'
                `, {
                    replacements: { becario_id: datosCita.becario_id },
                    transaction
                });
                
                if (!becario || becario.length === 0) {
                    throw new Error('El becario especificado no existe');
                }
            }
            
            // 3. Verificar que no haya conflicto de horario
            const [citasConflicto] = await sequelize.query(`
                SELECT id FROM citas 
                WHERE fecha = :fecha 
                AND hora = :hora 
                AND estado IN ('programada', 'confirmada')
                AND becario_id = :becario_id
            `, {
                replacements: {
                    fecha: datosCita.fecha,
                    hora: datosCita.hora + ':00', // Asegurar formato HH:MM:SS
                    becario_id: datosCita.becario_id || null
                },
                transaction
            });
            
            if (citasConflicto && citasConflicto.length > 0) {
                throw new Error('Ya existe una cita programada para este horario con este becario');
            }
            
            // 4. Crear la cita
            await sequelize.query(`
                INSERT INTO citas (
                    paciente_id,
                    psicologo_id,
                    becario_id,
                    fecha,
                    hora,
                    duracion_minutos,
                    tipo_consulta,
                    estado,
                    motivo,
                    created_at
                ) VALUES (
                    :paciente_id,
                    :psicologo_id,
                    :becario_id,
                    :fecha,
                    :hora,
                    :duracion_minutos,
                    :tipo_consulta,
                    :estado,
                    :motivo,
                    NOW()
                )
            `, {
                replacements: {
                    paciente_id: paciente.id,
                    psicologo_id: datosCita.usuarioId,
                    becario_id: datosCita.becario_id || null,
                    fecha: datosCita.fecha,
                    hora: datosCita.hora,
                    duracion_minutos: datosCita.duracion || 50,
                    tipo_consulta: datosCita.tipo_consulta,
                    estado: 'programada',
                    motivo: datosCita.notas || null
                },
                transaction
            });

            const [[citaInsertada]] = await sequelize.query(
                'SELECT LAST_INSERT_ID() AS id',
                { transaction }
            );

            
            // 5. Obtener la cita creada con informaci√≥n del paciente
            const [citaCreada] = await sequelize.query(`
                SELECT 
                    c.*,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente_nombre,
                    p.telefono AS paciente_telefono,
                    u_bec.nombre AS becario_nombre
                FROM citas c
                JOIN pacientes p ON c.paciente_id = p.id
                LEFT JOIN users u_bec ON c.becario_id = u_bec.id
                WHERE c.id = :cita_id
            `, {
                replacements: { cita_id: citaInsertada.id },
                transaction
            });
            
            // 6. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'nueva_cita', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId: datosCita.usuarioId,
                    pacienteId: paciente.id,
                    descripcion: `Nueva cita creada para ${datosCita.fecha} ${datosCita.hora}` 
                },
                transaction
            });
            
            await transaction.commit();
            console.log('‚úÖ Cita creada exitosamente');
            
            return citaCreada[0];
            
        } catch (error) {
            await transaction.rollback();
            console.error('‚ùå Error en crearNuevaCita:', error);
            throw error;
        }
    }
    

    /**
     * Reemplaza: sp_generar_reporte_mensual
     */
    static async generarReporteMensual(mes, anio, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    p.id,
                    CONCAT(p.nombre, ' ', p.apellido) AS paciente,
                    COUNT(c.id) AS total_sesiones,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) AS sesiones_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) AS sesiones_canceladas,
                    SUM(CASE WHEN c.estado = 'programada' THEN 1 ELSE 0 END) AS sesiones_programadas,
                    MIN(c.fecha) AS primera_sesion_mes,
                    MAX(c.fecha) AS ultima_sesion_mes
                FROM pacientes p
                LEFT JOIN citas c ON p.id = c.paciente_id 
                    AND MONTH(c.fecha) = :mes 
                    AND YEAR(c.fecha) = :anio
            `;
            
            const params = { mes, anio };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND c.psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            query += `
                WHERE p.activo = TRUE
                GROUP BY p.id, p.nombre, p.apellido
                ORDER BY p.apellido, p.nombre
            `;
            
            const [results] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return results;
            
        } catch (error) {
            console.error('Error en generarReporteMensual:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_insert_alta
     * Realiza transacci√≥n at√≥mica para dar de alta paciente
     */
    static async darAltaPaciente(pacienteId, tipoAlta, usuarioId, notas = null) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Insertar en altas
            await sequelize.query(`
                INSERT INTO altas (paciente_id, tipo_alta, usuario_id, notas, created_at)
                VALUES (:pacienteId, :tipoAlta, :usuarioId, :notas, NOW())
            `, {
                replacements: { pacienteId, tipoAlta, usuarioId, notas },
                transaction
            });
            
            // 2. Actualizar paciente
            await sequelize.query(`
                UPDATE pacientes 
                SET estado = :tipoAlta,
                    activo = FALSE,
                    updated_at = NOW()
                WHERE id = :pacienteId
            `, {
                replacements: { tipoAlta, pacienteId },
                transaction
            });
            
            // 3. Cancelar citas futuras
            await sequelize.query(`
                UPDATE citas 
                SET estado = 'cancelada',
                    motivo_cancelacion = 'Paciente dado de alta',
                    updated_at = NOW()
                WHERE paciente_id = :pacienteId 
                AND fecha >= CURDATE()
                AND estado IN ('programada', 'confirmada')
            `, {
                replacements: { pacienteId },
                transaction
            });
            
            // 4. Registrar en logs
            await sequelize.query(`
                INSERT INTO logs_sistema (
                    tipo, usuario_id, descripcion, paciente_id, created_at
                ) VALUES (
                    'alta_paciente', :usuarioId, :descripcion, :pacienteId, NOW()
                )
            `, {
                replacements: { 
                    usuarioId, 
                    pacienteId,
                    descripcion: `Alta tipo: ${tipoAlta}` 
                },
                transaction
            });
            
            // Commit de la transacci√≥n
            await transaction.commit();
            
            return true;
            
        } catch (error) {
            // Rollback en caso de error
            await transaction.rollback();
            console.error('Error en darAltaPaciente:', error);
            throw error;
        }
    }
    
    /**
     * Reemplaza: tr_after_update_cita
     * Actualiza cita y maneja notificaciones
     */
    static async actualizarCita(citaId, updates, usuarioId) {
        const transaction = await sequelize.transaction();
        
        try {
            // 1. Obtener datos actuales
            const [citaActual] = await sequelize.query(`
                SELECT * FROM citas WHERE id = :citaId
            `, {
                replacements: { citaId },
                type: sequelize.QueryTypes.SELECT,
                transaction
            });
            
            if (!citaActual) {
                throw new Error('Cita no encontrada');
            }
            
            // 2. Construir query de actualizaci√≥n
            const setClauses = [];
            const params = { citaId };
            
            for (const [key, value] of Object.entries(updates)) {
                setClauses.push(`${key} = :${key}`);
                params[key] = value;
            }
            
            const updateQuery = `
                UPDATE citas 
                SET ${setClauses.join(', ')}, updated_at = NOW()
                WHERE id = :citaId
            `;
            
            // 3. Actualizar cita
            await sequelize.query(updateQuery, {
                replacements: params,
                transaction
            });
            
            // 4. Verificar cambios importantes para notificaciones
            const cambiosImportantes = 
                (updates.fecha && updates.fecha !== citaActual.fecha) ||
                (updates.hora && updates.hora !== citaActual.hora) ||
                (updates.tipo_consulta && updates.tipo_consulta !== citaActual.tipo_consulta);
            
            // 5. Crear notificaciones si hay cambios importantes
            if (cambiosImportantes) {
                // Obtener paciente email si existe
                const [paciente] = await sequelize.query(`
                    SELECT email FROM pacientes WHERE id = :pacienteId
                `, {
                    replacements: { pacienteId: citaActual.paciente_id },
                    type: sequelize.QueryTypes.SELECT,
                    transaction
                });
                
                if (paciente && paciente.email) {
                    // Crear notificaci√≥n para el paciente (si tuvieras tabla notificaciones)
                    // await sequelize.query(...)
                }
                
                // Notificar al psic√≥logo y becario si est√°n asignados
                const usuariosNotificar = [];
                if (citaActual.psicologo_id) usuariosNotificar.push(citaActual.psicologo_id);
                if (citaActual.becario_id) usuariosNotificar.push(citaActual.becario_id);
                
                for (const userId of usuariosNotificar) {
                    await sequelize.query(`
                        INSERT INTO notificaciones (
                            usuario_id, tipo, titulo, mensaje, leido, created_at
                        ) VALUES (
                            :userId, 'cita_modificada', 'Cita modificada',
                            CONCAT('La cita del paciente ha sido modificada. Nueva fecha: ', 
                                   :nuevaFecha, ' ', :nuevaHora),
                            FALSE, NOW()
                        )
                    `, {
                        replacements: {
                            userId,
                            nuevaFecha: updates.fecha || citaActual.fecha,
                            nuevaHora: updates.hora || citaActual.hora
                        },
                        transaction
                    });
                }
            }
            
            await transaction.commit();
            return true;
            
        } catch (error) {
            await transaction.rollback();
            console.error('Error en actualizarCita:', error);
            throw error;
        }
    }
    
    /**
     * Obtener estad√≠sticas generales
     */
    static async obtenerEstadisticas(fechaInicio, fechaFin, psicologoId = null) {
        try {
            let query = `
                SELECT 
                    COUNT(*) AS total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) AS completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) AS canceladas,
                    SUM(CASE WHEN estado = 'programada' THEN 1 ELSE 0 END) AS programadas,
                    COUNT(DISTINCT paciente_id) AS pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) AS psicologos_activos
                FROM citas
                WHERE fecha BETWEEN :fechaInicio AND :fechaFin
            `;
            
            const params = { fechaInicio, fechaFin };
            
            if (psicologoId !== null && psicologoId !== undefined) {
                query += ` AND psicologo_id = :psicologoId`;
                params.psicologoId = psicologoId;
            }
            
            const [result] = await sequelize.query(query, {
                replacements: params,
                type: sequelize.QueryTypes.SELECT
            });
            
            return result;
            
        } catch (error) {
            console.error('Error en obtenerEstadisticas:', error);
            throw error;
        }
    }
}

module.exports = DatabaseService;

/backend\src\services\emailService.js:
--------------------------------------------------------------------------------
const nodemailer = require('nodemailer');

class EmailService {
    
    static transporter = null;
    
    static async inicializar() {
        try {
            this.transporter = nodemailer.createTransport({
                host: process.env.SMTP_HOST,
                port: process.env.SMTP_PORT,
                secure: process.env.SMTP_SECURE === 'true',
                auth: {
                    user: process.env.SMTP_USER,
                    pass: process.env.SMTP_PASS
                }
            });
            
            // Verificar conexi√≥n
            await this.transporter.verify();
            console.log('‚úÖ Servicio de email configurado correctamente');
            
        } catch (error) {
            console.error('‚ùå Error al configurar servicio de email:', error);
            this.transporter = null;
        }
    }
    
    static async enviarEmail(destinatario, asunto, contenido, adjuntos = []) {
        if (!this.transporter) {
            console.warn('Servicio de email no configurado');
            return false;
        }
        
        try {
            const mailOptions = {
                from: `"Sistema de Gesti√≥n Psicol√≥gica" <${process.env.SMTP_FROM || process.env.SMTP_USER}>`,
                to: destinatario,
                subject: asunto,
                html: contenido,
                attachments: adjuntos
            };
            
            const info = await this.transporter.sendMail(mailOptions);
            console.log(`üìß Email enviado a ${destinatario}: ${info.messageId}`);
            
            return true;
            
        } catch (error) {
            console.error('‚ùå Error al enviar email:', error);
            return false;
        }
    }
    
    static async enviarNotificacionCita(datosCita) {
        const { paciente, fecha, hora, tipo_consulta, ubicacion, psicologo } = datosCita;
        
        const asunto = `Recordatorio de Cita - ${fecha}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #4a6fa5; color: var(--white); padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #4a6fa5; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Recordatorio de Cita</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${paciente.nombre}</strong>,</p>
                        
                        <p>Le recordamos que tiene programada una cita de terapia psicol√≥gica:</p>
                        
                        <div class="details">
                            <p><strong>Fecha:</strong> ${fecha}</p>
                            <p><strong>Hora:</strong> ${hora}</p>
                            <p><strong>Modalidad:</strong> ${tipo_consulta === 'virtual' ? 'Virtual' : 'Presencial'}</p>
                            ${tipo_consulta === 'presencial' ? `<p><strong>Ubicaci√≥n:</strong> ${ubicacion || 'Consultorio asignado'}</p>` : ''}
                            <p><strong>Psic√≥logo/a:</strong> ${psicologo.nombre} ${psicologo.apellido}</p>
                        </div>
                        
                        ${tipo_consulta === 'virtual' ? `
                        <p><strong>Enlace para la sesi√≥n virtual:</strong> <a href="${ubicacion}">${ubicacion}</a></p>
                        ` : ''}
                        
                        <p>Por favor, confirme su asistencia respondiendo a este correo o contactando a su terapeuta.</p>
                        
                        <p>Si necesita reprogramar o cancelar su cita, h√°galo con al menos 24 horas de anticipaci√≥n.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje autom√°tico del Sistema de Gesti√≥n Psicol√≥gica.</p>
                        <p>Por favor, no responda a este correo.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(paciente.email, asunto, contenido);
    }
    
    static async enviarNotificacionAlta(datosAlta) {
        const { paciente, fecha_alta, tipo_alta, recomendaciones, psicologo } = datosAlta;
        
        const asunto = `Proceso de Alta - ${paciente.nombre} ${paciente.apellido}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #28a745; color: var(--white); padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #28a745; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Proceso de Alta Completado</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${paciente.nombre} ${paciente.apellido}</strong>,</p>
                        
                        <p>Le informamos que se ha completado su proceso terap√©utico en nuestro centro.</p>
                        
                        <div class="details">
                            <p><strong>Fecha de alta:</strong> ${fecha_alta}</p>
                            <p><strong>Tipo de alta:</strong> ${this.obtenerDescripcionAlta(tipo_alta)}</p>
                            <p><strong>Psic√≥logo/a responsable:</strong> ${psicologo.nombre} ${psicologo.apellido}</p>
                        </div>
                        
                        ${recomendaciones ? `
                        <h3>Recomendaciones:</h3>
                        <p>${recomendaciones}</p>
                        ` : ''}
                        
                        <p>Le agradecemos la confianza depositada en nosotros y le deseamos lo mejor en su continuo crecimiento personal.</p>
                        
                        <p>Si en el futuro requiere apoyo psicol√≥gico, no dude en contactarnos nuevamente.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje autom√°tico del Sistema de Gesti√≥n Psicol√≥gica.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(paciente.email, asunto, contenido);
    }
    
    static async enviarNotificacionObservacion(datosObservacion) {
        const { becario, supervisor, fecha, calificacion, aspectos } = datosObservacion;
        
        const asunto = `Nueva Observaci√≥n - ${fecha}`;
        
        const contenido = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                    .header { background-color: #ffc107; color: #333; padding: 20px; text-align: center; }
                    .content { padding: 20px; background-color: #f9f9f9; }
                    .footer { padding: 10px; text-align: center; font-size: 12px; color: #666; }
                    .details { margin: 20px 0; padding: 15px; background-color: #fff; border-left: 4px solid #ffc107; }
                    .aspecto { margin: 10px 0; padding: 10px; background-color: #f8f9fa; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Nueva Observaci√≥n de Supervisi√≥n</h1>
                    </div>
                    <div class="content">
                        <p>Estimado/a <strong>${becario.nombre} ${becario.apellido}</strong>,</p>
                        
                        <p>Su supervisor ${supervisor.nombre} ${supervisor.apellido} ha registrado una nueva observaci√≥n sobre su desempe√±o.</p>
                        
                        <div class="details">
                            <p><strong>Fecha:</strong> ${fecha}</p>
                            <p><strong>Calificaci√≥n general:</strong> ${calificacion}/10</p>
                        </div>
                        
                        ${aspectos && aspectos.length > 0 ? `
                        <h3>Aspectos evaluados:</h3>
                        ${aspectos.map(aspecto => `
                            <div class="aspecto">
                                <p><strong>${aspecto.nombre}:</strong> ${aspecto.calificacion}/10</p>
                                ${aspecto.comentario ? `<p><em>${aspecto.comentario}</em></p>` : ''}
                            </div>
                        `).join('')}
                        ` : ''}
                        
                        <p>Revise su panel para ver los detalles completos y las recomendaciones de mejora.</p>
                        
                        <p>Esta retroalimentaci√≥n tiene como objetivo apoyar su desarrollo profesional.</p>
                    </div>
                    <div class="footer">
                        <p>Este es un mensaje autom√°tico del Sistema de Gesti√≥n Psicol√≥gica.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
        
        return await this.enviarEmail(becario.email, asunto, contenido);
    }
    
    static async enviarReporteAdjunto(destinatario, asunto, contenido, archivoBuffer, nombreArchivo) {
        const adjuntos = [{
            filename: nombreArchivo,
            content: archivoBuffer,
            contentType: this.obtenerContentType(nombreArchivo)
        }];
        
        return await this.enviarEmail(destinatario, asunto, contenido, adjuntos);
    }
    
    static async enviarRecordatoriosCitas() {
        try {
            // Esta funci√≥n se llamar√≠a desde un job/cron
            // Obtener citas para ma√±ana
            const fechaManana = new Date();
            fechaManana.setDate(fechaManana.getDate() + 1);
            const fechaStr = fechaManana.toISOString().split('T')[0];
            
            // En una implementaci√≥n real, se obtendr√≠an las citas de la BD
            const citasRecordatorio = []; // Obtener de BD
            
            for (const cita of citasRecordatorio) {
                if (cita.paciente.email) {
                    await this.enviarNotificacionCita(cita);
                }
            }
            
            return true;
            
        } catch (error) {
            console.error('Error al enviar recordatorios:', error);
            return false;
        }
    }
    
    // M√©todos auxiliares
    static obtenerDescripcionAlta(tipo_alta) {
        const descripciones = {
            'terapeutica': 'Alta Terap√©utica (Objetivos cumplidos)',
            'abandono': 'Abandono del Tratamiento',
            'traslado': 'Traslado a otro centro',
            'graduacion': 'Graduaci√≥n del Programa',
            'no_continua': 'No Contin√∫a el Tratamiento',
            'otro': 'Otro motivo'
        };
        return descripciones[tipo_alta] || tipo_alta;
    }
    
    static obtenerContentType(nombreArchivo) {
        const extension = nombreArchivo.split('.').pop().toLowerCase();
        
        const tipos = {
            'pdf': 'application/pdf',
            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'xls': 'application/vnd.ms-excel',
            'csv': 'text/csv',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'doc': 'application/msword'
        };
        
        return tipos[extension] || 'application/octet-stream';
    }
}

// Inicializar al cargar el m√≥dulo
EmailService.inicializar().catch(console.error);

module.exports = EmailService;

/backend\src\services\estadisticaService.js:
--------------------------------------------------------------------------------
const { QueryTypes } = require('sequelize');
const sequelize = require('../config/db');

class EstadisticaService {
    
    static async calcularEstadisticasGenerales(periodo = 'mes') {
        try {
            let intervalo;
            switch (periodo) {
                case 'semana':
                    intervalo = 'INTERVAL 7 DAY';
                    break;
                case 'mes':
                    intervalo = 'INTERVAL 30 DAY';
                    break;
                case 'trimestre':
                    intervalo = 'INTERVAL 90 DAY';
                    break;
                case 'a√±o':
                    intervalo = 'INTERVAL 365 DAY';
                    break;
                default:
                    intervalo = 'INTERVAL 30 DAY';
            }
            
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    -- Pacientes
                    (SELECT COUNT(*) FROM pacientes WHERE created_at >= DATE_SUB(CURDATE(), ${intervalo})) as nuevos_pacientes,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = TRUE) as pacientes_activos,
                    (SELECT COUNT(*) FROM pacientes WHERE activo = FALSE) as pacientes_inactivos,
                    
                    -- Citas
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as total_citas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') as citas_completadas,
                    (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'cancelada') as citas_canceladas,
                    
                    -- Tasa de asistencia
                    ROUND(
                        (SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado = 'completada') * 100.0 / 
                        NULLIF((SELECT COUNT(*) FROM citas WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo}) AND estado IN ('programada', 'confirmada', 'completada')), 0),
                        2
                    ) as tasa_asistencia,
                    
                    -- Profesionales
                    (SELECT COUNT(*) FROM users WHERE rol = 'psicologo' AND activo = TRUE) as psicologos_activos,
                    (SELECT COUNT(*) FROM users WHERE rol = 'becario' AND activo = TRUE) as becarios_activos,
                    
                    -- Sesiones registradas
                    (SELECT COUNT(*) FROM sesiones s 
                     JOIN citas c ON s.cita_id = c.id 
                     WHERE c.fecha >= DATE_SUB(CURDATE(), ${intervalo})) as sesiones_registradas,
                    
                    -- Altas
                    (SELECT COUNT(*) FROM altas WHERE fecha_alta >= DATE_SUB(CURDATE(), ${intervalo})) as altas_realizadas,
                    
                    -- Observaciones
                    (SELECT COUNT(*) FROM observaciones_becarios WHERE fecha >= DATE_SUB(CURDATE(), ${intervalo})) as observaciones_realizadas
            `, { type: QueryTypes.SELECT });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasGenerales:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasPsicologo(psicologoId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as psicologo,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT a.becario_id) as becarios_supervisados,
                    
                    -- Tiempo
                    ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                    SUM(c.duracion_minutos) / 60.0 as horas_total,
                    
                    -- Sesiones registradas
                    COUNT(s.id) as sesiones_registradas,
                    
                    -- Observaciones
                    COUNT(ob.id) as observaciones_realizadas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion_observaciones,
                    
                    -- Altas
                    COUNT(al.id) as altas_realizadas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.psicologo_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN sesiones s ON c.id = s.cita_id
                LEFT JOIN asignaciones a ON u.id = a.psicologo_id AND a.estado = 'activa'
                LEFT JOIN observaciones_becarios ob ON u.id = ob.supervisor_id
                    AND ob.fecha BETWEEN ? AND ?
                LEFT JOIN altas al ON u.id = al.usuario_id
                    AND al.fecha_alta BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [fechaInicio, fechaFin, fechaInicio, fechaFin, fechaInicio, fechaFin, psicologoId],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasPsicologo:', error);
            throw error;
        }
    }
    
    static async calcularEstadisticasBecario(becarioId, fechaInicio, fechaFin) {
        try {
            const [estadisticas] = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    
                    -- Citas
                    COUNT(c.id) as total_citas,
                    SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN c.estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    ROUND(SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id), 2) as tasa_completitud,
                    
                    -- Pacientes
                    COUNT(DISTINCT c.paciente_id) as pacientes_unicos,
                    
                    -- Observaciones recibidas
                    COUNT(ob.id) as observaciones_recibidas,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    
                    -- Tiempo entre citas
                    ROUND(AVG(
                        DATEDIFF(
                            (SELECT MIN(c2.fecha) FROM citas c2 
                             WHERE c2.becario_id = c.becario_id 
                             AND c2.paciente_id = c.paciente_id 
                             AND c2.id > c.id),
                            c.fecha
                        )
                    ), 1) as dias_promedio_entre_citas
                    
                FROM users u
                LEFT JOIN citas c ON u.id = c.becario_id 
                    AND c.fecha BETWEEN ? AND ?
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                    AND ob.fecha BETWEEN ? AND ?
                WHERE u.id = ?
                GROUP BY u.id, u.nombre, u.apellido
            `, {
                replacements: [becarioId, fechaInicio, fechaFin, fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return estadisticas;
            
        } catch (error) {
            console.error('Error en calcularEstadisticasBecario:', error);
            throw error;
        }
    }
    
    static async calcularTendenciasMensuales(meses = 6) {
        try {
            const tendencias = await sequelize.query(`
                SELECT 
                    DATE_FORMAT(fecha, '%Y-%m') as mes,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as citas_canceladas,
                    COUNT(DISTINCT paciente_id) as pacientes_unicos,
                    COUNT(DISTINCT psicologo_id) as psicologos_activos,
                    COUNT(DISTINCT becario_id) as becarios_activos,
                    (SELECT COUNT(*) FROM altas WHERE DATE_FORMAT(fecha_alta, '%Y-%m') = DATE_FORMAT(c.fecha, '%Y-%m')) as altas_realizadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud
                FROM citas c
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL ? MONTH)
                GROUP BY DATE_FORMAT(fecha, '%Y-%m')
                ORDER BY mes
            `, {
                replacements: [meses],
                type: QueryTypes.SELECT
            });
            
            return tendencias;
            
        } catch (error) {
            console.error('Error en calcularTendenciasMensuales:', error);
            throw error;
        }
    }
    
    static async calcularDistribucionPorGenero() {
        try {
            const distribucion = await sequelize.query(`
                SELECT 
                    COALESCE(genero, 'no especificado') as genero,
                    COUNT(*) as cantidad,
                    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as porcentaje
                FROM pacientes
                WHERE activo = TRUE
                GROUP BY genero
                ORDER BY cantidad DESC
            `, { type: QueryTypes.SELECT });
            
            return distribucion;
            
        } catch (error) {
            console.error('Error en calcularDistribucionPorGenero:', error);
            throw error;
        }
    }
    
    static async calcularHorariosMasProductivos() {
        try {
            const horarios = await sequelize.query(`
                SELECT 
                    HOUR(hora) as hora,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                    ROUND(SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as tasa_completitud,
                    ROUND(AVG(duracion_minutos), 1) as duracion_promedio
                FROM citas
                WHERE fecha >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
                GROUP BY HOUR(hora)
                ORDER BY total_citas DESC
                LIMIT 8
            `, { type: QueryTypes.SELECT });
            
            return horarios;
            
        } catch (error) {
            console.error('Error en calcularHorariosMasProductivos:', error);
            throw error;
        }
    }
    
    static async calcularMetricasEficiencia() {
        try {
            const [metricas] = await sequelize.query(`
                SELECT 
                    -- Tiempo promedio entre primera y √∫ltima cita por paciente
                    ROUND(AVG(DATEDIFF(
                        ultima_cita.ultima,
                        primera_cita.primera
                    )), 1) as dias_tratamiento_promedio,
                    
                    -- Citas promedio por paciente
                    ROUND(AVG(total_citas.total), 1) as citas_promedio_por_paciente,
                    
                    -- Tasa de retenci√≥n (pacientes con m√°s de 1 cita)
                    ROUND(
                        COUNT(DISTINCT CASE WHEN total_citas.total > 1 THEN total_citas.paciente_id END) * 100.0 / 
                        COUNT(DISTINCT total_citas.paciente_id),
                        2
                    ) as tasa_retencion,
                    
                    -- Tiempo promedio para primera cita despu√©s del registro
                    ROUND(AVG(DATEDIFF(
                        primera_cita.primera,
                        p.created_at
                    )), 1) as dias_para_primera_cita
                    
                FROM pacientes p
                LEFT JOIN (
                    SELECT paciente_id, MIN(fecha) as primera
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) primera_cita ON p.id = primera_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, MAX(fecha) as ultima
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) ultima_cita ON p.id = ultima_cita.paciente_id
                LEFT JOIN (
                    SELECT paciente_id, COUNT(*) as total
                    FROM citas 
                    WHERE estado = 'completada'
                    GROUP BY paciente_id
                ) total_citas ON p.id = total_citas.paciente_id
                WHERE p.activo = TRUE
            `, { type: QueryTypes.SELECT });
            
            return metricas;
            
        } catch (error) {
            console.error('Error en calcularMetricasEficiencia:', error);
            throw error;
        }
    }
    
    static async calcularSatisfaccionBecarios() {
        try {
            const satisfaccion = await sequelize.query(`
                SELECT 
                    u.id,
                    CONCAT(u.nombre, ' ', u.apellido) as becario,
                    COUNT(ob.id) as total_observaciones,
                    ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                    ROUND(STDDEV(ob.calificacion), 2) as desviacion_estandar,
                    MIN(ob.calificacion) as calificacion_minima,
                    MAX(ob.calificacion) as calificacion_maxima,
                    COUNT(DISTINCT ob.aspecto_evaluado) as aspectos_evaluados,
                    (SELECT CONCAT(sup.nombre, ' ', sup.apellido) 
                     FROM asignaciones a 
                     JOIN users sup ON a.psicologo_id = sup.id 
                     WHERE a.becario_id = u.id AND a.estado = 'activa' LIMIT 1) as supervisor
                FROM users u
                LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                WHERE u.rol = 'becario' AND u.activo = TRUE
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY promedio_calificacion DESC
            `, { type: QueryTypes.SELECT });
            
            return satisfaccion;
            
        } catch (error) {
            console.error('Error en calcularSatisfaccionBecarios:', error);
            throw error;
        }
    }
    
    static async predecirDemanda(fechaInicio, fechaFin) {
        try {
            // An√°lisis hist√≥rico para predecir demanda
            const prediccion = await sequelize.query(`
                SELECT 
                    -- Por d√≠a de la semana
                    DAYNAME(fecha) as dia_semana,
                    COUNT(*) as historico_total,
                    ROUND(AVG(COUNT(*)) OVER(), 0) as promedio_diario,
                    
                    -- Por hora
                    HOUR(hora) as hora_dia,
                    COUNT(*) as citas_por_hora,
                    
                    -- Por psic√≥logo
                    psicologo_id,
                    COUNT(*) as citas_psicologo
                    
                FROM citas
                WHERE fecha BETWEEN ? AND ?
                AND estado IN ('programada', 'confirmada', 'completada')
                GROUP BY DAYNAME(fecha), HOUR(hora), psicologo_id
                ORDER BY dia_semana, hora_dia
            `, {
                replacements: [fechaInicio, fechaFin],
                type: QueryTypes.SELECT
            });
            
            return prediccion;
            
        } catch (error) {
            console.error('Error en predecirDemanda:', error);
            throw error;
        }
    }
    
    static async generarReporteComparativo(periodo, tipoComparacion) {
        try {
            let query;
            
            switch (tipoComparacion) {
                case 'psicologos':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'psicologo' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(c.duracion_minutos), 1) as duracion_promedio,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.psicologo_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'psicologo' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                case 'becarios':
                    query = `
                        SELECT 
                            u.id,
                            CONCAT(u.nombre, ' ', u.apellido) as profesional,
                            'becario' as tipo,
                            COUNT(c.id) as total_citas,
                            SUM(CASE WHEN c.estado = 'completada' THEN 1 ELSE 0 END) as citas_completadas,
                            ROUND(AVG(ob.calificacion), 2) as promedio_calificacion,
                            COUNT(DISTINCT c.paciente_id) as pacientes_unicos
                        FROM users u
                        LEFT JOIN citas c ON u.id = c.becario_id
                            AND c.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        LEFT JOIN observaciones_becarios ob ON u.id = ob.becario_id
                            AND ob.fecha >= DATE_SUB(CURDATE(), INTERVAL ? DAY)
                        WHERE u.rol = 'becario' AND u.activo = TRUE
                        GROUP BY u.id, u.nombre, u.apellido
                        ORDER BY citas_completadas DESC
                    `;
                    break;
                    
                default:
                    throw new Error('Tipo de comparaci√≥n no v√°lido');
            }
            
            const resultados = await sequelize.query(query, {
                replacements: [periodo, periodo],
                type: QueryTypes.SELECT
            });
            
            return resultados;
            
        } catch (error) {
            console.error('Error en generarReporteComparativo:', error);
            throw error;
        }
    }
}

module.exports = EstadisticaService;

/backend\src\services\index.js:
--------------------------------------------------------------------------------
// Services for business logic

/backend\src\services\reporteService.js:
--------------------------------------------------------------------------------
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');

class ReporteService {
    
    static async generarExcel(datos, tipoReporte) {
        try {
            const workbook = new ExcelJS.Workbook();
            workbook.creator = 'Sistema de Gesti√≥n Psicol√≥gica';
            workbook.created = new Date();
            
            let worksheet;
            let columns = [];
            
            switch (tipoReporte) {
                case 'citas':
                    worksheet = workbook.addWorksheet('Reporte de Citas');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'MODALIDAD', key: 'MODALIDAD', width: 15 },
                        { header: 'Empleado', key: 'Empleado', width: 20 },
                        { header: 'ESTUDIANTE', key: 'ESTUDIANTE', width: 25 },
                        { header: 'CARRERA', key: 'CARRERA', width: 20 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'EDAD', key: 'EDAD', width: 8 },
                        { header: 'SEXO', key: 'SEXO', width: 10 },
                        { header: 'MOTIVO DE CONSULTA', key: 'MOTIVO_DE_CONSULTA', width: 30 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'CORREO', key: 'CORREO', width: 25 },
                        { header: 'DIA', key: 'DIA', width: 12 },
                        { header: 'HORA', key: 'HORA', width: 10 },
                        { header: 'ESTATUS', key: 'ESTATUS', width: 12 },
                        { header: 'PRACTICANTE', key: 'PRACTICANTE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 },
                        { header: 'ATIENDE', key: 'ATIENDE', width: 20 }
                    ];
                    break;
                    
                case 'pacientes':
                    worksheet = workbook.addWorksheet('Reporte de Pacientes');
                    columns = [
                        { header: 'MES', key: 'MES', width: 10 },
                        { header: 'NOMBRE', key: 'NOMBRE', width: 25 },
                        { header: 'TELEFONO', key: 'TELEFONO', width: 15 },
                        { header: 'MATRICULA', key: 'MATRICULA', width: 15 },
                        { header: 'CUATRI', key: 'CUATRI', width: 10 },
                        { header: 'TIPO DE SERVICIO', key: 'TIPO_DE_SERVICIO', width: 20 },
                        { header: 'FECHA DE PRESENTACION', key: 'FECHA_DE_PRESENTACION', width: 20 },
                        { header: 'No. de sesiones terap√©uticas personales', key: 'No_de_sesiones_terapeuticas_personales', width: 15 },
                        { header: 'FECHA DE ACEPTACION', key: 'FECHA_DE_ACEPTACION', width: 20 },
                        { header: 'MMPI-2 RF', key: 'MMPI_2_RF', width: 15 },
                        { header: 'FECHA DE TERMINO', key: 'FECHA_DE_TERMINO', width: 20 },
                        { header: 'CARTA DE LIBERACION', key: 'CARTA_DE_LIBERACION', width: 20 },
                        { header: 'HORAS OBJETIVO', key: 'HORAS_OBJETIVO', width: 15 },
                        { header: 'HORAS REALIZADAS', key: 'HORAS_REALIZADAS', width: 15 },
                        { header: 'HORAS FALTANTES', key: 'HORAS_FALTANTES', width: 15 },
                        { header: 'SERVICIO COMUNITARIO LIBERADO', key: 'SERVICIO_COMUNITARIO_LIBERADO', width: 20 },
                        { header: 'QUIEN ATIENDE', key: 'QUIEN_ATIENDE', width: 20 },
                        { header: 'OBSERVACIONES', key: 'OBSERVACIONES', width: 30 }
                    ];
                    break;
                    
                default:
                    worksheet = workbook.addWorksheet('Reporte');
                    columns = Object.keys(datos[0] || {}).map(key => ({
                        header: key.toUpperCase(),
                        key: key,
                        width: 20
                    }));
            }
            
            worksheet.columns = columns;
            
            // Agregar datos
            if (datos && datos.length > 0) {
                datos.forEach(row => {
                    worksheet.addRow(row);
                });
            }
            
            // Aplicar estilos a la cabecera
            worksheet.getRow(1).font = { bold: true };
            worksheet.getRow(1).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFE0E0E0' }
            };
            
            // Autoajustar columnas
            worksheet.columns.forEach(column => {
                let maxLength = 0;
                column.eachCell({ includeEmpty: true }, cell => {
                    const cellLength = cell.value ? cell.value.toString().length : 0;
                    if (cellLength > maxLength) {
                        maxLength = cellLength;
                    }
                });
                column.width = Math.min(maxLength + 2, 50);
            });
            
            // Generar buffer
            const buffer = await workbook.xlsx.writeBuffer();
            return buffer;
            
        } catch (error) {
            console.error('Error en generarExcel:', error);
            throw error;
        }
    }
    
    static async generarPDF(datos, tipoReporte, titulo) {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({ margin: 50 });
                const chunks = [];
                
                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => {
                    const buffer = Buffer.concat(chunks);
                    resolve(buffer);
                });
                
                // Encabezado
                doc.fontSize(20).text(titulo || 'Reporte del Sistema', { align: 'center' });
                doc.moveDown();
                doc.fontSize(12).text(`Generado: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, { align: 'center' });
                doc.moveDown(2);
                
                // Contenido seg√∫n tipo de reporte
                switch (tipoReporte) {
                    case 'resumen':
                        this.generarPDFResumen(doc, datos);
                        break;
                    case 'paciente':
                        this.generarPDFPaciente(doc, datos);
                        break;
                    default:
                        this.generarPDFTabla(doc, datos);
                }
                
                doc.end();
                
            } catch (error) {
                reject(error);
            }
        });
    }
    
    static generarPDFResumen(doc, datos) {
        doc.fontSize(16).text('Resumen Estad√≠stico', { underline: true });
        doc.moveDown();
        
        if (datos.estadisticas) {
            const stats = datos.estadisticas;
            doc.fontSize(12);
            doc.text(`Total de Pacientes: ${stats.total_pacientes || 0}`);
            doc.text(`Pacientes Activos: ${stats.pacientes_activos || 0}`);
            doc.text(`Citas del Mes: ${stats.total_citas_mes || 0}`);
            doc.text(`Citas Completadas: ${stats.citas_completadas || 0}`);
            doc.text(`Tasa de Completitud: ${stats.tasa_completitud || '0'}%`);
            doc.moveDown();
        }
        
        if (datos.evolucion_mensual && datos.evolucion_mensual.length > 0) {
            doc.fontSize(14).text('Evoluci√≥n Mensual:', { underline: true });
            doc.moveDown();
            
            datos.evolucion_mensual.forEach(item => {
                doc.fontSize(10).text(`${item.mes}: ${item.total_citas} citas (${item.citas_completadas} completadas)`);
            });
        }
    }
    
    static generarPDFPaciente(doc, datos) {
        doc.fontSize(16).text(`Expediente de ${datos.paciente?.nombre || ''} ${datos.paciente?.apellido || ''}`, { underline: true });
        doc.moveDown();
        
        // Informaci√≥n b√°sica
        doc.fontSize(12).text('Informaci√≥n B√°sica:', { underline: true });
        doc.fontSize(10);
        if (datos.paciente) {
            doc.text(`Nombre: ${datos.paciente.nombre} ${datos.paciente.apellido}`);
            doc.text(`Tel√©fono: ${datos.paciente.telefono || 'No especificado'}`);
            doc.text(`Email: ${datos.paciente.email || 'No especificado'}`);
            doc.text(`Fecha de Nacimiento: ${datos.paciente.fecha_nacimiento || 'No especificado'}`);
        }
        doc.moveDown();
        
        // Historial de sesiones
        if (datos.sesiones && datos.sesiones.length > 0) {
            doc.fontSize(12).text('Historial de Sesiones:', { underline: true });
            doc.moveDown();
            
            datos.sesiones.forEach((sesion, index) => {
                doc.fontSize(10).text(`${index + 1}. ${sesion.fecha} - ${sesion.psicologo_nombre}`);
                if (sesion.conclusion) {
                    doc.fontSize(8).text(`   Conclusiones: ${sesion.conclusion.substring(0, 100)}...`);
                }
                doc.moveDown(0.5);
            });
        }
    }
    
    static generarPDFTabla(doc, datos) {
        if (!datos || datos.length === 0) {
            doc.text('No hay datos para mostrar');
            return;
        }
        
        // Obtener columnas
        const columnas = Object.keys(datos[0]);
        const anchoColumna = 500 / columnas.length;
        
        // Encabezado de tabla
        doc.fontSize(10).font('Helvetica-Bold');
        let xPos = 50;
        
        columnas.forEach(columna => {
            doc.text(columna.toUpperCase(), xPos, doc.y, { width: anchoColumna });
            xPos += anchoColumna;
        });
        
        doc.moveDown();
        doc.font('Helvetica');
        
        // L√≠nea separadora
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown();
        
        // Filas de datos
        datos.forEach(fila => {
            xPos = 50;
            columnas.forEach(columna => {
                const valor = fila[columna] !== null && fila[columna] !== undefined ? 
                            fila[columna].toString() : '';
                doc.fontSize(8).text(valor.substring(0, 30), xPos, doc.y, { width: anchoColumna });
                xPos += anchoColumna;
            });
            doc.moveDown();
        });
    }
    
    static async generarCSV(datos, delimitador = ',') {
        if (!datos || datos.length === 0) {
            return '';
        }
        
        const columnas = Object.keys(datos[0]);
        let csv = columnas.join(delimitador) + '\n';
        
        datos.forEach(fila => {
            const valores = columnas.map(columna => {
                const valor = fila[columna];
                if (valor === null || valor === undefined) {
                    return '';
                }
                // Escapar comillas y delimitadores
                const valorStr = valor.toString();
                if (valorStr.includes(delimitador) || valorStr.includes('"') || valorStr.includes('\n')) {
                    return `"${valorStr.replace(/"/g, '""')}"`;
                }
                return valorStr;
            });
            csv += valores.join(delimitador) + '\n';
        });
        
        return csv;
    }
    
    static async guardarReporteArchivo(buffer, formato, nombreBase) {
        try {
            const timestamp = new Date().getTime();
            const nombreArchivo = `${nombreBase}_${timestamp}.${formato}`;
            const rutaArchivo = path.join(__dirname, '..', '..', 'reports', nombreArchivo);
            
            // Crear directorio si no existe
            await fs.mkdir(path.dirname(rutaArchivo), { recursive: true });
            
            // Guardar archivo
            await fs.writeFile(rutaArchivo, buffer);
            
            return {
                nombre: nombreArchivo,
                ruta: `/reports/${nombreArchivo}`,
                tamano: buffer.length
            };
            
        } catch (error) {
            console.error('Error al guardar reporte:', error);
            throw error;
        }
    }
    
    static async eliminarReporteAntiguos(dias = 30) {
        try {
            const directorio = path.join(__dirname, '..', '..', 'reports');
            const fechaLimite = new Date(Date.now() - dias * 24 * 60 * 60 * 1000);
            
            const archivos = await fs.readdir(directorio);
            
            for (const archivo of archivos) {
                const rutaArchivo = path.join(directorio, archivo);
                const stats = await fs.stat(rutaArchivo);
                
                if (stats.mtime < fechaLimite) {
                    await fs.unlink(rutaArchivo);
                    console.log(`Eliminado archivo antiguo: ${archivo}`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('Error al eliminar reportes antiguos:', error);
            return false;
        }
    }
}

module.exports = ReporteService;

/frontend\.env:
--------------------------------------------------------------------------------
PORT=3001
BROWSER=none

/frontend\package.json:
--------------------------------------------------------------------------------
{
  "name": "frontend-psico",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.0",
    "axios": "^1.6.0",
    "react-icons": "^4.12.0",
    "date-fns": "^2.30.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "dev": "react-scripts start --no-lazy"
  },
  "devDependencies": {
    "react-scripts": "5.0.1"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

/frontend\src\App.css:
--------------------------------------------------------------------------------
/* Estilos generales de la aplicaci√≥n */
.app-container {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

/* Animaciones adicionales */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes slideInRight {
  from { transform: translateX(20px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes slideInLeft {
  from { transform: translateX(-20px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}

/* Clases de utilidad adicionales */
.animation-pulse {
  animation: pulse 2s infinite;
}

.animation-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animation-slide-in-left {
  animation: slideInLeft 0.3s ease-out;
}

.animation-bounce {
  animation: bounce 0.5s ease-in-out;
}

/* Scrollbar personalizado para toda la app */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--white);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--white);
}

/* Estados de hover para elementos interactivos */
.interactive-card {
  transition: all 0.3s ease;
  cursor: pointer;
}

.interactive-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
  border-color: var(--grnb);
}

/* Loader global */
.global-loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--blud);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.global-loader-content {
  text-align: center;
}

.global-loader-spinner {
  width: 60px;
  height: 60px;
  border: 4px solid var(--blub);
  border-top: 4px solid var(--blu);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.global-loader-text {
  margin-top: 20px;
  color: var(--white);
  font-size: 18px;
  font-weight: bold;
}

/* Notificaciones */
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 10000;
  max-width: 400px;
}

.notification {
  background: linear-gradient(135deg, var(--blud) 0%, var(--blub) 100%);
  border: 2px solid var(--grnb);
  border-radius: 8px;
  padding: 15px 20px;
  margin-bottom: 10px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  animation: slideInRight 0.3s ease-out;
  color: var(--white);
}

.notification.success {
  border-color: var(--grnb);
}

.notification.error {
  border-color: var(--rr);
}

.notification.warning {
  border-color: var(--yy);
}

.notification.info {
  border-color: var(--blu);
}

/* Tooltip */
.tooltip {
  position: relative;
  display: inline-block;
}

.tooltip .tooltip-text {
  visibility: hidden;
  width: 200px;
  background-color: var(--blud);
  color: var(--white);
  text-align: center;
  border-radius: 6px;
  padding: 8px;
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.3s;
  border: 1px solid var(--blu);
  font-size: 14px;
}

.tooltip:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

/frontend\src\App.js:
--------------------------------------------------------------------------------
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Login from './components/Auth/Login';
import RoleRouter from './components/Auth/RoleRouter';
import ProtectedRoute from './components/Auth/ProtectedRoute';

// Importa los modales
import ConfirmModal from './components/Common/ConfirmModal';
import NotificationModal from './components/Common/NotificationModal';

// P√°ginas para Becarios
import BecarioDashboard from './pages/becario/DashboardPage';
import BecarioCitas from './pages/becario/CitasPage';
import BecarioPacientes from './pages/becario/PacientesPage';
import BecarioNotificaciones from './pages/becario/NotificacionesPage';
import BecarioObservaciones from './pages/becario/ObservacionesPage';

// P√°ginas para Psic√≥logos
import PsicologoDashboard from './pages/psicologo/DashboardPage';
import PsicologoPacientes from './pages/psicologo/PacientesPage';
import PsicologoCitas from './pages/psicologo/CitasPage';
import PsicologoExpedientes from './pages/psicologo/ExpedientesPage';
import PsicologoSesiones from './pages/psicologo/SesionesPage';
import PsicologoSupervision from './pages/psicologo/SupervisionPage';

// P√°ginas para Coordinadores
import CoordinadorDashboard from './pages/coordinador/DashboardPage';
import CoordinadorUsuarios from './pages/coordinador/UsuariosPage';
import CoordinadorPacientes from './pages/coordinador/PacientesPage';
import CoordinadorAsignaciones from './pages/coordinador/AsignacionesPage';
import CoordinadorAgenda from './pages/coordinador/AgendaPage';
import CoordinadorReportes from './pages/coordinador/ReportesPage';
import CoordinadorAltas from './pages/coordinador/AltasPage';
import CoordinadorConfiguracion from './pages/coordinador/ConfiguracionPage';

function App() {
  return (
    <Router>
      <AuthProvider>
        {/* Agrega los modales aqu√≠ */}
        <ConfirmModal />
        <NotificationModal />
        
        <Routes>
          <Route path="/login" element={<Login />} />
          
          {/* Rutas de Becario */}
          <Route path="/" element={<RoleRouter />}>
            <Route index element={<BecarioDashboard />} />
            
            {/* Becario */}
            <Route path="becario/dashboard" element={<BecarioDashboard />} />
            <Route path="becario/citas" element={<BecarioCitas />} />
            <Route path="becario/pacientes" element={<BecarioPacientes />} />
            <Route path="becario/notificaciones" element={<BecarioNotificaciones />} />
            <Route path="becario/observaciones" element={<BecarioObservaciones />} />
            
            {/* Psic√≥logo */}
            <Route path="psicologo/dashboard" element={<PsicologoDashboard />} />
            <Route path="psicologo/pacientes" element={<PsicologoPacientes />} />
            <Route path="psicologo/citas" element={<PsicologoCitas />} />
            <Route path="psicologo/expedientes" element={<PsicologoExpedientes />} />
            <Route path="psicologo/sesiones" element={<PsicologoSesiones />} />
            <Route path="psicologo/supervision" element={<PsicologoSupervision />} />
            
            {/* Coordinador */}
            <Route path="coordinador/dashboard" element={<CoordinadorDashboard />} />
            <Route path="coordinador/usuarios" element={<CoordinadorUsuarios />} />
            <Route path="coordinador/pacientes" element={<CoordinadorPacientes />} />
            <Route path="coordinador/asignaciones" element={<CoordinadorAsignaciones />} />
            <Route path="coordinador/agenda" element={<CoordinadorAgenda />} />
            <Route path="coordinador/reportes" element={<CoordinadorReportes />} />
            <Route path="coordinador/altas" element={<CoordinadorAltas />} />
            <Route path="coordinador/configuracion" element={<CoordinadorConfiguracion />} />
          </Route>
          
          {/* Redirecci√≥n por defecto */}
          <Route path="*" element={<Navigate to="/" />} />
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;

/frontend\src\global.css:
--------------------------------------------------------------------------------
:root {
  /* Colores base - Manteniendo nombres originales */
  --grnb: #29ce6e;   /* Verde azulado oscuro */
  --blub: #2c3138;   /* Azul claro */
  --blud: #1B1E23;   /* Azul oscuro */
  --white: #ffffff;
  --grayl: #96a2ad;
  --gray: #6c757d;
  --gray-dark: #343a40;

  --whiteSET: #ffffff;
  --bludSET: #1B1E23;
  --blubSET: #2c3138;
  
  /* Colores adicionales */
  --blu: #1F85BA;      /* GRNB - Azul */
  --bludd: #1B6DA7;
  --blub-dark: #131923; /* BLUD - Azul m√°s oscuro */
  --blul: #1b2937;     /* BLUL - Azul oscuro */
  --grnd: #37b670;     /* GRND - Verde */
  --grnl: #30ff64;     /* GRNL - Verde claro */
  --rr: #fa3144;       /* RR - Rojo */
  --yy: #ffa631;       /* YY - Amarillo */
  --rl: #ff5363;       /* RL - Rojo claro */
  --yl: #ffdd55;       /* YL - Amarillo claro */
  --wt: #ffffff;       /* WT - Blanco */
}

[data-theme="light"] {
  /* Colores base - Manteniendo nombres originales */
  --blub: #fff;   /* Azul claro */
  --blud: #e8f1fa;   /* Azul oscuro */
  --white: #1B1E23;
  --grayl: #2c3138;
  --gray: #2c3138;
  --gray-dark: #343a40;

  --whiteSET: #ffffff;
  --bludSET: #1B1E23;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, var(--blub) 0%, var(--blud) 100%);
  color: var(--white);

}

/* ===== ESTRUCTURA PRINCIPAL ===== */
.main-container {
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  height: 100vh;
}

.dashboard-logo {
  max-width: 200px;
  height: auto;
  object-fit: contain;
}

.content-area {
  flex: 1;
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  border: 2px solid var(--blub);
  margin: 10px;
  padding: 15px;
  border-radius: 10px;
  position: relative;
  overflow: auto;
}

.grid-content {
  width: 1500px;
  height: 750px;
  background: transparent;
  border-radius: 0;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ===== HEADERS ===== */
.header {
  height: 35px;
  background: var(--blu);
  position: fixed;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
  position: relative;
  z-index: 10;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}

.top-header {
  height: 50px;
  background: var(--blu);
  display: flex;
  align-items: center;
  color: var(--whiteSET);
  justify-content: space-between;
  padding: 0 20px;
  z-index: 1000;

  
}

.window-controls {
  display: flex;
  gap: 10px;
}

/* ===== BOTONES GENERALES ===== */
.btn-header {
  background: transparent;
  border: 2px solid transparent;
  color: var(--whiteSET);
  font-weight: bold;
  padding: 8px 16px;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 15px;
}

.btn-header:hover {
  color: var(--bludSET);
}

.btn-header:disabled {
  color: var(--bludd);
  cursor: not-allowed;
}

.btn-header-logo {
  background: transparent;
  border: 2px solid transparent;
  color: transparent;
  font-weight: bold;
  padding: 8px 16px;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 15px;
}

.control-btn {
  background: transparent;
  border: none;
  color: var(--whiteSET);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: background 0.3s ease;
}

.control-btn:hover {
  color: var(--bludSET)
}

.btn-icon {
  width: 20px;
  height: 20px;
  transition: filter 0.3s ease;
}

.control-icon {
  width: 25px;
  height: 25px;
}

/* ===== BOTONES POR COLOR/TIPO ===== */
/* Bot√≥n primario (verde) */
.btn-primary {
  background: var(--grnb);
  margin-top: 10px;
  color: var(--blub);
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.btn-primary:hover:not(:disabled) {
  background: var(--white);
  color: var(--grnb);
}

.btn-primary:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.btn-primary:disabled:hover {
  background: var(--grnb);
  color: var(--blub);
}

/* Bot√≥n secundario (azul) */
.btn-secondary {
  background: var(--blu);
  color: var(--white);
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  margin-top: 10px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.btn-secondary:hover:not(:disabled) {
  background: var(--white);
  color: var(--blu);
}

.btn-secondary:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.btn-secondary:disabled:hover {
  background: var(--blu);
  color: var(--white);
}

/* Bot√≥n peligro/cancelar (rojo) */
.btn-danger {
  background: var(--rr);
  color: var(--white);
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.btn-danger:hover:not(:disabled) {
  background: var(--white);
  color: var(--rr);
}

.btn-danger:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.btn-danger:disabled:hover {
  background: var(--rr);
  color: var(--white);
}

/* Bot√≥n advertencia (amarillo) */
.btn-warning {
  background: var(--yy);
  color: var(--blub);
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
}

.btn-warning:hover:not(:disabled) {
  background: var(--white);
  color: var(--yy);
}

.btn-warning:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.btn-warning:disabled:hover {
  background: var(--yy);
  color: var(--blub);
}

/* Bot√≥n con texto sin fondo */
.btn-text {
  background: none;
  border: none;
  color: var(--blu);
  cursor: pointer;
  font-size: 14px;
  text-decoration: underline;
  padding: 5px;
  transition: all 0.3s ease;
}

.btn-text:hover {
  color: var(--white);
  text-decoration: none;
}

/* Bot√≥n redondeado especial */
.btn-rounded {
  padding: 12px;
  border-radius: 15px;
  border: none;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
}

/* ===== INPUTS GENERALES ===== */
.input-field {
  width: 100%;
  padding: 10px 16px;
  border-radius: 5px;
  border: 2px solid var(--blu);
  background: var(--blud);
  color: var(--white);
  font-size: 16px;
  outline: none;
  transition: border-color 0.3s ease, background-color 0.3s ease;
}

.input-field:focus {
  border-color: var(--grnb);
  background: var(--blud);
  color: var(--white);
}

.input-field:hover {
  border-color: var(--blu);
}

.input-field::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

/* Input especial para c√≥digos */
.code-input {
  width: 45px;
  height: 45px;
  font-size: 24px;
  background: var(--blud);
  color: var(--white);
  text-align: center;
  border: 2px solid var(--blub);
  border-radius: 5px;
  outline: none;
  transition: border-color 0.3s ease;
}

.code-input:focus {
  border-color: var(--blu);
}

.code-input-filled {
  border-color: var(--blu);
}

/* Input de b√∫squeda */
.search-input {
  width: 100%;
  padding: 10px;
  border-radius: 5px;
  border: 1px solid var(--blu);
  background: var(--blud);
  color: var(--white);
}

.search-input:focus {
  border-color: var(--blu);
  outline: none;
}

/* Textarea */
.textarea-field {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--blu);
  background: var(--blud);
  color: var(--white);
  border-radius: 5px;
  resize: vertical;
  min-height: 100px;
}

.textarea-field:focus {
  border-color: var(--blu);
  outline: none;
}

/* Select */
.select-field {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--blu);
  background: var(--blud);
  color: var(--white);
  border-radius: 5px;
}

.select-field:focus {
  border-color: var(--blu);
  outline: none;
}

/* ===== TARJETAS Y CONTENEDORES ===== */
.card {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  border: 2px solid var(--blub);
  backdrop-filter: blur(10px);
  border-radius: 10px;
  padding: 20px;
  color: var(--white);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.card-primary {
  border-color: var(--grnb);
}

.card-secondary {
  border-color: var(--blu);
}

.card-danger {
  border-color: var(--rr);
}

.card-warning {
  border-color: var(--yy);
}

/* Contenedor con fondo semitransparente */
.container-transparent {
  background: rgba(0, 0, 0, 0.30);
  border-radius: 10px;
  padding: 20px;
  backdrop-filter: blur(10px);
}

/* ===== MODALES ===== */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.3s ease;
}

.modal-container {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  border: 2px solid var(--blub);
  border-radius: 10px;
  padding: 30px;
  color: var(--white);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  max-width: 500px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  animation: slideUp 0.3s ease;
}

.modal-large {
  max-width: 800px;
  width: 95%;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 2px solid var(--blu);
}

.modal-title {
  margin: 0;
  color: var(--blu);
  font-size: 1.5em;
}

.modal-close {
  background: transparent;
  border: none;
  color: var(--rr);
  font-size: 28px;
  cursor: pointer;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.3s ease;
}

.modal-close:hover {
  color: var(--white);
  background: rgba(255, 255, 255, 0.1);
}

.modal-content {
  margin-bottom: 20px;
}

.modal-footer {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 20px;
  padding-top: 15px;
  border-top: 2px solid var(--blu);
}

/* ===== GRIDS Y LAYOUTS ===== */
.grid-2 {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
}

.grid-3 {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
}

.grid-auto {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.flex-row {
  display: flex;
  gap: 15px;
  align-items: center;
}

.flex-col {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

/* ===== ESTADOS Y MENSAJES ===== */
.error-message {
  color: var(--white);
  background: rgba(231, 76, 60, 0.2);
  padding: 10px;
  border-radius: 5px;
  margin-bottom: 15px;
  border: 1px solid var(--rr);
}

.success-message {
  color: var(--white);
  background: rgba(52, 152, 219, 0.2);
  padding: 10px;
  border-radius: 5px;
  margin-bottom: 15px;
  border: 1px solid var(--blu);
  font-weight: bold;
  text-align: center;
}

.warning-message {
  color: var(--white);
  background: rgba(241, 196, 15, 0.2);
  padding: 10px;
  border-radius: 5px;
  margin-bottom: 15px;
  border: 1px solid var(--yy);
}

/* Estados de carga */
.loading-container {
  text-align: center;
  padding: 40px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid var(--blu);
  border-top: 5px solid var(--white);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 18px;
  margin-top: 15px;
  color: var(--blu);
}

/* Estados de usuario/privilegios */
.status-verified {
  color: var(--grnb);
  font-weight: bold;
}

.status-pending {
  color: var(--yy);
  font-weight: bold;
}

.status-active {
  color: var(--grnb);
  font-weight: bold;
}

.status-inactive {
  color: var(--rr);
  font-weight: bold;
}

.privilege-admin {
  color: var(--rr);
  font-weight: bold;
}

.privilege-vendor {
  color: var(--blu);
  font-weight: bold;
}

/* ===== SCROLLBAR ===== */
.scrollable {
  overflow-y: auto;
}

.scrollable::-webkit-scrollbar {
  width: 6px;
}

.scrollable::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 3px;
}

.scrollable::-webkit-scrollbar-thumb {
  background: var(--white);
  border-radius: 3px;
}

.scrollable::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Para Firefox */
.scrollable {
  scrollbar-width: thin;
  scrollbar-color: var(--white) rgba(255, 255, 255, 0.05);
}

/* ===== ANIMACIONES ===== */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .grid-2,
  .grid-3 {
    grid-template-columns: 1fr;
  }
  
  .modal-container {
    width: 95%;
    padding: 20px;
  }
  
  .modal-footer {
    flex-direction: column;
  }
  
  .flex-row {
    flex-direction: column;
  }
  
  .btn-header {
    padding: 6px 12px;
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .header,
  .top-header {
    padding: 0 10px;
  }
  
  .modal-container {
    padding: 15px;
  }
  
  .btn-primary,
  .btn-secondary,
  .btn-danger,
  .btn-warning {
    padding: 8px 15px;
    font-size: 14px;
  }
}

/* ===== UTILIDADES ===== */
.text-center {
  text-align: center;
}

.text-right {
  text-align: right;
}

.text-left {
  text-align: left;
}

.mt-10 { margin-top: 10px; }
.mt-20 { margin-top: 20px; }
.mb-10 { margin-bottom: 10px; }
.mb-20 { margin-bottom: 20px; }
.ml-10 { margin-left: 10px; }
.mr-10 { margin-right: 10px; }

.p-10 { padding: 10px; }
.p-20 { padding: 20px; }
.pt-10 { padding-top: 10px; }
.pb-10 { padding-bottom: 10px; }

.w-100 { width: 100%; }
.h-100 { height: 100%; }

.hidden { display: none; }
.flex { display: flex; }
.grid { display: grid; }
.block { display: block; }
.inline { display: inline; }
.inline-block { display: inline-block; }

/* Tablas */
.table-container {
  width: 100%;
  overflow-x: auto;
  background: var(--blud);
  border-radius: 8px;
  border: 1px solid var(--blub);
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  color: var(--white);
}

.data-table th {
  background: var(--bludSET);
  padding: 12px 15px;
  text-align: left;
  font-weight: bold;
  border-bottom: 2px solid var(--blu);
}

.data-table td {
  padding: 12px 15px;
  border-bottom: 1px solid var(--blub);
}

.data-table tr:hover {
  background: rgba(31, 133, 186, 0.1);
}

.data-table tr:last-child td {
  border-bottom: none;
}

/* Badges */
.badge {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: bold;
  text-transform: uppercase;
}

.badge-success {
  background: rgba(31, 186, 121, 0.2);
  color: var(--grnb);
  border: 1px solid var(--grnb);
}

.badge-warning {
  background: rgba(255, 166, 49, 0.2);
  color: var(--yy);
  border: 1px solid var(--yy);
}

.badge-danger {
  background: rgba(250, 49, 68, 0.2);
  color: var(--rr);
  border: 1px solid var(--rr);
}

.badge-info {
  background: rgba(64, 148, 232, 0.2);
  color: var(--blu);
  border: 1px solid var(--blu);
}

/* Progress bars */
.progress-container {
  width: 100%;
  height: 8px;
  background: var(--blub);
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--blu) 0%, var(--bludd) 100%);
  border-radius: 4px;
  transition: width 0.3s ease;
}

/* Avatars */
.avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--blu);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--white);
  font-weight: bold;
  font-size: 16px;
}

.avatar-small {
  width: 32px;
  height: 32px;
  font-size: 14px;
}

.avatar-large {
  width: 60px;
  height: 60px;
  font-size: 24px;
}

/* Tabs */
.tabs {
  display: flex;
  border-bottom: 2px solid var(--blub);
  margin-bottom: 20px;
}

.tab {
  padding: 12px 24px;
  background: transparent;
  border: none;
  color: var(--grayl);
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
  border-bottom: 2px solid transparent;
  margin-bottom: -2px;
}

.tab:hover {
  color: var(--white);
}

.tab.active {
  color: var(--blu);
  border-bottom: 2px solid var(--blu);
}

/* Accordion */
.accordion {
  border: 1px solid var(--blub);
  border-radius: 8px;
  margin-bottom: 10px;
  overflow: hidden;
}

.accordion-header {
  padding: 15px 20px;
  background: var(--blud);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: bold;
  transition: background 0.3s ease;
}

.accordion-header:hover {
  background: var(--blub);
}

.accordion-content {
  padding: 20px;
  background: rgba(0, 0, 0, 0.1);
  border-top: 1px solid var(--blub);
}

/* Pagination */
.pagination {
  display: flex;
  gap: 5px;
  justify-content: center;
  margin-top: 20px;
}

.page-item {
  background: var(--blud);
  border: 1px solid var(--blub);
  color: var(--white);
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.page-item:hover {
  background: var(--white);
  border-color: var(--white);
}

.page-item.active {
  background: var(--blu);
  border-color: var(--blu);
  color: var(--blud);
}

/* Timeline para actividad reciente */
.timeline {
  position: relative;
  padding-left: 30px;
}

.timeline::before {
  content: '';
  position: absolute;
  left: 15px;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--bludd);
}

.timeline-item {
  position: relative;
  margin-bottom: 20px;
}

.timeline-item::before {
  content: '';
  position: absolute;
  left: -20px;
  top: 40px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--white);

}

.timeline-content {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  padding: 15px;
  border-radius: 8px;
  border: 1px solid var(--blub);
}

/* Layout Styles */
.content-wrapper {
  display: flex;
  flex: 1;
  overflow: auto;
  min-height: 0;
  height: calc(100vh - 80px);
}

.sidebar {
  width: 250px;
  background: var(--blub);
  border-right: 1px solid var(--blub);
  transition: width 0.3s ease;
  overflow-y: auto;
}

.sidebar.closed {
  width: 70px;
}

.main-content {
  flex: 1;
  overflow-y: auto;
}

.sidebar-nav {
  padding: 20px 0;
}

.sidebar-nav-item {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 12px 20px;
  color: var(--grayl);
  text-decoration: none;
  transition: all 0.3s ease;
  border-left: 3px solid transparent;
}

.sidebar-nav-item:hover {
  background: rgba(31, 133, 186, 0.1);
  color: var(--blu);
  border-left-color: var(--blu);
}

.sidebar-nav-item.active {
  background: rgba(31, 133, 186, 0.2);
  color: var(--white);
  border-left-color: var(--blu);
}

.sidebar-nav-item svg {
  font-size: 20px;
  color: var(--blu);
  min-width: 24px;
}

.status-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 30px;
  background: var(--blud);
  border-top: 1px solid var(--blub);
  padding: 0 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 12px;
  color: var(--grayl);
  z-index: 1000;
}

.user-info {
  display: flex;
  
  align-items: center;
  gap: 10px;
}

.user-email {
  color: var(--whiteSET);
  font-weight: 500;
}

/* Dashboard Styles */
.dashboard-page {
  padding: 0px;
}

.page-header {
  margin-bottom: 30px;
}

.page-header h1 {
  color: var(--whiteset);
  margin-bottom: 5px;
}

.page-header p {
  color: var(--grayl);
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.stat-card {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  border: 1px solid var(--blub);
  border-radius: 10px;
  padding: 20px;
  transition: all 0.3s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
  border-color: var(--blu);
}

.stat-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.stat-header h3 {
  font-size: 14px;
  color: var(--white);
  font-weight: normal;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.stat-value {
  font-size: 32px;
  font-weight: bold;
  color: var(--white);
  margin-bottom: 10px;
}

.stat-change {
  font-size: 12px;
  color: var(--grayl);
}

.dashboard-content-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
}

.dashboard-section {
  background: var(--blud);
  border: 1px solid var(--blub);
  border-radius: 10px;
  padding: 20px;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.citas-list, .pacientes-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.cita-item, .paciente-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  transition: background 0.3s ease;
}

.cita-item:hover, .paciente-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.cita-info, .paciente-info {
  flex: 1;
}

.cita-paciente, .paciente-nombre {
  font-weight: bold;
  color: var(--white);
}

.cita-hora, .paciente-fecha {
  font-size: 12px;
  color: var(--grayl);
}

.paciente-progreso {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 150px;
}

.progreso-text {
  font-size: 12px;
  color: var(--blu);
  min-width: 40px;
}

.activity-chart {
  height: 200px;
  padding: 20px;
}

.chart-bars {
  display: flex;
  align-items: flex-end;
  gap: 10px;
  height: 100%;
  padding-top: 20px;
}

.chart-bar {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100%;
}

.bar-fill {
  width: 20px;
  background: linear-gradient(to top, var(--blu), var(--bludd));
  border-radius: 4px 4px 0 0;
  transition: height 0.3s ease;
}

.bar-label {
  margin-top: 10px;
  font-size: 12px;
  color: var(--grayl);
}

.quick-actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Calendar Styles */
.calendar-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 15px;
  background: var(--blud);
  border-radius: 10px;
  border: 1px solid var(--blub);
}

.view-selector {
  display: flex;
  gap: 5px;
}

.date-navigation {
  display: flex;
  align-items: center;
  gap: 20px;
}

.current-date h3 {
  color: var(--white);
  margin: 0;
}

.calendar-day-view {
  display: flex;
  height: 600px;
  overflow-y: auto;
  background: var(--blud);
  border-radius: 10px;
  border: 1px solid var(--blub);
  margin-bottom: 20px;
}

.time-column {
  width: 80px;
  border-right: 1px solid var(--blub);
}

.time-slot {
  height: 60px;
  display: flex;
  align-items: flex-start;
  justify-content: flex-end;
  padding: 5px 10px;
  border-bottom: 1px solid var(--blub);
}

.time-label {
  color: var(--grayl);
  font-size: 12px;
}

.events-column {
  flex: 1;
  position: relative;
}

.hour-slot {
  height: 60px;
  border-bottom: 1px solid var(--blub);
  position: relative;
}

.event-item {
  position: absolute;
  left: 10px;
  right: 10px;
  background: var(--blub);
  border-radius: 8px;
  padding: 10px;
  overflow: hidden;
  transition: all 0.3s ease;
}

.event-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.event-confirmed {
  border-left: 4px solid var(--grnb);
}

.event-pending {
  border-left: 4px solid var(--yy);
}

.event-cancelled {
  border-left: 4px solid var(--rr);
}

.event-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 5px;
}

.event-time {
  font-size: 12px;
  color: var(--grayl);
  display: flex;
  align-items: center;
  gap: 5px;
}

.event-content {
  margin-bottom: 10px;
}

.event-patient {
  font-weight: bold;
  color: var(--white);
  display: flex;
  align-items: center;
  gap: 5px;
}

.event-type {
  font-size: 12px;
  color: var(--blu);
  margin-top: 2px;
}

.event-notes {
  font-size: 11px;
  color: var(--white);
  margin-top: 2px;
}

.event-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.day-citas-list {
  background: var(--blud);
  border-radius: 10px;
  border: 1px solid var(--blub);
  padding: 20px;
}

.citas-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.cita-card {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  border: 1px solid var(--blub);
  border-radius: 10px;
  padding: 15px;
  transition: all 0.3s ease;
}

.cita-card:hover {

  transform: translateY(-2px);
}

.cita-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.cita-card-body {
  margin-bottom: 15px;
}

.cita-card-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.no-citas {
  text-align: center;
  padding: 40px;
  color: var(--grayl);
}

.no-citas-icon {
  font-size: 48px;
  margin-bottom: 15px;
}

/* Configuration Styles */
.configuracion-container {
  display: flex;
  gap: 30px;
  margin-bottom: 30px;
}

.config-tabs {
  width: 250px;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.config-tab {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px 20px;
  background: transparent;
  border: none;
  color: var(--grayl);
  text-align: left;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.3s ease;
}

.config-tab:hover {
  background: rgba(255, 255, 255, 0.05);
  color: var(--white);
}

.config-tab.active {
  background: rgba(31, 133, 186, 0.2);
  color: var(--blu);
  border: 3px solid var(--blu);
}

.config-tab svg {
  font-size: 20px;
}

.config-content {
  flex: 1;
  background: var(--blud);
  border: 1px solid var(--blub);
  border-radius: 10px;
  padding: 30px;
}

.tab-content h3 {
  color: var(--grnb);
  margin-bottom: 25px;
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 30px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: var(--white);
  font-weight: 500;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 15px;
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid var(--blub);
}

.security-info {
  margin-top: 30px;
  padding: 20px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  border-left: 4px solid var(--blu);
}

.security-info h4 {
  color: var(--blu);
  margin-bottom: 10px;
}

.security-info ul {
  padding-left: 20px;
  color: var(--grayl);
}

.security-info li {
  margin-bottom: 5px;
}

.notifications-list {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.notification-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  border: 1px solid var(--blub);
}

.notification-item h4 {
  color: var(--white);
  margin-bottom: 5px;
}

.notification-item p {
  color: var(--grayl);
  font-size: 14px;
}

.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--blub);
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: var(--white);
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: var(--blu);
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.horario-disponibilidad {
  margin: 30px 0;
  padding: 20px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
}

.dias-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.dia-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.advanced-settings {
  background: var(--blud);
  border: 1px solid var(--blub);
  border-radius: 10px;
  padding: 30px;
  margin-top: 30px;
}

.advanced-actions {
  display: flex;
  gap: 15px;
  margin-top: 20px;
}

.alert-message {
  padding: 15px 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  border-left: 4px solid;
}

.alert-message.success {
  background: rgba(31, 186, 101, 0.2);
  border-color: var(--grnb);
  color: var(--grnb);
}

.alert-message.error {
  background: rgba(250, 49, 68, 0.2);
  border-color: var(--rr);
  color: var(--rr);
}

/* Responsive */
@media (max-width: 1024px) {
  .form-grid {
    grid-template-columns: 1fr;
  }
  
  .configuracion-container {
    flex-direction: column;
  }
  
  .config-tabs {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
  }
}

@media (max-width: 768px) {
  .stats-grid,
  .dashboard-content-grid {
    grid-template-columns: 1fr;
  }
  
  .calendar-controls {
    flex-direction: column;
    gap: 15px;
    align-items: flex-start;
  }
  
  .date-navigation {
    width: 100%;
    justify-content: space-between;
  }
  
  .citas-cards {
    grid-template-columns: 1fr;
  }
}

/* Clases de utilidad adicionales */
.gap-5 { gap: 5px; }
.gap-10 { gap: 10px; }
.gap-20 { gap: 20px; }
.align-center { align-items: center; }
.font-bold { font-weight: bold; }
.text-small { font-size: 12px; }
.text-danger { color: var(--rr); }
.text-success { color: var(--grnb); }

/* Estilos para el modal de nueva cita */
.modal-overlay-nueva-cita {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.3s ease;
}

.modal-container-nueva-cita {
  background: var(--blub);
  border-radius: 10px;
  padding: 25px;
  width: 500px;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  animation: slideUp 0.3s ease;
  border: 2px solid var(--blu);
}

.modal-title-nueva-cita {
  color: var(--blu);
  margin-bottom: 20px;
  font-size: 24px;
  border-bottom: 2px solid var(--blu);
  padding-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.form-input-nueva-cita {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 1px solid var(--grayl);
  border-radius: 5px;
  background: var(--blud);
  color: var(--white);
  font-size: 16px;
  transition: all 0.3s ease;
}

.form-input-nueva-cita:focus {
  outline: none;
  border-color: var(--blu);

}

.form-select-nueva-cita {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 1px solid var(--grayl);
  border-radius: 5px;
  background: var(--blud);
  color: var(--white);
  font-size: 16px;
  cursor: pointer;
}

.form-select-nueva-cita:focus {
  outline: none;
  border-color: var(--blu);
}

.form-textarea-nueva-cita {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 1px solid var(--grayl);
  border-radius: 5px;
  background: var(--blud);
  color: var(--white);
  font-size: 16px;
  min-height: 100px;
  resize: vertical;
}

.modal-buttons-container-nueva-cita {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 20px;
}

.modal-button-nueva-cita {
  padding: 12px 24px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.button-success-nueva-cita {
  background: var(--grnb);
  color: var(--white);
}

.button-success-nueva-cita:hover {
  transform: translateY(-2px);
}

.button-danger-nueva-cita {
  background: var(--rr);
  color: var(--white);
}

.button-danger-nueva-cita:hover {
  background: var(--rl);
  transform: translateY(-2px);
}

.error-message-nueva-cita {
  background: var(--rl);
  color: var(--white);
  padding: 12px;
  border-radius: 5px;
  margin-bottom: 15px;
  animation: shake 0.5s ease;
}

.info-box-nueva-cita {
  background: var(--blul);
  padding: 15px;
  border-radius: 5px;
  margin-bottom: 15px;
  color: var(--blu);
  border-left: 4px solid var(--blu);
}

/* Animaciones */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

/* Media queries para responsive */
@media (max-width: 768px) {
  .modal-container-nueva-cita {
    width: 95%;
    padding: 15px;
  }
  
  .modal-buttons-container-nueva-cita {
    flex-direction: column;
  }
  
  .modal-button-nueva-cita {
    width: 100%;
    justify-content: center;
  }
}


/* ===== ESTILOS PARA NUEVAS P√ÅGINAS ===== */

/* Notificaciones */
.unread {
  background: rgba(64, 148, 232, 0.1);
  border-left-color: var(--blu) !important;
}

.notification-icon {
  font-size: 24px;
  min-width: 40px;
}

.notification-content {
  flex: 1;
}

.notification-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 5px;
}

.notification-time {
  font-size: 12px;
  color: var(--grayl);
  display: flex;
  align-items: center;
  gap: 5px;
}

.notification-type {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.notification-type-icon {
  font-size: 28px;
}

.notification-type-info {
  flex: 1;
}

.notification-type-info strong {
  display: block;
  margin-bottom: 5px;
}

.notification-type-info p {
  font-size: 13px;
  color: var(--grayl);
  margin: 0;
}

/* Observaciones y Sesiones */
.observaciones-list,
.sesiones-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Expedientes */
.diagnostico-tag {
  background: rgba(31, 133, 186, 0.1);
  color: var(--blu);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  border: 1px solid rgba(31, 133, 186, 0.3);
}

/* Supervisi√≥n */
.flex-1 {
  flex: 1;
}

/* Layouts espec√≠ficos por rol */
.user-rol {
  font-size: 12px;
  background: rgba(255, 255, 255, 0.1);
  padding: 2px 8px;
  border-radius: 10px;
  margin-left: 5px;
}

.user-especialidad {
  font-size: 12px;
  color: var(--whiteSET);
  margin-left: 5px;
}

.sidebar-info {
  padding: 20px;
  border-top: 1px solid var(--blub);
  margin-top: auto;
}

.sidebar-info-item {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
  color: var(--grayl);
  margin-bottom: 10px;
}

.badge-notificacion {
  position: absolute;
  top: -5px;
  right: -5px;
  background: var(--rr);
  color: var(--white);
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
  min-width: 18px;
  text-align: center;
}

/* Grids responsivos */
.grid-4 {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

/* Detalles en modales */
.detail-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.detail-row strong {
  color: var(--blu);
}

.detail-row.notes {
  flex-direction: column;
  align-items: flex-start;
}

.detail-row.notes p {
  margin-top: 5px;
  color: var(--grayl);
}

/* Ajustes responsive */
@media (max-width: 1200px) {
  .grid-4 {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .grid-4 {
    grid-template-columns: 1fr;
  }
  
  .notification-item {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .notification-icon {
    margin-bottom: 10px;
  }
}

/* Animaciones adicionales */
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.pulse {
  animation: pulse 2s infinite;
}

/* Estados de usuario */
.estado-activo {
  color: var(--grnb);
}

.estado-inactivo {
  color: var(--rr);
}

/* Barra de progreso en cards */
.card-progress {
  margin-top: 15px;
}

.card-progress-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
  font-size: 12px;
  color: var(--grayl);
}

/* Filtros mejorados */
.filters-container {
  display: flex;
  gap: 20px;
  align-items: center;
}

.search-box {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.search-box svg {
  position: absolute;
  left: 15px;
  color: var(--grayl);
}

.search-input {
  padding-left: 45px;
}

.filter-buttons {
  display: flex;
  gap: 10px;
}

/* Ajustes para tablas */
.data-table th,
.data-table td {
  vertical-align: middle;
}

/* Mejoras en accordions */
.accordion-header {
  align-items: center;
}

.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.accordion.active .accordion-content {
  max-height: 1000px;
}

/* Timeline mejorado */
.timeline-item:last-child {
  margin-bottom: 0;
}

.timeline-content strong {
  color: var(--blu);
  display: block;
  margin-bottom: 5px;
}

/* Utilidades adicionales */
.ml-10 { margin-left: 10px; }
.mr-10 { margin-right: 10px; }
.mt-30 { margin-top: 30px; }

.justify-between { justify-content: space-between; }
.justify-end { justify-content: flex-end; }
.flex-wrap { flex-wrap: wrap; }

.text-primary { color: var(--blu); }
.text-warning { color: var(--yy); }
.text-info { color: var(--grnb); }

/* Botones en tablas */
.btn-table {
  padding: 4px 8px;
  font-size: 12px;
  min-width: auto;
}

/* Estado de carga global */
.global-loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: var(--blud);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.global-loader-content {
  text-align: center;
}

.global-loader-spinner {
  width: 60px;
  height: 60px;
  border: 5px solid rgba(255, 255, 255, 0.1);
  border-top: 5px solid var(--blu);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

.global-loader-text {
  font-size: 18px;
  color: var(--blu);
  font-weight: bold;
}



/* Estilos para el toggle switch */
.toggle-container {
  display: flex;
  align-items: center;
}

.toggle-checkbox {
  display: none;
}

.toggle-label {
  position: relative;
  display: flex;
  align-items: center;
  width: 60px;
  height: 30px;
  background: var(--white);
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;

}

[data-theme="light"] .toggle-label {
  background: var(--white);

}

.toggle-ball {
  position: absolute;
  left: 3px;
  width: 24px;
  height: 24px;
  background: var(--blud);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  z-index: 2;

  color: var(--yy);
}

.toggle-checkbox:checked + .toggle-label .toggle-ball {
  left: calc(100% - 27px);
  color: var(--blu);
}

.toggle-icons {
  display: flex;
  justify-content: space-between;
  width: 100%;
  padding: 0 8px;
  z-index: 1;
}

.sun-icon {
  color: var(--yy);
  opacity: 0.7;
  transition: opacity 0.3s ease;
}

.moon-icon {
  color: var(--blu);
  opacity: 0.7;
  transition: opacity 0.3s ease;
}

.toggle-checkbox:not(:checked) + .toggle-label .sun-icon {
  opacity: 1;
}

.toggle-checkbox:checked + .toggle-label .moon-icon {
  opacity: 1;
}




/* Efecto activo */
.toggle-label:active {
  transform: scale(0.95);
}

/* Animaci√≥n suave para el cambio de tema */
.main-container,
.sidebar,
.main-content,
.card,
.input-field,
.data-table,
.btn-primary,
.btn-secondary {
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}



/frontend\src\index.js:
--------------------------------------------------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './global.css';
import './App.css';

// Importa los estilos de los modales
import './components/Common/ConfirmModal.css';
import './components/Common/NotificationModal.css';

import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

/frontend\src\components\Auth\Login.css:
--------------------------------------------------------------------------------

.login-page {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

.background-video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: -1;
  pointer-events: none;
  user-select: none;
}

.background-video::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg, 
    rgba(28, 31, 36, 0.8) 0%, 
    rgba(28, 31, 36, 0.6) 100%
  );
}

.login-container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  z-index: 1;
}

.login-card {
  background: linear-gradient(180deg, 
    var(--blud) 0%, 
    var(--blub) 100%);
  border: 2px solid var(--blu);
  border-radius: 15px;
  padding: 40px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
}

.login-header {
  text-align: center;
  margin-bottom: 30px;
}

.logo-container {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 20px;
}

.login-logo {
  max-width: 250px;
  height: auto;
  object-fit: contain;
}

.login-subtitle {
  color: var(--blu);
  font-size: 1.1em;
  margin-top: 10px;
  font-weight: 300;
  letter-spacing: 1px;
}

.form-group {
  margin-bottom: 20px;
}

.input-field {
  width: 100%;
  padding: 12px 15px;
  background: var(--blub);
  border: 1px solid var(--blud);
  border-radius: 8px;
  color: var(--white);
  font-size: 1em;
  transition: all 0.3s ease;
}

.input-field:focus {
  outline: none;
  border-color: var(--blu);
}

.input-field::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.w-100 {
  width: 100%;
}

.btn-primary-login {
  background: var(--blu);
  color: var(--white);
  border: none;
  padding: 14px;
  border-radius: 8px;
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 10px;
}

.btn-primary-login:hover:not(:disabled) {
  transform: translateY(-2px);
  color: var(--blu);
  background: var(--white);
}

.btn-primary-login:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.error-message {
  background: rgba(231, 76, 60, 0.1);
  border: 1px solid rgba(231, 76, 60, 0.3);
  color: #ff6b6b;
  padding: 12px;
  border-radius: 8px;
  margin: 15px 0;
  text-align: center;
  font-size: 0.9em;
}

.login-footer {
  margin-top: 30px;
  text-align: center;
}


.app-info {
  margin-top: 30px;
  text-align: center;
  color: var(--white);
  font-size: 0.8em;
  border-top: 1px solid var(--blu);
  padding-top: 20px;
}

.app-info p {
  margin: 5px 0;
  opacity: 0.7;
}

/* Responsive */
@media (max-width: 480px) {
  .login-card {
    padding: 30px 20px;
    margin: 20px;
  }
  
  .login-logo {
    max-width: 200px;
  }
  
  .instructions {
    flex-direction: column;
    gap: 10px;
  }
}

/* Deshabilitar el √≠cono nativo del navegador */
input[type="password"]::-webkit-textfield-decoration-container,
input[type="password"]::-webkit-contacts-auto-fill-button,
input[type="password"]::-webkit-credentials-auto-fill-button {
  display: none !important;
  visibility: hidden !important;
  pointer-events: none !important;
  position: absolute !important;
  right: 0 !important;
}

/* Para Firefox */
input[type="password"]::-moz-textfield-decoration-container {
  display: none !important;
}

/* Para Microsoft Edge y otros navegadores */
input[type="password"]::-ms-reveal,
input[type="password"]::-ms-clear {
  display: none !important;
}

/* Asegurar que nuestro √≠cono est√© encima */
.password-toggle {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10; /* Asegurar que est√© por encima */
}

.password-toggle svg {
  color: var(--white); /* Color azul */
  width: 22px;
  height: 22px;
  transition: all 0.3s ease;
  filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
}

.password-toggle:hover svg {
  color: var(--blu); /* Blanco al hacer hover */
  transform: scale(1.1);
}

/* Asegurar espacio suficiente para el √≠cono */
#password-field {
  padding-right: 45px !important;
  /* Forzar que no muestre el √≠cono nativo */
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

/* Estilos espec√≠ficos para el input de contrase√±a */
.password-input-container {
  position: relative;
  width: 100%;
}

.password-input-container input {
  width: 100%;
  /* Eliminar cualquier estilo nativo */
  &::-webkit-inner-spin-button,
  &::-webkit-outer-spin-button,
  &::-webkit-search-cancel-button,
  &::-webkit-clear-button {
    display: none;
    -webkit-appearance: none;
  }
}

/frontend\src\components\Auth\Login.js:
--------------------------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import './Login.css';

const Login = () => {
  const [credentials, setCredentials] = useState({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    if (!credentials.email || !credentials.password) {
      setError('Por favor ingrese email y contrase√±a');
      setLoading(false);
      return;
    }

    const result = await login(credentials.email, credentials.password);
    
    console.log('Resultado del login:', result);

    if (result.success) {
      navigate('/dashboard');
    } else {
      setError(result.message);
    }
    
    setLoading(false);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleSubmit(e);
    }
  };

  return (
    <div className="login-page">
      {/* Video de fondo */}
      <video 
        autoPlay 
        loop 
        muted 
        className="background-video"
        onContextMenu={(e) => e.preventDefault()}
      >
        <source src="/images/banner.mp4" type="video/mp4" />
        Tu navegador no soporta videos HTML5.
      </video>

      {/* Contenedor del login */}
      <div className="login-container">
        <div className="login-card">
          <div className="login-header">
            {/* Logo en lugar del texto */}
            <div className="logo-container">
              <img 
                src="/images/logoCESUN2.png" 
                alt="PsicoGesti√≥n" 
                className="login-logo"
              />
            </div>
            <p className="login-subtitle">Consultorio Psicol√≥gico</p>
          </div>

          <form onSubmit={handleSubmit}>
            <div className="form-group">
              <input
                type="email"
                className="input-field"
                placeholder="Correo electr√≥nico"
                value={credentials.email}
                onChange={(e) => setCredentials({...credentials, email: e.target.value})}
                onKeyDown={handleKeyDown}
                autoFocus
              />
            </div>

            <div className="form-group">
              <div className="password-input-container">
                <input
                  type="password"
                  className="input-field"
                  placeholder="Contrase√±a"
                  value={credentials.password}
                  onChange={(e) => setCredentials({...credentials, password: e.target.value})}
                  onKeyDown={handleKeyDown}
                  id="password-field"
                  // A√±ade este atributo para deshabilitar el √≠cono nativo
                  autoComplete="current-password"
                />
                <button 
                  type="button" 
                  className="password-toggle"
                  onClick={() => {
                    const input = document.getElementById('password-field');
                    const icon = document.querySelector('.password-toggle svg');
                    
                    if (input.type === 'password') {
                      input.type = 'text';
                      // Cambiar al √≠cono de ojo tachado cuando se muestra la contrase√±a
                      icon.innerHTML = '<path d="M12 6.5c2.76 0 5 2.24 5 5 0 .51-.1 1-.24 1.46l3.06 3.06c1.39-1.23 2.49-2.77 3.18-4.53C21.27 7.11 17 4 12 4c-1.27 0-2.49.2-3.64.57l2.17 2.17c.47-.14.96-.24 1.47-.24zM2.71 3.16c-.39.39-.39 1.02 0 1.41l1.97 1.97C3.06 7.83 1.77 9.53 1 11.5 2.73 15.89 7 19 12 19c1.52 0 2.97-.3 4.31-.82l2.72 2.72c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L4.13 3.16c-.39-.39-1.02-.39-1.42 0zM12 16.5c-2.76 0-5-2.24-5-5 0-.77.18-1.5.49-2.14l1.57 1.57c-.03.18-.06.37-.06.57 0 1.66 1.34 3 3 3 .2 0 .38-.03.57-.07L14.14 16c-.64.32-1.37.5-2.14.5zm2.97-5.33c-.15-1.4-1.25-2.49-2.64-2.64l2.64 2.64z"/>';
                    } else {
                      input.type = 'password';
                      // Cambiar al √≠cono de ojo normal cuando se oculta la contrase√±a
                      icon.innerHTML = '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>';
                    }
                  }}
                >
                  <svg 
                    width="20" 
                    height="20" 
                    viewBox="0 0 24 24" 
                    fill="currentColor"
                  >
                    <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                  </svg>
                </button>
              </div>
            </div>

            {error && (
              <div className="error-message">
                {error}
              </div>
            )}

            <button
              type="submit"
              className="btn-primary-login w-100"
              disabled={loading}
            >
              {loading ? 'Iniciando sesi√≥n...' : 'Iniciar Sesi√≥n'}
            </button>

            <div className="login-footer">

            </div>
          </form>

          <div className="app-info">
            <p>Versi√≥n 1.0.0</p>
            <p>Sistema de Gesti√≥n de Consultorio Psicol√≥gico</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Login;

/frontend\src\components\Auth\PrivateRoute.js:
--------------------------------------------------------------------------------
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const PrivateRoute = ({ children }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <div className="global-loader">
        <div className="global-loader-content">
          <div className="global-loader-spinner"></div>
          <div className="global-loader-text">Cargando...</div>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  return children;
};

export default PrivateRoute;

/frontend\src\components\Auth\ProtectedRoute.js:
--------------------------------------------------------------------------------
// src/components/Auth/ProtectedRoute.js
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const ProtectedRoute = ({ children, allowedRoles }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <div className="global-loader">
        <div className="global-loader-content">
          <div className="global-loader-spinner"></div>
          <div className="global-loader-text">Cargando...</div>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  // Verificar si el usuario tiene un rol permitido
  if (!allowedRoles.includes(user.rol)) {
    // Redirigir al dashboard correspondiente seg√∫n el rol
    switch (user.rol) {
      case 'becario':
        return <Navigate to="/becario/dashboard" replace />;
      case 'psicologo':
        return <Navigate to="/psicologo/dashboard" replace />;
      case 'coordinador':
        return <Navigate to="/coordinador/dashboard" replace />;
      default:
        return <Navigate to="/login" />;
    }
  }

  return children;
};

export default ProtectedRoute;

/frontend\src\components\Auth\RoleRouter.js:
--------------------------------------------------------------------------------
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import BecarioLayout from '../Layout/BecarioLayout';
import PsicologoLayout from '../Layout/PsicologoLayout';
import CoordinadorLayout from '../Layout/CoordinadorLayout';

const RoleRouter = ({ children }) => {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="global-loader">
        <div className="global-loader-content">
          <div className="global-loader-spinner"></div>
          <div className="global-loader-text">Verificando rol...</div>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  // Verificar si la ruta actual corresponde al rol del usuario
  const path = location.pathname;
  
  if (user.rol === 'becario' && !path.startsWith('/becario')) {
    return <Navigate to="/becario/dashboard" replace />;
  }
  
  if (user.rol === 'psicologo' && !path.startsWith('/psicologo')) {
    return <Navigate to="/psicologo/dashboard" replace />;
  }
  
  if (user.rol === 'coordinador' && !path.startsWith('/coordinador')) {
    return <Navigate to="/coordinador/dashboard" replace />;
  }

  // Determinar layout basado en el rol del usuario
  switch (user.rol) {
    case 'becario':
      return <BecarioLayout>{children}</BecarioLayout>;
    case 'psicologo':
      return <PsicologoLayout>{children}</PsicologoLayout>;
    case 'coordinador':
      return <CoordinadorLayout>{children}</CoordinadorLayout>;
    default:
      return <Navigate to="/login" />;
  }
};

export default RoleRouter;

/frontend\src\components\Common\ConfirmModal.css:
--------------------------------------------------------------------------------
.confirm-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: fadeIn 0.3s ease;
}

.modal-confirm {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  padding: 30px;
  border-radius: 10px;
  text-align: center;
  transition: all 0.3s ease;
  max-width: 400px;
  width: 90%;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
}

/* Tipos de confirmaci√≥n - solo borde */
.modal-confirm-info {
  border: 2px solid var(--blu);
}

.modal-confirm-warning {
  border: 2px solid var(--yy);
}

.modal-confirm-danger {
  border: 2px solid var(--rr);
}

.confirm-message {
  color: var(--white);
  font-size: 1.1em;
  line-height: 1.5;
  margin-bottom: 25px;
  padding: 0 10px;
}

.confirm-buttons-container {
  display: flex;
  gap: 15px;
  justify-content: center;
}

/* Estilos base de los botones */
.confirm-button-cancel,
.confirm-button-confirm {
  border: none;
  padding: 10px 25px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  font-size: 1em;
  transition: all 0.3s ease;
  min-width: 100px;
}

/* Bot√≥n de confirmar por tipo */
.confirm-button-info {
  background: var(--blu);
  color: var(--white);
}

.confirm-button-warning {
  background: var(--yy);
  color: var(--white);
}

.confirm-button-danger {
  background: var(--rr);
  color: var(--white);
}

/* Bot√≥n de cancelar por tipo */
.confirm-button-info-cancel {
  background: var(--blud);
  color: var(--white);
  border: 1px solid var(--blu);
}

.confirm-button-warning-cancel {
  background: var(--blud);
  color: var(--white);
  border: 1px solid var(--yy);
}

.confirm-button-danger-cancel {
  background: var(--blud);
  color: var(--white);
  border: 1px solid var(--rr);
}

/* Hover effects */
.confirm-button-info:hover {
  transform: translateY(-2px);
}

.confirm-button-warning:hover {
  transform: translateY(-2px);
}

.confirm-button-danger:hover {
  transform: translateY(-2px);
}

.confirm-button-info-cancel:hover {
  background: var(--blu);
  transform: translateY(-2px);
}

.confirm-button-warning-cancel:hover {
  background: var(--yy);
  transform: translateY(-2px);
}

.confirm-button-danger-cancel:hover {
  background: var(--rr);
  transform: translateY(-2px);
}

.confirm-button-cancel:active,
.confirm-button-confirm:active {
  transform: translateY(0);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.modal-confirm {
  animation: slideUp 0.3s ease;
}

/frontend\src\components\Common\ConfirmModal.jsx:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react'
import './ConfirmModal.css'

let showConfirmFunc = null

const ConfirmModal = () => {
  const [visible, setVisible] = useState(false)
  const [message, setMessage] = useState('')
  const [type, setType] = useState('warning') // 'warning', 'danger', 'info'
  const [callback, setCallback] = useState(null)

  const show = (msg, confirmCallback, msgType = 'warning') => {
    setMessage(msg)
    setType(msgType)
    setCallback(() => confirmCallback)
    setVisible(true)
  }

  const handleConfirm = () => {
    if (callback) callback(true)
    hide()
  }

  const handleCancel = () => {
    if (callback) callback(false)
    hide()
  }

  const hide = () => {
    setVisible(false)
    setMessage('')
    setCallback(null)
  }

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleConfirm()
    } else if (e.key === 'Escape') {
      handleCancel()
    }
  }

  const handleOverlayClick = (e) => {
    if (e.target.classList.contains('confirm-overlay')) {
      handleCancel()
    }
  }

  // Exponer la funci√≥n show al objeto global
  useEffect(() => {
    showConfirmFunc = show
    
    return () => {
      showConfirmFunc = null
    }
  }, [])

  useEffect(() => {
    if (visible) {
      document.addEventListener('keydown', handleKeyDown)
    }
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [visible])

  if (!visible) return null

  const getButtonTexts = () => {
    switch (type) {
      case 'danger': return { confirm: 'S√≠', cancel: 'Cancelar' }
      case 'info': return { confirm: 'S√≠', cancel: 'No' }
      default: return { confirm: 'S√≠', cancel: 'Cancelar' }
    }
  }

  const buttonTexts = getButtonTexts()

  return (
    <div 
      className="confirm-overlay" 
      onClick={handleOverlayClick}
    >
      <div className={`modal-confirm modal-confirm-${type}`}>
        <div className="confirm-message">
          {message}
        </div>
        <div className="confirm-buttons-container">
          <button 
            className={`modal-button confirm-button-cancel confirm-button-${type}-cancel`}
            onClick={handleCancel}
          >
            {buttonTexts.cancel}
          </button>
          <button 
            className={`modal-button confirm-button-confirm confirm-button-${type}`}
            onClick={handleConfirm}
            autoFocus
          >
            {buttonTexts.confirm}
          </button>
        </div>
      </div>
    </div>
  )
}

// Funci√≥n global para mostrar confirmaciones
export const showConfirm = (message, type = 'warning') => {
  return new Promise((resolve) => {
    if (showConfirmFunc) {
      showConfirmFunc(message, resolve, type)
    } else {
      console.error('ConfirmModal no est√° montado')
      // Fallback al confirm nativo si no est√° disponible
      const result = window.confirm(message)
      resolve(result)
    }
  })
}

export default ConfirmModal

/frontend\src\components\Common\NotificationModal.css:
--------------------------------------------------------------------------------
.notification-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: fadeIn 0.3s ease;
}

.modal-notification {
  background: linear-gradient(180deg, var(--blud) 0%, var(--blub) 100%);
  padding: 30px;
  border-radius: 10px;
  text-align: center;
  transition: all 0.3s ease;
  max-width: 400px;
  width: 90%;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
}

/* Tipos de notificaci√≥n - solo borde */
.modal-notification-info {
  border: 2px solid var(--blu);
}

.modal-notification-success {
  border: 2px solid var(--blu);
}

.modal-notification-error {
  border: 2px solid var(--rr);
}

.modal-notification-warning {
  border: 2px solid var(--yy);
}

.notification-message {
  color: var(--white);
  font-size: 1.1em;
  line-height: 1.5;
  margin-bottom: 20px;
  padding: 0 10px;
}

/* Estilos base del bot√≥n */
.notification-close-button {
  border: none;
  padding: 10px 30px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  font-size: 1em;
  transition: all 0.3s ease;
  min-width: 120px;
  color: var(--blub);
}

/* Botones por tipo */
.notification-button-info {
  background: var(--blu);
}

.notification-button-success {
  background: var(--blu);
}

.notification-button-error {
  background: var(--rr);
}

.notification-button-warning {
  background: var(--yy);
}

/* Hover effects */
.notification-button-info:hover {
  background: var(--blub);
  transform: translateY(-2px);
}

.notification-button-success:hover {
  background: var(--bludd);
  transform: translateY(-2px);
}

.notification-button-error:hover {
  background: #e74c3c;
  transform: translateY(-2px);
}

.notification-button-warning:hover {
  background: #f39c12;
  transform: translateY(-2px);
}

.notification-close-button:active {
  transform: translateY(0);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.modal-notification {
  animation: slideUp 0.3s ease;
}

/frontend\src\components\Common\NotificationModal.jsx:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react'
import './NotificationModal.css'

let showNotificationFunc = null

const NotificationModal = () => {
  const [visible, setVisible] = useState(false)
  const [message, setMessage] = useState('')
  const [type, setType] = useState('info') // 'info', 'success', 'error', 'warning'

  const show = (msg, msgType = 'info') => {
    setMessage(msg)
    setType(msgType)
    setVisible(true)
  }

  const hide = () => {
    setVisible(false)
  }

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      hide()
    }
  }

  const handleOverlayClick = (e) => {
    if (e.target.classList.contains('notification-overlay')) {
      hide()
    }
  }

  // Exponer la funci√≥n show al objeto global
  useEffect(() => {
    showNotificationFunc = show
    
    return () => {
      showNotificationFunc = null
    }
  }, [])

  useEffect(() => {
    if (visible) {
      document.addEventListener('keydown', handleKeyDown)
    }
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [visible])

  if (!visible) return null

  return (
    <div 
      className="notification-overlay" 
      onClick={handleOverlayClick}
    >
      <div className={`modal-notification modal-notification-${type}`}>
        <div className="notification-message">
          {message}
        </div>
        <button 
          className={`modal-button notification-close-button notification-button-${type}`}
          onClick={hide}
          autoFocus
        >
          Aceptar
        </button>
      </div>
    </div>
  )
}

// Funci√≥n global para mostrar notificaciones
export const showNotification = (message, type = 'info') => {
  if (showNotificationFunc) {
    showNotificationFunc(message, type)
  } else {
    console.error('NotificationModal no est√° montado')
    // Fallback al alert si no est√° disponible

  }
}

export default NotificationModal

/frontend\src\components\Layout\BecarioLayout.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { Outlet, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { 
  FiMenu, FiChevronLeft, FiHome, FiUsers, FiCalendar, FiBell,FiSun, FiMoon,
  FiFileText, FiLogOut, FiClock
} from 'react-icons/fi';

const BecarioLayout = () => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const { user, logout } = useAuth();
  const [darkMode, setDarkMode] = useState(false);
  const navigate = useNavigate();
  const [notificaciones, setNotificaciones] = useState([]);

  useEffect(() => {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        setDarkMode(true);
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        setDarkMode(false);
        document.documentElement.setAttribute('data-theme', 'light');
      }
    }, []);
  
    const toggleDarkMode = () => {
      const newDarkMode = !darkMode;
      setDarkMode(newDarkMode);
      
      if (newDarkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      }
    };

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const fetchNotificaciones = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('http://localhost:3000/api/notificaciones/mis-notificaciones', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setNotificaciones(data.data || []);
      }
    } catch (error) {
      console.error('Error al obtener notificaciones:', error);
    }
  };

  useEffect(() => {
    fetchNotificaciones();
    // Actualizar cada 30 segundos
    const interval = setInterval(fetchNotificaciones, 30000);
    return () => clearInterval(interval);
  }, []);

  const navItems = [
    { path: '/becario/dashboard', icon: <FiHome />, label: 'Inicio', permiso: 'ver_panel_becario' },
    { path: '/becario/citas', icon: <FiCalendar />, label: 'Mis Citas', permiso: 'gestionar_citas_asignadas' },
    { path: '/becario/pacientes', icon: <FiUsers />, label: 'Mis Pacientes', permiso: 'ver_pacientes_asignados' },
    { path: '/becario/notificaciones', icon: <FiBell />, label: 'Notificaciones', permiso: 'ver_notificaciones' },
    { path: '/becario/observaciones', icon: <FiFileText />, label: 'Observaciones', permiso: 'registrar_observaciones' },
  ];

  return (
    <div className="main-container">
      {/* Top Header */}
      <header className="top-header">
        <div className="flex-row align-center">
          <button 
            className="control-btn"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <FiChevronLeft size={24} /> : <FiMenu size={24} />}
          </button>
          <img 
                src="/images/logoCESUN2wide.png" 
                alt="PsicoGesti√≥n" 
                className="dashboard-logo"
              />
          <h2 className="app-name">- Becario</h2>
        </div>
        
        <div className="flex-row align-center gap-20">
          <div className="notificaciones-dropdown">
            <button className="btn-header">
              <FiBell />
              {notificaciones.filter(n => !n.leida).length > 0 && (
                <span className="badge-notificacion">
                  {notificaciones.filter(n => !n.leida).length}
                </span>
              )}
            </button>
          </div>

          {/* Toggle Switch Dark Mode */}
          <div className="toggle-container">
            <input 
              type="checkbox" 
              id="dark-mode-toggle" 
              className="toggle-checkbox"
              checked={darkMode}
              onChange={toggleDarkMode}
            />
            <label 
              htmlFor="dark-mode-toggle" 
              className="toggle-label"
              title={darkMode ? "Modo oscuro activado" : "Modo claro activado"}
            >
              <div className="toggle-ball">
                {darkMode ? <FiMoon size={14} /> : <FiSun size={14} />}
              </div>
              <div className="toggle-icons">
                <FiSun className="sun-icon" size={14} />
                <FiMoon className="moon-icon" size={14} />
              </div>
            </label>
          </div>
          
          <div className="user-info">
            <span className="user-email">{user?.email}</span>
            <span className="user-rol">Becario</span>
          </div>
          
          <button 
            className="btn-header"
            onClick={handleLogout}
            title="Cerrar sesi√≥n"
          >
            <FiLogOut />
            <span>Salir</span>
          </button>
        </div>
      </header>

      <div className="content-wrapper">
        {/* Sidebar */}
        <aside className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
          <nav className="sidebar-nav">
            {navItems.map((item) => (
              <NavLink
                key={item.path}
                to={item.path}
                className={({ isActive }) => 
                  `sidebar-nav-item ${isActive ? 'active' : ''}`
                }
              >
                {item.icon}
                {sidebarOpen && <span>{item.label}</span>}
              </NavLink>
            ))}
          </nav>
          
          {/* Info del d√≠a */}
          {sidebarOpen && (
            <div className="sidebar-info">
              <div className="sidebar-info-item">
                <FiClock />
                <span>{new Date().toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</span>
              </div>
              <div className="sidebar-info-item">
                <FiUsers />
                <span>Pacientes asignados: Cargando...</span>
              </div>
            </div>
          )}
        </aside>

        {/* Main Content */}
        <main className="main-content">
          <div className="content-area">
            <Outlet />
          </div>
        </main>
      </div>

      {/* Bottom Status Bar */}
      <footer className="status-bar">
        <div className="status-info">
          <span>Sesi√≥n: {user?.email}</span>
          <span>Rol: Becario</span>
          <span>√öltima conexi√≥n: {new Date().toLocaleTimeString()}</span>
        </div>
      </footer>
    </div>
  );
};

export default BecarioLayout;

/frontend\src\components\Layout\CoordinadorLayout.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { Outlet, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { 
  FiMenu, FiChevronLeft, FiHome, FiUsers, FiCalendar, FiBarChart2,
  FiUserPlus, FiFileText, FiSettings, FiLogOut, FiClock,FiSun, FiMoon,
  FiTrendingUp, FiUserCheck
} from 'react-icons/fi';

const CoordinadorLayout = () => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [darkMode, setDarkMode] = useState(false);
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  // Inicializar el tema desde localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      setDarkMode(true);
      document.documentElement.setAttribute('data-theme', 'dark');
    } else {
      setDarkMode(false);
      document.documentElement.setAttribute('data-theme', 'light');
    }
  }, []);

  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    
    if (newDarkMode) {
      document.documentElement.setAttribute('data-theme', 'dark');
      localStorage.setItem('theme', 'dark');
    } else {
      document.documentElement.setAttribute('data-theme', 'light');
      localStorage.setItem('theme', 'light');
    }
  };

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const navItems = [
    { path: '/coordinador/dashboard', icon: <FiHome />, label: 'Panel Coordinaci√≥n', permiso: 'ver_panel_coordinacion' },
    { path: '/coordinador/usuarios', icon: <FiUserPlus />, label: 'Gesti√≥n Usuarios', permiso: 'gestionar_usuarios' },
    { path: '/coordinador/pacientes', icon: <FiUsers />, label: 'Gesti√≥n Pacientes', permiso: 'gestionar_pacientes' },
    { path: '/coordinador/asignaciones', icon: <FiUserCheck />, label: 'Asignaciones', permiso: 'gestionar_asignaciones' },
    { path: '/coordinador/agenda', icon: <FiCalendar />, label: 'Agenda Global', permiso: 'ver_agenda_global' },
    { path: '/coordinador/reportes', icon: <FiBarChart2 />, label: 'Reportes', permiso: 'generar_reportes' },
    { path: '/coordinador/altas', icon: <FiTrendingUp />, label: 'Seguimiento Altas', permiso: 'gestionar_altas' },
    { path: '/coordinador/configuracion', icon: <FiSettings />, label: 'Configuraci√≥n', permiso: 'ver_panel_coordinacion' },
  ];

  return (
    <div className="main-container">
      <header className="top-header">
        <div className="flex-row align-center">
          <button 
            className="control-btn"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <FiChevronLeft size={24} /> : <FiMenu size={24} />}
          </button>
              <img 
                src="/images/logoCESUN2wide.png" 
                alt="PsicoGesti√≥n" 
                className="dashboard-logo"
              />
          <h2 className="app-name">- Coordinaci√≥n</h2>
        </div>

        <div className="flex-row align-center gap-20">
          {/* Toggle Switch Dark Mode */}
          <div className="toggle-container">
            <input 
              type="checkbox" 
              id="dark-mode-toggle" 
              className="toggle-checkbox"
              checked={darkMode}
              onChange={toggleDarkMode}
            />
            <label 
              htmlFor="dark-mode-toggle" 
              className="toggle-label"
              title={darkMode ? "Modo oscuro activado" : "Modo claro activado"}
            >
              <div className="toggle-ball">
                {darkMode ? <FiMoon size={14} /> : <FiSun size={14} />}
              </div>
              <div className="toggle-icons">
                <FiSun className="sun-icon" size={14} />
                <FiMoon className="moon-icon" size={14} />
              </div>
            </label>
          </div>
          
          <div className="user-info">
            <span className="user-email">{user?.email}</span>
            <span className="user-rol">Coordinador</span>
            {user?.especialidad && (
              <span className="user-especialidad">‚Ä¢ {user.especialidad}</span>
            )}
          </div>
          
          <button 
            className="btn-header"
            onClick={handleLogout}
            title="Cerrar sesi√≥n"
          >
            <FiLogOut />
            <span>Salir</span>
          </button>
        </div>
      </header>

      <div className="content-wrapper">
        <aside className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
          <nav className="sidebar-nav">
            {navItems.map((item) => (
              <NavLink
                key={item.path}
                to={item.path}
                className={({ isActive }) => 
                  `sidebar-nav-item ${isActive ? 'active' : ''}`
                }
              >
                {item.icon}
                {sidebarOpen && <span>{item.label}</span>}
              </NavLink>
            ))}
          </nav>
          
          {sidebarOpen && (
            <div className="sidebar-info">
              <div className="sidebar-info-item">
                <FiClock />
                <span>Citas hoy: Cargando...</span>
              </div>
              <div className="sidebar-info-item">
                <FiUsers />
                <span>Becarios activos: Cargando...</span>
              </div>
              <div className="sidebar-info-item">
                <FiBarChart2 />
                <span>Altas este mes: Cargando...</span>
              </div>
            </div>
          )}
        </aside>

        <main className="main-content">
          <div className="content-area">
            <Outlet />
          </div>
        </main>
      </div>

      <footer className="status-bar">
        <div className="status-info">
          <span>Sesi√≥n: {user?.email}</span>
          <span>Rol: Coordinador ‚Ä¢ Sistema completo</span>
          <span>√öltima actualizaci√≥n: {new Date().toLocaleTimeString()}</span>
        </div>
      </footer>
    </div>
  );
};

export default CoordinadorLayout;

/frontend\src\components\Layout\MainLayout.js:
--------------------------------------------------------------------------------
import React, { useState } from 'react';
import { Outlet, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { FiMenu, FiChevronLeft,FiChevronLeft, FiHome, FiUsers, FiCalendar, FiSettings, FiLogOut } from 'react-icons/fi';

const MainLayout = () => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const navItems = [
    { path: '/dashboard', icon: <FiHome />, label: 'Dashboard' },
    { path: '/pacientes', icon: <FiUsers />, label: 'Pacientes' },
    { path: '/citas', icon: <FiCalendar />, label: 'Citas' },
    { path: '/configuracion', icon: <FiSettings />, label: 'Configuraci√≥n' },
  ];

  return (
    <div className="main-container">
      {/* Top Header */}
      <header className="top-header">
        <div className="flex-row align-center">
          <button 
            className="control-btn"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <FiChevronLeft size={24} /> : <FiMenu size={24} />}
          </button>
          <img 
                src="/images/logoCESUN2wide.png" 
                alt="PsicoGesti√≥n" 
                className="dashboard-logo"
              />
        </div>
        
        <div className="flex-row align-center gap-20">
          <div className="user-info">
            <span className="user-email">{user?.email}</span>
          </div>
          <button 
            className="btn-header"
            onClick={handleLogout}
            title="Cerrar sesi√≥n"
          >
            <FiLogOut />
            <span>Salir</span>
          </button>
        </div>
      </header>

      <div className="content-wrapper">
        {/* Sidebar */}
        <aside className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
          <nav className="sidebar-nav">
            {navItems.map((item) => (
              <NavLink
                key={item.path}
                to={item.path}
                className={({ isActive }) => 
                  `sidebar-nav-item ${isActive ? 'active' : ''}`
                }
              >
                {item.icon}
                {sidebarOpen && <span>{item.label}</span>}
              </NavLink>
            ))}
          </nav>
        </aside>

        {/* Main Content */}
        <main className="main-content">
          <div className="content-area">
            <Outlet />
          </div>
        </main>
      </div>

      {/* Bottom Status Bar */}
      <footer className="status-bar">
        <div className="status-info">
          <span>Sesi√≥n activa: {user?.email}</span>
          <span>√öltima conexi√≥n: {new Date().toLocaleTimeString()}</span>
        </div>
      </footer>
    </div>
  );
};

export default MainLayout;

/frontend\src\components\Layout\PsicologoLayout.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { Outlet, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { 
  FiMenu, FiChevronLeft, FiHome, FiUsers, FiCalendar, FiFileText,
  FiBarChart2, FiUserCheck, FiLogOut, FiClock, FiSun, FiMoon
} from 'react-icons/fi';

const PsicologoLayout = () => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [darkMode, setDarkMode] = useState(false);
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  // Inicializar el tema desde localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      setDarkMode(true);
      document.documentElement.setAttribute('data-theme', 'dark');
    } else {
      setDarkMode(false);
      document.documentElement.setAttribute('data-theme', 'light');
    }
  }, []);

  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    
    if (newDarkMode) {
      document.documentElement.setAttribute('data-theme', 'dark');
      localStorage.setItem('theme', 'dark');
    } else {
      document.documentElement.setAttribute('data-theme', 'light');
      localStorage.setItem('theme', 'light');
    }
  };

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const navItems = [
    { path: '/psicologo/dashboard', icon: <FiHome />, label: 'Panel Principal', permiso: 'ver_panel_psicologo' },
    { path: '/psicologo/pacientes', icon: <FiUsers />, label: 'Mis Pacientes', permiso: 'ver_mis_pacientes' },
    { path: '/psicologo/citas', icon: <FiCalendar />, label: 'Mis Citas', permiso: 'gestionar_mis_citas' },
    { path: '/psicologo/expedientes', icon: <FiFileText />, label: 'Expedientes', permiso: 'ver_expedientes' },
    { path: '/psicologo/sesiones', icon: <FiBarChart2 />, label: 'Registro Sesiones', permiso: 'registrar_sesiones' },
    { path: '/psicologo/supervision', icon: <FiUserCheck />, label: 'Supervisi√≥n', permiso: 'supervisar_becarios' },
  ];

  return (
    <div className="main-container">
      <header className="top-header">
        <div className="flex-row align-center">
          <button 
            className="control-btn"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <FiChevronLeft size={24} /> : <FiMenu size={24} />}
          </button>
          <img 
            src="/images/logoCESUN2wide.png" 
            alt="PsicoGesti√≥n" 
            className="dashboard-logo"
          />
          <h2 className="app-name">- Psic√≥logo</h2>
        </div>
        
        <div className="flex-row align-center gap-20">
          {/* Toggle Switch Dark Mode */}
          <div className="toggle-container">
            <input 
              type="checkbox" 
              id="dark-mode-toggle" 
              className="toggle-checkbox"
              checked={darkMode}
              onChange={toggleDarkMode}
            />
            <label 
              htmlFor="dark-mode-toggle" 
              className="toggle-label"
              title={darkMode ? "Modo oscuro activado" : "Modo claro activado"}
            >
              <div className="toggle-ball">
                {darkMode ? <FiMoon size={14} /> : <FiSun size={14} />}
              </div>
              <div className="toggle-icons">
                <FiSun className="sun-icon" size={14} />
                <FiMoon className="moon-icon" size={14} />
              </div>
            </label>
          </div>
          
          <div className="user-info">
            <span className="user-email">{user?.email}</span>
            <span className="user-rol">Psic√≥logo</span>
            {user?.especialidad && (
              <span className="user-especialidad">‚Ä¢ {user.especialidad}</span>
            )}
          </div>
          
          <button 
            className="btn-header"
            onClick={handleLogout}
            title="Cerrar sesi√≥n"
          >
            <FiLogOut />
            <span>Salir</span>
          </button>
        </div>
      </header>

      <div className="content-wrapper">
        <aside className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
          <nav className="sidebar-nav">
            {navItems.map((item) => (
              <NavLink
                key={item.path}
                to={item.path}
                className={({ isActive }) => 
                  `sidebar-nav-item ${isActive ? 'active' : ''}`
                }
              >
                {item.icon}
                {sidebarOpen && <span>{item.label}</span>}
              </NavLink>
            ))}
          </nav>
          
          {sidebarOpen && (
            <div className="sidebar-info">
              <div className="sidebar-info-item">
                <FiClock />
                <span>Citas hoy: Cargando...</span>
              </div>
              <div className="sidebar-info-item">
                <FiUsers />
                <span>Pacientes activos: Cargando...</span>
              </div>
            </div>
          )}
        </aside>

        <main className="main-content">
          <div className="content-area">
            <Outlet />
          </div>
        </main>
      </div>

      <footer className="status-bar">
        <div className="status-info">
          <span>Sesi√≥n: {user?.email}</span>
          <span>Rol: Psic√≥logo ‚Ä¢ Especialidad: {user?.especialidad || 'No especificada'}</span>
          <span>√öltima actualizaci√≥n: {new Date().toLocaleTimeString()}</span>
        </div>
      </footer>
    </div>
  );
};

export default PsicologoLayout;

/frontend\src\context\AuthContext.js:
--------------------------------------------------------------------------------
// frontend/src/context/AuthContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';
import ApiService from '../services/api';

const AuthContext = createContext({});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(localStorage.getItem('token'));

  useEffect(() => {
    if (token) {
      fetchUserData();
    } else {
      setLoading(false);
    }
  }, [token]);

  const fetchUserData = async () => {
    try {
      const response = await ApiService.getCurrentUser();
      setUser(response.user);
      
      // Guardar tambi√©n en localStorage para acceso r√°pido
      localStorage.setItem('psico_user', JSON.stringify(response.user));
    } catch (error) {
      console.error('Error fetching user data:', error);
      
      // Si el error es 401 (token inv√°lido/vencido), hacer logout
      if (error.status === 401) {
        logout();
      }
      
      // Intentar recuperar usuario de localStorage como fallback
      const storedUser = localStorage.getItem('psico_user');
      if (storedUser) {
        setUser(JSON.parse(storedUser));
      }
    } finally {
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    try {
      const response = await ApiService.post('/auth/login', { email, password });
      
      const { token, user } = response;
      
      localStorage.setItem('token', token);
      localStorage.setItem('psico_user', JSON.stringify(user));
      
      setToken(token);
      setUser(user);
      
      // Redirigir seg√∫n el rol despu√©s del login exitoso
      setTimeout(() => {
        if (user.rol) {
          window.location.href = `/${user.rol}/dashboard`;
        } else {
          window.location.href = '/dashboard';
        }
      }, 100);
      
      return { success: true };
    } catch (error) {
      console.error('Login error:', error);
      return { 
        success: false, 
        message: error.message || 'Error en el inicio de sesi√≥n' 
      };
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('psico_user');
    setToken(null);
    setUser(null);
    window.location.href = '/login';
  };

  const updateUser = (updatedUser) => {
    setUser(updatedUser);
    localStorage.setItem('psico_user', JSON.stringify(updatedUser));
  };

  const value = {
    user,
    token,
    login,
    logout,
    updateUser,
    loading,
    isCoordinador: user?.rol === 'coordinador',
    isPsicologo: user?.rol === 'psicologo',
    isBecario: user?.rol === 'becario'
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

/frontend\src\pages\becario\CitasPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiCalendar, FiClock, FiUser, FiPlus, 
  FiChevronLeft, FiChevronRight, FiFilter,
  FiCheckCircle, FiXCircle, FiEdit2
} from 'react-icons/fi';
import { format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const BecarioCitas = () => {
  const [citas, setCitas] = useState([]);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [loading, setLoading] = useState(true);
  const [view, setView] = useState('day');
  const [showNuevaCitaModal, setShowNuevaCitaModal] = useState(false);
  const [filterEstado, setFilterEstado] = useState('');

  useEffect(() => {
    fetchCitas();
  }, [selectedDate, filterEstado]);

  const fetchCitas = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const fecha = format(selectedDate, 'yyyy-MM-dd');
      
      let url = `http://localhost:3000/api/citas/citas-por-fecha?fecha=${fecha}`;
      
      const response = await fetch(url, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // Filtrar por estado si se especifica
        let citasFiltradas = data.data || [];
        if (filterEstado) {
          citasFiltradas = citasFiltradas.filter(cita => cita.estado === filterEstado);
        }
        
        setCitas(citasFiltradas);
      }
    } catch (error) {
      console.error('Error al obtener citas:', error);
    } finally {
      setLoading(false);
    }
  };

  const goToPreviousDay = () => {
    setSelectedDate(prev => subDays(prev, 1));
  };

  const goToNextDay = () => {
    setSelectedDate(prev => addDays(prev, 1));
  };

  const goToToday = () => {
    setSelectedDate(new Date());
  };

  const handleEstadoCita = async (citaId, nuevoEstado) => {
    try {
      const token = localStorage.getItem('token');
      
      const response = await fetch(`http://localhost:3000/api/citas/cita/${citaId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ estado: nuevoEstado })
      });
      
      if (response.ok) {
        fetchCitas();
        notifications.success(`Cita ${nuevoEstado === 'completada' ? 'completada' : 'cancelada'} exitosamente`);
      }
    } catch (error) {
      console.error('Error al actualizar cita:', error);
      notifications.error('Error al actualizar la cita');
    }
  };

  const formatDateSpanish = (date) => {
    return format(date, "EEEE d 'de' MMMM, yyyy", { locale: es });
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando citas...</div>
      </div>
    );
  }

  return (
    <div className="citas-page">
      <div className="page-header">
        <div>
          <h1>Mis Citas</h1>
          <p>Gesti√≥n de citas asignadas</p>
        </div>
        <div className="flex-row gap-10">
          <button 
            className="btn-primary"
            onClick={() => setShowNuevaCitaModal(true)}
          >
            <FiPlus /> Nueva Cita
          </button>
        </div>
      </div>

      <div className="calendar-controls">
        <div className="view-selector">
          <button 
            className={`btn-text ${view === 'day' ? 'active' : ''}`}
            onClick={() => setView('day')}
          >
            D√≠a
          </button>
          <button 
            className={`btn-text ${view === 'week' ? 'active' : ''}`}
            onClick={() => setView('week')}
          >
            Semana
          </button>
        </div>

        <div className="date-navigation">
          <button className="btn-text" onClick={goToPreviousDay}>
            <FiChevronLeft /> Ayer
          </button>
          
          <div className="current-date">
            <h3>{formatDateSpanish(selectedDate)}</h3>
          </div>
          
          <button className="btn-text" onClick={goToNextDay}>
            Ma√±ana <FiChevronRight />
          </button>
        </div>

        <div className="quick-actions">
          <button className="btn-secondary" onClick={goToToday}>
            Hoy
          </button>
          <div className="filter-select">
            <select 
              value={filterEstado} 
              onChange={(e) => setFilterEstado(e.target.value)}
              className="form-select"
              style={{ width: '150px' }}
            >
              <option value="">Todos los estados</option>
              <option value="programada">Programadas</option>
              <option value="confirmada">Confirmadas</option>
              <option value="completada">Completadas</option>
              <option value="cancelada">Canceladas</option>
            </select>
          </div>
        </div>
      </div>

      {/* Lista de Citas */}
      <div className="day-citas-list">
        <h3>Citas para {formatDateSpanish(selectedDate)} ({citas.length})</h3>
        
        {citas.length > 0 ? (
          <div className="citas-cards">
            {citas.map((cita) => (
              <div key={cita.id} className="cita-card">
                <div className="cita-card-header">
                  <div className="cita-time">
                    <FiClock /> {cita.hora} ({cita.duracion || 50} min)
                  </div>
                  <div className={`cita-status badge ${
                    cita.estado === 'confirmada' ? 'badge-success' :
                    cita.estado === 'completada' ? 'badge-primary' :
                    cita.estado === 'programada' ? 'badge-warning' :
                    'badge-danger'
                  }`}>
                    {cita.estado}
                  </div>
                </div>
                
                <div className="cita-card-body">
                  <div className="cita-paciente">
                    <FiUser /> {cita.paciente_nombre || 'Paciente'}
                  </div>
                  
                  <div className="cita-info">
                    <div className="cita-tipo">
                      {cita.tipo_consulta === 'presencial' ? 'üìã Presencial' : 'üíª Virtual'}
                    </div>
                    
                    {cita.paciente_telefono && (
                      <div className="cita-contacto">
                        üìû {cita.paciente_telefono}
                      </div>
                    )}
                    
                    {cita.psicologo_nombre && (
                      <div className="cita-psicologo">
                        üë®‚Äç‚öïÔ∏è {cita.psicologo_nombre}
                      </div>
                    )}
                    
                    {cita.notas && (
                      <div className="cita-notas">
                        <strong>Notas:</strong> {cita.notas}
                      </div>
                    )}
                  </div>
                </div>
                
                <div className="cita-card-footer">
                  <button className="btn-text">
                    <FiEdit2 /> Editar
                  </button>
                  
                  {cita.estado === 'confirmada' && (
                    <button 
                      className="btn-text text-success"
                      onClick={() => handleEstadoCita(cita.id, 'completada')}
                    >
                      <FiCheckCircle /> Completar
                    </button>
                  )}
                  
                  {(cita.estado === 'programada' || cita.estado === 'confirmada') && (
                    <button 
                      className="btn-text text-danger"
                      onClick={() => handleEstadoCita(cita.id, 'cancelada')}
                    >
                      <FiXCircle /> Cancelar
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">üìÖ</div>
            <div>No hay citas programadas para este d√≠a</div>
            <button 
              className="btn-text" 
              onClick={() => setShowNuevaCitaModal(true)}
            >
              Agendar nueva cita
            </button>
          </div>
        )}
      </div>

      {/* Modal para nueva cita (simplificado) */}
      {showNuevaCitaModal && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3>Nueva Cita</h3>
              <button className="modal-close" onClick={() => setShowNuevaCitaModal(false)}>√ó</button>
            </div>
            <div className="modal-content">
              <p>Funcionalidad de nueva cita. Esta funci√≥n est√° en desarrollo.</p>
              <p>Por ahora, contacta al coordinador para agendar nuevas citas.</p>
            </div>
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowNuevaCitaModal(false)}>
                Cerrar
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default BecarioCitas;

/frontend\src\pages\becario\DashboardPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiCalendar, FiUsers, FiClock, FiBell, 
  FiTrendingUp, FiAlertCircle, FiRefreshCw 
} from 'react-icons/fi';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const BecarioDashboard = () => {
  const [estadisticas, setEstadisticas] = useState({
    citasHoy: 0,
    citasProximas: 0,
    pacientesAsignados: 0,
    observacionesPendientes: 0,
    notificacionesSinLeer: 0,
    citasCompletadas: 0
  });
  const [citasHoy, setCitasHoy] = useState([]);
  const [notificaciones, setNotificaciones] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      const token = localStorage.getItem('token');
      
      // Obtener estad√≠sticas
      const statsResponse = await fetch('http://localhost:3000/api/roles/my-role-info', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (statsResponse.ok) {
        const statsData = await statsResponse.json();
        setEstadisticas(statsData.data.estadisticas || {
          citasHoy: 3,
          pacientesAsignados: 2,
          observacionesPendientes: 1
        });
      }
      
      // Obtener citas de hoy
      const today = format(new Date(), 'yyyy-MM-dd');
      const citasResponse = await fetch(`http://localhost:3000/api/citas/citas-por-fecha?fecha=${today}`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (citasResponse.ok) {
        const citasData = await citasResponse.json();
        setCitasHoy(citasData.data || []);
      }
      
      // Obtener notificaciones
      const notifResponse = await fetch('http://localhost:3000/api/notificaciones/mis-notificaciones', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (notifResponse.ok) {
        const notifData = await notifResponse.json();
        setNotificaciones(notifData.data || []);
      }
      
    } catch (error) {
      console.error('Error cargando dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  const statCards = [
    {
      title: 'Citas Hoy',
      value: estadisticas.citasHoy,
      icon: <FiCalendar />,
      color: 'var(--grnb)',
      change: 'Programadas para hoy'
    },
    {
      title: 'Pacientes Asignados',
      value: estadisticas.pacientesAsignados,
      icon: <FiUsers />,
      color: 'var(--blu)',
      change: 'A tu cargo'
    },
    {
      title: 'Pr√≥ximas Citas',
      value: estadisticas.citasProximas || 5,
      icon: <FiClock />,
      color: 'var(--yy)',
      change: 'Pr√≥ximos 7 d√≠as'
    },
    {
      title: 'Notificaciones',
      value: estadisticas.notificacionesSinLeer || notificaciones.filter(n => !n.leida).length,
      icon: <FiBell />,
      color: 'var(--rr)',
      change: 'Sin leer'
    },
    {
      title: 'Observaciones Pendientes',
      value: estadisticas.observacionesPendientes,
      icon: <FiTrendingUp />,
      color: 'var(--grnd)',
      change: 'Por registrar'
    },
    {
      title: 'Citas Completadas',
      value: estadisticas.citasCompletadas || 12,
      icon: <FiAlertCircle />,
      color: 'var(--grnl)',
      change: 'Este mes'
    }
  ];

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando panel del becario...</div>
      </div>
    );
  }

  return (
    <div className="dashboard-page">
      <div className="page-header">
        <div>
          <h1>Panel del Becario</h1>
          <p>Bienvenido a tu centro de gesti√≥n de citas y pacientes</p>
        </div>
        <button className="btn-secondary" onClick={fetchDashboardData}>
          <FiRefreshCw /> Actualizar
        </button>
      </div>

      {/* Stats Grid */}
      <div className="stats-grid">
        {statCards.map((stat, index) => (
          <div key={index} className="stat-card">
            <div className="stat-header">
              <div className="stat-icon" style={{ color: stat.color }}>
                {stat.icon}
              </div>
              <h3>{stat.title}</h3>
            </div>
            <div className="stat-value">{stat.value}</div>
            <div className="stat-change">{stat.change}</div>
          </div>
        ))}
      </div>

      {/* Main Content Grid */}
      <div className="dashboard-content-grid">
        {/* Citas de Hoy */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Citas de Hoy</h3>
            <button className="btn-text">Ver Calendario</button>
          </div>
          
          <div className="citas-list">
            {citasHoy.length > 0 ? (
              citasHoy.slice(0, 5).map((cita) => (
                <div key={cita.id} className="cita-item">
                  <div className="cita-info">
                    <div className="cita-paciente">{cita.paciente_nombre}</div>
                    <div className="cita-hora">{cita.hora}</div>
                  </div>
                  <div className={`cita-estado badge ${
                    cita.estado === 'confirmada' ? 'badge-success' :
                    cita.estado === 'programada' ? 'badge-warning' :
                    'badge-danger'
                  }`}>
                    {cita.estado}
                  </div>
                </div>
              ))
            ) : (
              <div className="no-citas">
                <div className="no-citas-icon">üìÖ</div>
                <div>No hay citas programadas para hoy</div>
              </div>
            )}
          </div>
        </div>

        {/* Notificaciones Recientes */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Notificaciones Recientes</h3>
            <button className="btn-text">Ver todas</button>
          </div>
          
          <div className="notifications-list">
            {notificaciones.slice(0, 5).map((notif) => (
              <div key={notif.id} className={`notification-item ${!notif.leida ? 'unread' : ''}`}>
                <div>
                  <h4>{notif.titulo}</h4>
                  <p>{notif.mensaje}</p>
                  <small>{new Date(notif.fecha_notificacion).toLocaleTimeString()}</small>
                </div>
                {!notif.leida && <span className="badge badge-info">Nuevo</span>}
              </div>
            ))}
            
            {notificaciones.length === 0 && (
              <div className="no-citas">
                <div className="no-citas-icon">üîî</div>
                <div>No hay notificaciones</div>
              </div>
            )}
          </div>
        </div>

        {/* Pacientes Asignados */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Mis Pacientes</h3>
            <button className="btn-text">Ver todos</button>
          </div>
          
          <div className="pacientes-list">
            {[
              { id: 1, nombre: 'Carlos G√≥mez', ultimaSesion: '2024-01-10' },
              { id: 2, nombre: 'Mariana L√≥pez', ultimaSesion: '2024-01-09' },
              { id: 3, nombre: 'Ana Mart√≠nez', ultimaSesion: '2024-01-08' }
            ].map((paciente) => (
              <div key={paciente.id} className="paciente-item">
                <div className="paciente-info">
                  <div className="paciente-nombre">{paciente.nombre}</div>
                  <div className="paciente-fecha">
                    √öltima sesi√≥n: {new Date(paciente.ultimaSesion).toLocaleDateString()}
                  </div>
                </div>
                <button className="btn-text">Ver</button>
              </div>
            ))}
          </div>
        </div>

        {/* Quick Actions */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Acciones R√°pidas</h3>
          </div>
          
          <div className="quick-actions">
            <button className="btn-primary w-100 mb-10">
              Ver Mis Citas
            </button>
            <button className="btn-secondary w-100 mb-10">
              Registrar Observaci√≥n
            </button>
            <button className="btn-warning w-100 mb-10">
              Marcar Cita como Completada
            </button>
            <button className="btn-text w-100">
              Ver Calendario Completo
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BecarioDashboard;

/frontend\src\pages\becario\NotificacionesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiBell, FiCheckCircle, FiClock, FiCalendar, FiMessageSquare } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const BecarioNotificaciones = () => {
  const [notificaciones, setNotificaciones] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchNotificaciones();
  }, []);

  const fetchNotificaciones = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setNotificaciones([
          {
            id: 1,
            tipo: 'cita_modificada',
            titulo: 'Cita modificada',
            mensaje: 'La cita con Carlos G√≥mez ha sido reprogramada para ma√±ana a las 11:00 AM',
            fecha: '2024-01-10 09:30:00',
            leida: false
          },
          {
            id: 2,
            tipo: 'cita_nueva',
            titulo: 'Nueva cita asignada',
            mensaje: 'Tienes una nueva cita con Mariana L√≥pez para el viernes 12 de enero',
            fecha: '2024-01-09 14:15:00',
            leida: true
          },
          {
            id: 3,
            tipo: 'sistema',
            titulo: 'Recordatorio de observaci√≥n',
            mensaje: 'Recuerda registrar las observaciones de la sesi√≥n con Roberto S√°nchez',
            fecha: '2024-01-08 16:45:00',
            leida: false
          },
          {
            id: 4,
            tipo: 'mensaje',
            titulo: 'Mensaje del psic√≥logo',
            mensaje: 'Por favor, prepara el informe del paciente Carlos G√≥mez para la supervisi√≥n',
            fecha: '2024-01-07 10:20:00',
            leida: true
          }
        ]);
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al obtener notificaciones:', error);
      setLoading(false);
    }
  };

  const marcarComoLeida = async (notifId) => {
    setNotificaciones(prev => 
      prev.map(notif => 
        notif.id === notifId ? { ...notif, leida: true } : notif
      )
    );
  };

  const marcarTodasComoLeidas = () => {
    setNotificaciones(prev => 
      prev.map(notif => ({ ...notif, leida: true }))
    );
  };

  const getIconByTipo = (tipo) => {
    switch (tipo) {
      case 'cita_nueva':
      case 'cita_modificada':
        return <FiCalendar />;
      case 'sistema':
        return <FiBell />;
      case 'mensaje':
        return <FiMessageSquare />;
      default:
        return <FiBell />;
    }
  };

  const getColorByTipo = (tipo) => {
    switch (tipo) {
      case 'cita_nueva':
        return 'var(--grnb)';
      case 'cita_modificada':
        return 'var(--yy)';
      case 'sistema':
        return 'var(--blu)';
      case 'mensaje':
        return 'var(--grnd)';
      default:
        return 'var(--gray)';
    }
  };

  const notificacionesNoLeidas = notificaciones.filter(n => !n.leida).length;

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando notificaciones...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Notificaciones</h1>
          <p>Mensajes y alertas del sistema</p>
        </div>
        <div className="flex-row gap-10">
          {notificacionesNoLeidas > 0 && (
            <button className="btn-secondary" onClick={marcarTodasComoLeidas}>
              <FiCheckCircle /> Marcar todas como le√≠das
            </button>
          )}
        </div>
      </div>

      <div className="configuracion-container">
        <div className="config-content">
          <div className="notifications-list">
            {notificaciones.map((notif) => (
              <div 
                key={notif.id} 
                className={`notification-item ${!notif.leida ? 'unread' : ''}`}
                style={{ borderLeftColor: getColorByTipo(notif.tipo) }}
              >
                <div className="notification-icon" style={{ color: getColorByTipo(notif.tipo) }}>
                  {getIconByTipo(notif.tipo)}
                </div>
                
                <div className="notification-content">
                  <div className="notification-header">
                    <h4>{notif.titulo}</h4>
                    <div className="notification-time">
                      <FiClock size={12} />
                      {new Date(notif.fecha).toLocaleDateString()} {new Date(notif.fecha).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                    </div>
                  </div>
                  
                  <p>{notif.mensaje}</p>
                  
                  {!notif.leida && (
                    <button 
                      className="btn-text text-small"
                      onClick={() => marcarComoLeida(notif.id)}
                    >
                      <FiCheckCircle /> Marcar como le√≠da
                    </button>
                  )}
                </div>
                
                {!notif.leida && (
                  <span className="badge badge-info">Nuevo</span>
                )}
              </div>
            ))}
            
            {notificaciones.length === 0 && (
              <div className="no-citas">
                <div className="no-citas-icon">üîî</div>
                <div>No hay notificaciones</div>
                <p className="text-small mt-10">Las notificaciones aparecer√°n aqu√≠ cuando tengas nuevas alertas</p>
              </div>
            )}
          </div>
          
          <div className="mt-20">
            <h4>Tipos de notificaciones</h4>
            <div className="grid-4 mt-10">
              <div className="notification-type">
                <div className="notification-type-icon" style={{ color: 'var(--grnb)' }}>
                  <FiCalendar />
                </div>
                <div className="notification-type-info">
                  <strong>Citas</strong>
                  <p>Nuevas citas, modificaciones y recordatorios</p>
                </div>
              </div>
              
              <div className="notification-type">
                <div className="notification-type-icon" style={{ color: 'var(--blu)' }}>
                  <FiBell />
                </div>
                <div className="notification-type-info">
                  <strong>Sistema</strong>
                  <p>Alertas y recordatorios del sistema</p>
                </div>
              </div>
              
              <div className="notification-type">
                <div className="notification-type-icon" style={{ color: 'var(--grnd)' }}>
                  <FiMessageSquare />
                </div>
                <div className="notification-type-info">
                  <strong>Mensajes</strong>
                  <p>Comunicaci√≥n con psic√≥logos y coordinadores</p>
                </div>
              </div>
              
              <div className="notification-type">
                <div className="notification-type-icon" style={{ color: 'var(--yy)' }}>
                  <FiCheckCircle />
                </div>
                <div className="notification-type-info">
                  <strong>Tareas</strong>
                  <p>Recordatorios de tareas pendientes</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BecarioNotificaciones;

/frontend\src\pages\becario\ObservacionesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiFileText, FiPlus, FiEdit2, FiTrash2, FiCalendar, FiUser, FiSave } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';


const BecarioObservaciones = () => {
  const [observaciones, setObservaciones] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [formData, setFormData] = useState({
    paciente_id: '',
    fecha: new Date().toISOString().split('T')[0],
    observaciones: '',
    dificultades: '',
    logros: '',
    preguntas_supervisor: ''
  });
  const [pacientes, setPacientes] = useState([]);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setPacientes([
          { id: 1, nombre: 'Carlos G√≥mez' },
          { id: 2, nombre: 'Mariana L√≥pez' },
          { id: 3, nombre: 'Roberto S√°nchez' }
        ]);
        
        setObservaciones([
          {
            id: 1,
            paciente_nombre: 'Carlos G√≥mez',
            fecha: '2024-01-10',
            observaciones: 'El paciente mostr√≥ mejor√≠a en su manejo de la ansiedad durante la sesi√≥n.',
            dificultades: 'A√∫n presenta resistencia para hablar sobre ciertos temas familiares.',
            logros: 'Logr√≥ identificar tres t√©cnicas de relajaci√≥n que le funcionan.',
            preguntas_supervisor: '¬øC√≥mo abordar la resistencia a temas familiares?'
          },
          {
            id: 2,
            paciente_nombre: 'Mariana L√≥pez',
            fecha: '2024-01-09',
            observaciones: 'La paciente trabaj√≥ en estrategias para manejar el estr√©s laboral.',
            dificultades: 'Dificultad para establecer l√≠mites en el trabajo.',
            logros: 'Identific√≥ patrones de pensamiento que generan estr√©s.',
            preguntas_supervisor: '¬øSugerencias para ejercicios de asertividad?'
          }
        ]);
        
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al cargar datos:', error);
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // En un proyecto real, aqu√≠ enviar√≠amos al backend
    const nuevaObservacion = {
      id: observaciones.length + 1,
      paciente_nombre: pacientes.find(p => p.id == formData.paciente_id)?.nombre || 'Paciente',
      ...formData
    };
    
    setObservaciones([nuevaObservacion, ...observaciones]);
    setShowForm(false);
    setFormData({
      paciente_id: '',
      fecha: new Date().toISOString().split('T')[0],
      observaciones: '',
      dificultades: '',
      logros: '',
      preguntas_supervisor: ''
    });
    
    notifications.success('Observaci√≥n registrada exitosamente');
  };

  const handleDelete = async (id) => {
    const confirmado = await confirmations.danger('¬øEst√°s seguro de eliminar esta observaci√≥n?');
    
    if (confirmado) {
      setObservaciones(observaciones.filter(o => o.id !== id));
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando observaciones...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Observaciones de Sesiones</h1>
          <p>Registro de observaciones para supervisi√≥n</p>
        </div>
        <button 
          className="btn-primary"
          onClick={() => setShowForm(true)}
        >
          <FiPlus /> Nueva Observaci√≥n
        </button>
      </div>

      {/* Formulario de Nueva Observaci√≥n */}
      {showForm && (
        <div className="card mb-20">
          <div className="modal-header">
            <h3>Nueva Observaci√≥n</h3>
            <button className="modal-close" onClick={() => setShowForm(false)}>√ó</button>
          </div>
          
          <form onSubmit={handleSubmit}>
            <div className="form-grid">
              <div className="form-group">
                <label>Paciente</label>
                <select
                  name="paciente_id"
                  value={formData.paciente_id}
                  onChange={handleInputChange}
                  className="select-field"
                  required
                >
                  <option value="">Seleccionar paciente</option>
                  {pacientes.map(paciente => (
                    <option key={paciente.id} value={paciente.id}>
                      {paciente.nombre}
                    </option>
                  ))}
                </select>
              </div>
              
              <div className="form-group">
                <label>Fecha de sesi√≥n</label>
                <input
                  type="date"
                  name="fecha"
                  value={formData.fecha}
                  onChange={handleInputChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group" style={{ gridColumn: 'span 2' }}>
                <label>Observaciones generales</label>
                <textarea
                  name="observaciones"
                  value={formData.observaciones}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="4"
                  required
                  placeholder="Describe lo observado durante la sesi√≥n..."
                />
              </div>
              
              <div className="form-group">
                <label>Dificultades encontradas</label>
                <textarea
                  name="dificultades"
                  value={formData.dificultades}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="3"
                  placeholder="Dificultades o resistencias observadas..."
                />
              </div>
              
              <div className="form-group">
                <label>Logros del paciente</label>
                <textarea
                  name="logros"
                  value={formData.logros}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="3"
                  placeholder="Avances y logros observados..."
                />
              </div>
              
              <div className="form-group" style={{ gridColumn: 'span 2' }}>
                <label>Preguntas para el supervisor</label>
                <textarea
                  name="preguntas_supervisor"
                  value={formData.preguntas_supervisor}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="3"
                  placeholder="Dudas o preguntas para la supervisi√≥n..."
                />
              </div>
            </div>
            
            <div className="form-actions">
              <button type="submit" className="btn-primary">
                <FiSave /> Guardar Observaci√≥n
              </button>
              <button 
                type="button" 
                className="btn-danger"
                onClick={() => setShowForm(false)}
              >
                Cancelar
              </button>
            </div>
          </form>
        </div>
      )}

      {/* Lista de Observaciones */}
      <div className="config-content">
        <h3>Observaciones Registradas</h3>
        
        {observaciones.length > 0 ? (
          <div className="observaciones-list">
            {observaciones.map((obs) => (
              <div key={obs.id} className="accordion">
                <div className="accordion-header">
                  <div className="flex-row align-center gap-10">
                    <FiCalendar />
                    <span>{new Date(obs.fecha).toLocaleDateString()}</span>
                  </div>
                  <div className="flex-row align-center gap-10">
                    <FiUser />
                    <span>{obs.paciente_nombre}</span>
                  </div>
                  <div className="flex-row gap-5">
                    <button className="btn-text">
                      <FiEdit2 />
                    </button>
                    <button 
                      className="btn-text text-danger"
                      onClick={() => handleDelete(obs.id)}
                    >
                      <FiTrash2 />
                    </button>
                  </div>
                </div>
                
                <div className="accordion-content">
                  <div className="grid-2 gap-20">
                    <div>
                      <h4>Observaciones</h4>
                      <p>{obs.observaciones}</p>
                    </div>
                    
                    <div>
                      <h4>Logros</h4>
                      <p>{obs.logros}</p>
                    </div>
                    
                    <div>
                      <h4>Dificultades</h4>
                      <p>{obs.dificultades}</p>
                    </div>
                    
                    <div>
                      <h4>Preguntas para supervisor</h4>
                      <p>{obs.preguntas_supervisor}</p>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">üìù</div>
            <div>No hay observaciones registradas</div>
            <p className="text-small mt-10">
              Las observaciones son importantes para tu supervisi√≥n y desarrollo profesional.
            </p>
            <button 
              className="btn-text mt-10"
              onClick={() => setShowForm(true)}
            >
              <FiPlus /> Registrar tu primera observaci√≥n
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default BecarioObservaciones;

/frontend\src\pages\becario\PacientesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiUser, FiCalendar, FiPhone, FiMail, FiFileText } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const BecarioPacientes = () => {
  const [pacientes, setPacientes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedPaciente, setSelectedPaciente] = useState(null);
  const [showDetalles, setShowDetalles] = useState(false);

  useEffect(() => {
    fetchPacientes();
  }, []);

  const fetchPacientes = async () => {
    try {
      const token = localStorage.getItem('token');
      
      // En un proyecto real, esto vendr√≠a de un endpoint espec√≠fico
      // Simulamos datos por ahora
      setTimeout(() => {
        setPacientes([
          {
            id: 1,
            nombre: 'Carlos G√≥mez',
            edad: 25,
            telefono: '555-1234',
            email: 'carlos@email.com',
            motivo_consulta: 'Ansiedad acad√©mica',
            ultima_sesion: '2024-01-10',
            proxima_cita: '2024-01-17',
            sesiones_completadas: 3,
            psicologo: 'Lic. Luis Fern√°ndez'
          },
          {
            id: 2,
            nombre: 'Mariana L√≥pez',
            edad: 28,
            telefono: '555-5678',
            email: 'mariana@email.com',
            motivo_consulta: 'Estr√©s laboral',
            ultima_sesion: '2024-01-09',
            proxima_cita: '2024-01-16',
            sesiones_completadas: 5,
            psicologo: 'Lic. Luis Fern√°ndez'
          },
          {
            id: 3,
            nombre: 'Roberto S√°nchez',
            edad: 22,
            telefono: '555-9012',
            email: 'roberto@email.com',
            motivo_consulta: 'Problemas de adaptaci√≥n',
            ultima_sesion: '2024-01-08',
            proxima_cita: '2024-01-15',
            sesiones_completadas: 2,
            psicologo: 'Lic. Luis Fern√°ndez'
          }
        ]);
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al obtener pacientes:', error);
      setLoading(false);
    }
  };

  const filteredPacientes = pacientes.filter(paciente =>
    paciente.nombre.toLowerCase().includes(searchTerm.toLowerCase()) ||
    paciente.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
    paciente.motivo_consulta.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const showPacienteDetalles = (paciente) => {
    setSelectedPaciente(paciente);
    setShowDetalles(true);
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando pacientes...</div>
      </div>
    );
  }

  return (
    <div className="pacientes-page">
      <div className="page-header">
        <div>
          <h1>Mis Pacientes</h1>
          <p>Pacientes asignados a tu supervisi√≥n</p>
        </div>
      </div>

      {/* Search */}
      <div className="search-box" style={{ marginBottom: '20px' }}>
        <FiSearch />
        <input
          type="text"
          className="search-input"
          placeholder="Buscar paciente por nombre, email o motivo de consulta..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      {/* Patients Grid */}
      <div className="grid-3">
        {filteredPacientes.map((paciente) => (
          <div key={paciente.id} className="card">
            <div className="flex-row align-center gap-10 mb-10">
              <div className="avatar">
                {paciente.nombre.split(' ').map(n => n[0]).join('')}
              </div>
              <div>
                <h3>{paciente.nombre}</h3>
                <p className="text-small">{paciente.edad} a√±os</p>
              </div>
            </div>

            <div className="flex-col gap-5 mb-10">
              <div className="flex-row align-center gap-5">
                <FiPhone size={14} />
                <span>{paciente.telefono}</span>
              </div>
              <div className="flex-row align-center gap-5">
                <FiMail size={14} />
                <span>{paciente.email}</span>
              </div>
              <div className="flex-row align-center gap-5">
                <FiCalendar size={14} />
                <span>√öltima: {new Date(paciente.ultima_sesion).toLocaleDateString()}</span>
              </div>
            </div>

            <div className="mb-10">
              <p><strong>Motivo:</strong> {paciente.motivo_consulta}</p>
              <p><strong>Psic√≥logo:</strong> {paciente.psicologo}</p>
              <p><strong>Sesiones:</strong> {paciente.sesiones_completadas} completadas</p>
            </div>

            <div className="flex-row gap-10">
              <button 
                className="btn-secondary flex-1"
                onClick={() => showPacienteDetalles(paciente)}
              >
                <FiFileText /> Detalles
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Modal de Detalles */}
      {showDetalles && selectedPaciente && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>Detalles del Paciente</h3>
              <button className="modal-close" onClick={() => setShowDetalles(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="grid-2 gap-20">
                <div>
                  <h4>Informaci√≥n Personal</h4>
                  <div className="detail-row">
                    <strong>Nombre:</strong> {selectedPaciente.nombre}
                  </div>
                  <div className="detail-row">
                    <strong>Edad:</strong> {selectedPaciente.edad} a√±os
                  </div>
                  <div className="detail-row">
                    <strong>Tel√©fono:</strong> {selectedPaciente.telefono}
                  </div>
                  <div className="detail-row">
                    <strong>Email:</strong> {selectedPaciente.email}
                  </div>
                </div>
                
                <div>
                  <h4>Informaci√≥n Cl√≠nica</h4>
                  <div className="detail-row">
                    <strong>Motivo de consulta:</strong> {selectedPaciente.motivo_consulta}
                  </div>
                  <div className="detail-row">
                    <strong>Psic√≥logo asignado:</strong> {selectedPaciente.psicologo}
                  </div>
                  <div className="detail-row">
                    <strong>Sesiones completadas:</strong> {selectedPaciente.sesiones_completadas}
                  </div>
                  <div className="detail-row">
                    <strong>Pr√≥xima cita:</strong> {new Date(selectedPaciente.proxima_cita).toLocaleDateString()}
                  </div>
                </div>
              </div>
              
              <div className="mt-20">
                <h4>Historial de Citas Recientes</h4>
                <div className="table-container mt-10">
                  <table className="data-table">
                    <thead>
                      <tr>
                        <th>Fecha</th>
                        <th>Hora</th>
                        <th>Estado</th>
                        <th>Tipo</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>{new Date(selectedPaciente.ultima_sesion).toLocaleDateString()}</td>
                        <td>10:00 AM</td>
                        <td><span className="badge badge-success">Completada</span></td>
                        <td>Presencial</td>
                      </tr>
                      <tr>
                        <td>2024-01-03</td>
                        <td>11:00 AM</td>
                        <td><span className="badge badge-success">Completada</span></td>
                        <td>Virtual</td>
                      </tr>
                      <tr>
                        <td>2023-12-27</td>
                        <td>09:00 AM</td>
                        <td><span className="badge badge-success">Completada</span></td>
                        <td>Presencial</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowDetalles(false)}>
                Cerrar
              </button>
              <button className="btn-primary">
                Agendar Cita
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default BecarioPacientes;

/frontend\src\pages\coordinador\AgendaPage.js:
--------------------------------------------------------------------------------
// frontend/src/pages/coordinador/AgendaPage.js
import React, { useState, useEffect } from 'react';
import { 
  FiCalendar, FiClock, FiUsers, FiFilter, 
  FiChevronLeft, FiChevronRight, FiRefreshCw,
  FiUser, FiEye, FiEyeOff, FiMail,
  FiPhone, FiVideo, FiMapPin, FiEdit2,
  FiDownload, FiBarChart2, FiCheckCircle, FiXCircle, FiAlertCircle,
  FiSearch, FiUserCheck, FiSettings, FiArchive
} from 'react-icons/fi';
import { format, addDays, subDays, startOfWeek, endOfWeek, eachDayOfInterval } from 'date-fns';
import { es } from 'date-fns/locale';
import ApiService from '../../services/api';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const CoordinadorAgenda = () => {
  const [citas, setCitas] = useState([]);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [view, setView] = useState('week');
  const [loading, setLoading] = useState(true);
  const [filterPsicologo, setFilterPsicologo] = useState('');
  const [filterEstado, setFilterEstado] = useState('');
  const [psicologos, setPsicologos] = useState([]);
  const [showDetalles, setShowDetalles] = useState(false);
  const [selectedCita, setSelectedCita] = useState(null);
  const [mostrarTodas, setMostrarTodas] = useState(true);
  const [estadisticas, setEstadisticas] = useState(null);
  const [disponibilidad, setDisponibilidad] = useState([]);
  const [showModalDisponibilidad, setShowModalDisponibilidad] = useState(false);
  const [pacientes, setPacientes] = useState([]);
  const [searchPaciente, setSearchPaciente] = useState('');
  const [filteredPacientes, setFilteredPacientes] = useState([]);
  
  const [filtrosAvanzados, setFiltrosAvanzados] = useState({
    fecha_inicio: '',
    fecha_fin: '',
    paciente_id: '',
    tipo_consulta: ''
  });

  // Colores fijos para psic√≥logos
  const coloresPsicologos = ['#29ce9b', '#1F85BA', '#ffa631', '#37B69C', '#fa3144'];

  useEffect(() => {
    fetchPsicologos();
    fetchPacientes();
  }, []);

  useEffect(() => {
    fetchAgenda();
  }, [selectedDate, view, filterPsicologo, filterEstado, filtrosAvanzados]);

  const fetchPacientes = async () => {
    try {
      const response = await ApiService.get('/pacientes?activo=true&limit=100');
      if (response.success) {
        setPacientes(response.data);
      }
    } catch (error) {
      console.error('Error cargando pacientes:', error);
    }
  };

  const fetchPsicologos = async () => {
    try {
      const response = await ApiService.get('/users?rol=psicologo');
      if (response.success) {
        const psicologosData = response.data.map((psicologo, index) => ({
          id: psicologo.id,
          nombre: `${psicologo.nombre} ${psicologo.apellido}`,
          color: coloresPsicologos[index % coloresPsicologos.length],
          especialidad: psicologo.especialidad || 'Psicolog√≠a General',
          email: psicologo.email
        }));
        setPsicologos(psicologosData);
      }
    } catch (error) {
      console.error('Error cargando psic√≥logos:', error);
    }
  };

  const fetchAgenda = async () => {
    try {
      setLoading(true);
      
      const params = new URLSearchParams();
      
      // Si estamos en vista semanal, usar el rango de la semana
      if (view === 'week') {
        const start = startOfWeek(selectedDate, { weekStartsOn: 1 });
        const end = endOfWeek(selectedDate, { weekStartsOn: 1 });
        params.append('fecha_inicio', format(start, 'yyyy-MM-dd'));
        params.append('fecha_fin', format(end, 'yyyy-MM-dd'));
      } else {
        // Vista diaria
        params.append('fecha_inicio', format(selectedDate, 'yyyy-MM-dd'));
        params.append('fecha_fin', format(selectedDate, 'yyyy-MM-dd'));
      }
      
      // Aplicar filtros
      if (filterPsicologo) {
        params.append('psicologo_id', filterPsicologo);
      }
      
      if (filterEstado) {
        params.append('estado', filterEstado);
      }
      
      // Filtros avanzados
      if (filtrosAvanzados.paciente_id) {
        params.append('paciente_id', filtrosAvanzados.paciente_id);
      }
      
      if (filtrosAvanzados.tipo_consulta) {
        params.append('tipo_consulta', filtrosAvanzados.tipo_consulta);
      }
      
      // Llamar al endpoint de agenda global
      const response = await ApiService.get(`/agenda/global?${params.toString()}`);
      
      if (response.success) {
        // Transformar los datos para que coincidan con la estructura esperada
        const citasTransformadas = response.data.citas.map(cita => {
          const psicologo = psicologos.find(p => p.id === cita.psicologo_id) || {
            nombre: cita.Psicologo ? `${cita.Psicologo.nombre} ${cita.Psicologo.apellido}` : 'No asignado',
            color: coloresPsicologos[cita.psicologo_id % coloresPsicologos.length]
          };
          
          return {
            id: cita.id,
            fecha: cita.fecha,
            hora: cita.hora || '00:00',
            duracion: cita.duracion || 50,
            paciente_nombre: cita.Paciente ? 
              `${cita.Paciente.nombre} ${cita.Paciente.apellido}` : 'Paciente',
            paciente_id: cita.paciente_id,
            psicologo_id: cita.psicologo_id,
            psicologo_nombre: psicologo.nombre,
            psicologo_color: psicologo.color,
            tipo_consulta: cita.tipo_consulta,
            estado: cita.estado,
            becario_nombre: cita.Becario ? 
              `${cita.Becario.nombre} ${cita.Becario.apellido}` : null,
            becario_id: cita.becario_id,
            notas: cita.notas,
            telefono: cita.Paciente?.telefono,
            email: cita.Paciente?.email
          };
        });
        
        setCitas(citasTransformadas);
        setEstadisticas(response.data.estadisticas);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error cargando agenda:', error);
      setLoading(false);
    }
  };

  const filteredCitas = citas.filter(cita => {
    const matchesPsicologo = !filterPsicologo || cita.psicologo_id == filterPsicologo;
    const matchesEstado = !filterEstado || cita.estado === filterEstado;
    return matchesPsicologo && matchesEstado;
  });

  // Funci√≥n para buscar pacientes
  const buscarPaciente = (searchTerm) => {
    setSearchPaciente(searchTerm);
    if (searchTerm.length > 1) {
      const filtered = pacientes.filter(paciente =>
        `${paciente.nombre} ${paciente.apellido}`.toLowerCase().includes(searchTerm.toLowerCase()) ||
        paciente.email?.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setFilteredPacientes(filtered.slice(0, 5));
    } else {
      setFilteredPacientes([]);
    }
  };

  const seleccionarPaciente = (paciente) => {
    setSearchPaciente(`${paciente.nombre} ${paciente.apellido}`);
    setFiltrosAvanzados(prev => ({
      ...prev,
      paciente_id: paciente.id
    }));
    setFilteredPacientes([]);
  };

  const goToPrevious = () => {
    setSelectedDate(prev => subDays(prev, view === 'day' ? 1 : 7));
  };

  const goToNext = () => {
    setSelectedDate(prev => addDays(prev, view === 'day' ? 1 : 7));
  };

  const goToToday = () => {
    setSelectedDate(new Date());
  };

  const formatDateSpanish = (date) => {
    return format(date, "EEEE d 'de' MMMM, yyyy", { locale: es });
  };

  const getWeekRange = () => {
    const start = startOfWeek(selectedDate, { weekStartsOn: 1 });
    const end = endOfWeek(selectedDate, { weekStartsOn: 1 });
    return `Semana del ${format(start, 'd MMM')} al ${format(end, 'd MMM, yyyy')}`;
  };

  const generateHours = () => {
    const hours = [];
    for (let i = 9; i <= 20; i++) {
      hours.push(`${i}:00`);
    }
    return hours;
  };

  const getCitasPorDiaYHora = (fecha, hora) => {
    try {
      const fechaStr = format(new Date(fecha), 'yyyy-MM-dd');
      const horaNum = hora.split(':')[0];
      
      return filteredCitas.filter(cita => 
        cita.fecha === fechaStr &&
        cita.hora.startsWith(horaNum)
      );
    } catch (error) {
      console.error('Error filtrando citas:', error);
      return [];
    }
  };

  const showCitaDetalles = (cita) => {
    setSelectedCita(cita);
    setShowDetalles(true);
  };

  const handleFiltroAvanzado = (key, value) => {
    setFiltrosAvanzados(prev => ({
      ...prev,
      [key]: value
    }));
  };

  const resetFiltros = () => {
    setFilterPsicologo('');
    setFilterEstado('');
    setSearchPaciente('');
    setFiltrosAvanzados({
      fecha_inicio: '',
      fecha_fin: '',
      paciente_id: '',
      tipo_consulta: ''
    });
  };

  const exportarAgenda = async () => {
      try {
          setLoading(true);
          
          const fechaInicio = filtrosAvanzados.fecha_inicio || format(startOfWeek(selectedDate, { weekStartsOn: 1 }), 'yyyy-MM-dd');
          const fechaFin = filtrosAvanzados.fecha_fin || format(endOfWeek(selectedDate, { weekStartsOn: 1 }), 'yyyy-MM-dd');
          
          // Crear datos para exportar
          const datosExportacion = {
              fecha_inicio: fechaInicio,
              fecha_fin: fechaFin,
              psicologo_id: filterPsicologo || null,
              tipo_consulta: filtrosAvanzados.tipo_consulta || null
          };

          const token = localStorage.getItem('token');
          
          const response = await fetch('http://localhost:3000/api/reportes/exportar-agenda-csv', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify(datosExportacion)
          });

          if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Error ${response.status}: ${errorText}`);
          }

          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          
          let filename = `agenda_${fechaInicio}_a_${fechaFin}.csv`;
          const contentDisposition = response.headers.get('content-disposition');
          if (contentDisposition) {
              const match = contentDisposition.match(/filename="(.+?)"/);
              if (match) {
                  filename = match[1];
              }
          }
          
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);
          
          notifications.success(' Agenda exportada exitosamente como CSV');
          
      } catch (error) {
          console.error('Error exportando agenda:', error);
          notifications.error(' Error al exportar agenda: ' + error.message);
      } finally {
          setLoading(false);
      }
  };

  const exportarDisponibilidad = async () => {
      try {
          const fecha = format(new Date(), 'yyyy-MM-dd');
          const response = await ApiService.post('/reportes/exportar-disponibilidad-csv', { fecha });
          
          const blob = new Blob([response], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          const url = URL.createObjectURL(blob);
          
          link.setAttribute('href', url);
          link.setAttribute('download', `disponibilidad_${fecha}.csv`);
          document.body.appendChild(link);
          link.click();
          
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          
          notifications.success(' Disponibilidad exportada exitosamente');
          
      } catch (error) {
          console.error('Error exportando disponibilidad:', error);
          notifications.error(' Error al exportar disponibilidad');
      }
  };

  const verHoy = () => {
      const hoy = format(new Date(), 'yyyy-MM-dd');
      setFiltrosAvanzados({
          fecha_inicio: hoy,
          fecha_fin: hoy,
          paciente_id: '',
          tipo_consulta: ''
      });
      setSelectedDate(new Date());
  };

  const revisarConflictos = async () => {
      try {
          setLoading(true);
          
          const fechaInicio = filtrosAvanzados.fecha_inicio || format(startOfWeek(selectedDate, { weekStartsOn: 1 }), 'yyyy-MM-dd');
          const fechaFin = filtrosAvanzados.fecha_fin || format(endOfWeek(selectedDate, { weekStartsOn: 1 }), 'yyyy-MM-dd');
          
          const response = await ApiService.post('/reportes/reporte-conflictos', {
              fecha_inicio: fechaInicio,
              fecha_fin: fechaFin
          });
          
          if (response.success && response.data.conflictos.length > 0) {
              notifications.warning(`Se encontraron ${response.data.conflictos.length} conflictos de horario`);
          } else {
              notifications.success(' No se encontraron conflictos de horario');
          }
          
      } catch (error) {
          console.error('Error revisando conflictos:', error);
          notifications.error(' Error al revisar conflictos');
      } finally {
          setLoading(false);
      }
  };

  const fetchDisponibilidad = async () => {
    try {
        const fecha = format(new Date(), 'yyyy-MM-dd');
        const response = await ApiService.get(`/agenda/disponibilidad-profesionales?fecha=${fecha}`);
        
        if (response.success) {
            setDisponibilidad(response.data.disponibilidad);
        } else {
            setDisponibilidad([]);
        }
    } catch (error) {
        console.error('Error cargando disponibilidad:', error);
        setDisponibilidad([]);
    }
  };

  // Llama a fetchDisponibilidad en useEffect
  useEffect(() => {
    const loadData = async () => {
        await fetchPsicologos();
        await fetchPacientes();
        await fetchAgenda();
        await fetchDisponibilidad();
    };
    loadData();
  }, [selectedDate, view, filterPsicologo, filterEstado, filtrosAvanzados]);

  const weekDays = view === 'week' ? 
    eachDayOfInterval({ 
      start: startOfWeek(selectedDate, { weekStartsOn: 1 }), 
      end: endOfWeek(selectedDate, { weekStartsOn: 1 }) 
    }) : [selectedDate];

  if (loading && citas.length === 0) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando agenda global...</div>
      </div>
    );
  }

  return (
    <div className="citas-page">
      <div className="page-header">
        <div>
          <h1>Agenda Global</h1>
          <p>Vista completa de todas las citas del consultorio</p>
        </div>
        <div className="flex-row gap-10">
          <button className="btn-secondary" onClick={fetchAgenda}>
            <FiRefreshCw /> Actualizar
          </button>
          <button className="btn-primary" onClick={exportarAgenda}>
            <FiDownload /> Exportar Agenda
          </button>
        </div>
      </div>

      {/* Estad√≠sticas r√°pidas - MEJORADO */}
      {estadisticas && (
        <div className="grid-2 mb-20" style={{ gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
          <div className="card card-primary-coord">
            <div className="flex-row align-center gap-15 mb-15">
              <div className="avatar" style={{ background: 'var(--blu)' }}>
                <FiBarChart2 size={24} />
              </div>
              <div>
                <h4>Resumen General</h4>
                <p className="text-small">Estad√≠sticas del per√≠odo</p>
              </div>
            </div>
            
            <div className="grid-2 gap-10">
              <div className="stat-box">
                <div className="stat-icon" style={{ color: 'var(--grnb)' }}>
                  <FiCalendar />
                </div>
                <div className="stat-content">
                  <div className="stat-value">{estadisticas.total_citas || filteredCitas.length}</div>
                  <div className="stat-label">Total Citas</div>
                </div>
              </div>
              
              <div className="stat-box">
                <div className="stat-icon" style={{ color: 'var(--blu)' }}>
                  <FiCheckCircle />
                </div>
                <div className="stat-content">
                  <div className="stat-value">{estadisticas.confirmadas || filteredCitas.filter(c => c.estado === 'confirmada').length}</div>
                  <div className="stat-label">Confirmadas</div>
                </div>
              </div>
              
              <div className="stat-box">
                <div className="stat-icon" style={{ color: 'var(--yy)' }}>
                  <FiUsers />
                </div>
                <div className="stat-content">
                  <div className="stat-value">{estadisticas.psicologos_involucrados || psicologos.length}</div>
                  <div className="stat-label">Psic√≥logos</div>
                </div>
              </div>
              
              <div className="stat-box">
                <div className="stat-icon" style={{ color: 'var(--grnd)' }}>
                  <FiUser />
                </div>
                <div className="stat-content">
                  <div className="stat-value">{estadisticas.pacientes_atendidos || new Set(filteredCitas.map(c => c.paciente_id)).size}</div>
                  <div className="stat-label">Pacientes</div>
                </div>
              </div>
            </div>
            
            <div className="mt-15 pt-15 border-top">
              <div className="flex-row justify-between">
                <span className="text-small">Programadas:</span>
                <span className="badge badge-warning">{estadisticas.programadas || filteredCitas.filter(c => c.estado === 'programada').length}</span>
              </div>
              <div className="flex-row justify-between mt-5">
                <span className="text-small">Completadas:</span>
                <span className="badge badge-success">{estadisticas.completadas || filteredCitas.filter(c => c.estado === 'completada').length}</span>
              </div>
            </div>
          </div>
          

          <div className="card card-secondary-coord">
            <div className="flex-row align-center gap-15 mb-15">
              <div className="avatar" style={{ background: 'var(--grnb)' }}>
                <FiUserCheck size={24} />
              </div>
              <div>
                <h4>Disponibilidad Hoy</h4>
                <p className="text-small">{format(new Date(), 'dd/MM/yyyy')}</p>
              </div>
            </div>
            
            <div className="flex-col gap-10 mt-10">
              {disponibilidad && disponibilidad.length > 0 ? (
                <>
                  {disponibilidad.slice(0, 3).map(profesional => {
                    const porcentaje = profesional.porcentaje_ocupacion || 
                      Math.round((profesional.citas_programadas / profesional.max_citas_dia) * 100);
                    
                    return (
                      <div key={profesional.id} className="flex-col gap-5">
                        <div className="flex-row justify-between align-center">
                          <span className="text-small font-bold">
                            {profesional.profesional.split(' ')[1] || profesional.profesional}
                          </span>
                          <span className={`badge ${
                            profesional.estado === 'disponible' ? 'badge-success' :
                            profesional.estado === 'limitado' ? 'badge-warning' :
                            'badge-danger'
                          }`}>
                            {profesional.citas_programadas}/{profesional.max_citas_dia}
                          </span>
                        </div>
                        <div className="progress-container">
                          <div 
                            className="progress-bar" 
                            style={{ 
                              width: `${porcentaje}%`,
                              background: porcentaje > 80 ? 'var(--rr)' : 
                                        porcentaje > 60 ? 'var(--yy)' : 'var(--grnb)'
                            }}
                          ></div>
                        </div>
                        {profesional.cupos_disponibles > 0 && (
                          <div className="text-small text-success flex-row align-center gap-5">
                            <FiCheckCircle size={12} />
                            {profesional.cupos_disponibles} cupo(s) disponible(s)
                          </div>
                        )}
                      </div>
                    );
                  })}
                  {disponibilidad.length > 3 && (
                    <div className="text-center mt-10">
                      <button 
                        className="btn-text btn-text-modal"
                        onClick={() => setShowModalDisponibilidad(true)}
                        style={{ 
                          fontSize: '12px',
                          padding: '6px 12px'
                        }}
                      >
                        Ver todos ({disponibilidad.length} profesionales)
                      </button>
                    </div>
                  )}
                </>
              ) : (
                <div className="text-center p-10">
                  <div className="loading-spinner"></div>
                  <div className="text-small mt-10">Cargando disponibilidad...</div>
                </div>
              )}
            </div>
          </div>
          
          
        </div>
      )}

      <div className="calendar-controls">
        <div className="view-selector">
          <button 
            className={`btn-header ${view === 'day' ? 'active' : ''}`}
            onClick={() => setView('day')}
          >
            <FiCalendar /> D√≠a
          </button>
          <button 
            className={`btn-header ${view === 'week' ? 'active' : ''}`}
            onClick={() => setView('week')}
          >
            <FiCalendar /> Semana
          </button>
        </div>

        <div className="date-navigation">
          <button className="btn-header" onClick={goToPrevious}>
            <FiChevronLeft /> {view === 'day' ? 'Ayer' : 'Sem. anterior'}
          </button>
          
          <div className="current-date">
            <h3>
              {view === 'day' 
                ? formatDateSpanish(selectedDate)
                : getWeekRange()
              }
            </h3>
            <div className="text-small">
              <FiClock className="mr-5" />
              Total citas: {filteredCitas.length}
            </div>
          </div>
          
          <button className="btn-header" onClick={goToNext}>
            {view === 'day' ? 'Ma√±ana' : 'Pr√≥x. semana'} <FiChevronRight />
          </button>
        </div>

        <div className="quick-actions">
          <button className="btn-primary" onClick={goToToday}>
            Hoy
          </button>

        </div>
      </div>

      {/* Filtros - MEJORADO con alineaci√≥n consistente */}
      <div className="filters-container mb-20">

        
        <div className="grid-3 gap-20 mt-15">
          <div className="form-group">
            <label className="form-label">
              <FiUser /> Psic√≥logo
            </label>
            <select 
              value={filterPsicologo} 
              onChange={(e) => setFilterPsicologo(e.target.value)}
              className="select-field"
            >
              <option value="">Todos los psic√≥logos</option>
              {psicologos.map(psicologo => (
                <option key={psicologo.id} value={psicologo.id}>
                  {psicologo.nombre}
                </option>
              ))}
            </select>
          </div>
          
          <div className="form-group">
            <label className="form-label">
              <FiCheckCircle /> Estado
            </label>
            <select 
              value={filterEstado} 
              onChange={(e) => setFilterEstado(e.target.value)}
              className="select-field"
            >
              <option value="">Todos los estados</option>
              <option value="programada">Programadas</option>
              <option value="confirmada">Confirmadas</option>
              <option value="completada">Completadas</option>
              <option value="cancelada">Canceladas</option>
            </select>
          </div>
          
          <div className="form-group">
            <label className="form-label">
              <FiVideo /> Tipo de Consulta
            </label>
            <select 
              value={filtrosAvanzados.tipo_consulta}
              onChange={(e) => handleFiltroAvanzado('tipo_consulta', e.target.value)}
              className="select-field"
            >
              <option value="">Todos los tipos</option>
              <option value="presencial">Presencial</option>
              <option value="virtual">Virtual</option>
            </select>
          </div>
        </div>
        
        {/* Filtros avanzados - MEJORADO */}
        <div className="grid-3 gap-20 mt-20">
          <div className="form-group">
            <label className="form-label">
              <FiCalendar /> Fecha Inicio
            </label>
            <input
              type="date"
              value={filtrosAvanzados.fecha_inicio}
              onChange={(e) => handleFiltroAvanzado('fecha_inicio', e.target.value)}
              className="input-field"
            />
          </div>
          
          <div className="form-group">
            <label className="form-label">
              <FiCalendar /> Fecha Fin
            </label>
            <input
              type="date"
              value={filtrosAvanzados.fecha_fin}
              onChange={(e) => handleFiltroAvanzado('fecha_fin', e.target.value)}
              className="input-field"
            />
          </div>
          
          <div className="form-group">
            <label className="form-label">
              <FiSearch /> Buscar Paciente
            </label>
            <div className="search-box-wrapper">
              <input
                type="text"
                value={searchPaciente}
                onChange={(e) => buscarPaciente(e.target.value)}
                className="input-field"
                placeholder="Nombre o apellido del paciente"
              />
              {filteredPacientes.length > 0 && (
                <div className="search-results">
                  {filteredPacientes.map(paciente => (
                    <div 
                      key={paciente.id}
                      className="search-result-item"
                      onClick={() => seleccionarPaciente(paciente)}
                    >
                      <div className="search-result-name">
                        {paciente.nombre} {paciente.apellido}
                      </div>
                      {paciente.email && (
                        <div className="search-result-email">{paciente.email}</div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Calendario Semanal/Dia */}
      <div className="calendar-week-view" style={{ minHeight: '600px' }}>
        <div className="week-header">
          <div className="time-header"></div>
          {weekDays.map((day) => (
            <div key={day.toISOString()} className="day-header">
              <div className="day-name">
                {format(day, 'EEE', { locale: es })}
              </div>
              <div className="day-number">
                {format(day, 'd')}
              </div>
              <div className="text-small">
                {filteredCitas.filter(c => c.fecha === format(day, 'yyyy-MM-dd')).length} citas
              </div>
            </div>
          ))}
        </div>
        
        <div className="week-body">
          <div className="time-column">
            {generateHours().map(hour => (
              <div key={hour} className="time-slot">{hour}</div>
            ))}
          </div>
          
          {weekDays.map((day) => (
            <div key={day.toISOString()} className="day-column">
              {generateHours().map(hour => {
                const citasHora = getCitasPorDiaYHora(day, hour);
                
                return (
                  <div key={hour} className="hour-cell">
                    {citasHora.slice(0, mostrarTodas ? citasHora.length : 1).map((cita, index) => (
                      <div 
                        key={cita.id}
                        className="week-event"
                        style={{ 
                          backgroundColor: cita.psicologo_color,
                          opacity: 0.85,
                          height: `${100 / (mostrarTodas ? Math.max(citasHora.length, 1) : 1)}%`,
                          top: `${(index / (mostrarTodas ? citasHora.length : 1)) * 100}%`
                        }}
                        onClick={() => showCitaDetalles(cita)}
                        title={`${cita.hora} - ${cita.paciente_nombre} (${cita.psicologo_nombre})`}
                      >
                        <div className="week-event-time">{cita.hora}</div>
                        <div className="week-event-patient">{cita.paciente_nombre}</div>
                        <div className="week-event-psicologo">
                          {cita.psicologo_nombre.split(' ')[1]}
                        </div>
                        <div className="week-event-type">
                          {cita.tipo_consulta === 'virtual' ? <FiVideo /> : <FiMapPin />}
                        </div>
                      </div>
                    ))}
                    {citasHora.length > 1 && !mostrarTodas && (
                      <div 
                        className="week-event-more"
                        onClick={() => setMostrarTodas(true)}
                      >
                        +{citasHora.length - 1} m√°s
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          ))}
        </div>
      </div>

      {/* Resumen por Psic√≥logo */}
      <div className="grid-3 mt-30">
        {psicologos.slice(0, 3).map(psicologo => {
          const citasPsicologo = filteredCitas.filter(c => c.psicologo_id === psicologo.id);
          const citasHoy = citasPsicologo.filter(c => c.fecha === format(new Date(), 'yyyy-MM-dd')).length;
          
          return (
            <div key={psicologo.id} className="card">
              <div className="flex-row align-center gap-10 mb-10">
                <div 
                  className="avatar" 
                  style={{ background: psicologo.color }}
                >
                  {psicologo.nombre.split(' ').map(n => n[0]).join('')}
                </div>
                <div className="flex-1">
                  <h4>{psicologo.nombre}</h4>
                  <p className="text-small">{psicologo.especialidad}</p>
                  <p className="text-small">
                    <FiMail /> {psicologo.email}
                  </p>
                </div>
              </div>
              
              <div className="grid-2 gap-10">
                <div>
                  <div className="text-small">Citas totales</div>
                  <div className="font-bold">{citasPsicologo.length}</div>
                </div>
                <div>
                  <div className="text-small">Citas hoy</div>
                  <div className="font-bold">{citasHoy}</div>
                </div>
                <div>
                  <div className="text-small">Confirmadas</div>
                  <div className="font-bold">{citasPsicologo.filter(c => c.estado === 'confirmada').length}</div>
                </div>
                <div>
                  <div className="text-small">Con becario</div>
                  <div className="font-bold">{citasPsicologo.filter(c => c.becario_nombre).length}</div>
                </div>
              </div>
            </div>
          );
        })}
      </div>

      {/* Modal de Detalles de Cita */}
      {showDetalles && selectedCita && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3>Detalles de Cita</h3>
              <button className="modal-close" onClick={() => setShowDetalles(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="detail-row">
                <strong>Paciente:</strong>
                <span>{selectedCita.paciente_nombre}</span>
              </div>
              
              {selectedCita.telefono && (
                <div className="detail-row">
                  <strong>Tel√©fono:</strong>
                  <span><FiPhone /> {selectedCita.telefono}</span>
                </div>
              )}
              
              <div className="detail-row">
                <strong>Fecha y hora:</strong>
                <span>{selectedCita.fecha} {selectedCita.hora}</span>
              </div>
              
              <div className="detail-row">
                <strong>Psic√≥logo:</strong>
                <div className="flex-row align-center gap-5">
                  <div 
                    className="avatar-small" 
                    style={{ background: selectedCita.psicologo_color }}
                  >
                    {selectedCita.psicologo_nombre.split(' ').map(n => n[0]).join('')}
                  </div>
                  <span>{selectedCita.psicologo_nombre}</span>
                </div>
              </div>
              
              <div className="detail-row">
                <strong>Tipo:</strong>
                <span className="flex-row align-center gap-5">
                  {selectedCita.tipo_consulta === 'virtual' ? <FiVideo /> : <FiMapPin />}
                  {selectedCita.tipo_consulta === 'presencial' ? 'Presencial' : 'Virtual'}
                </span>
              </div>
              
              <div className="detail-row">
                <strong>Estado:</strong>
                <span className={`badge ${
                  selectedCita.estado === 'confirmada' ? 'badge-success' :
                  selectedCita.estado === 'completada' ? 'badge-primary' :
                  selectedCita.estado === 'programada' ? 'badge-warning' :
                  'badge-danger'
                }`}>
                  {selectedCita.estado}
                </span>
              </div>
              
              {selectedCita.becario_nombre && (
                <div className="detail-row">
                  <strong>Becario asignado:</strong>
                  <span>{selectedCita.becario_nombre}</span>
                </div>
              )}
              
              <div className="detail-row">
                <strong>Duraci√≥n:</strong>
                <span>{selectedCita.duracion} minutos</span>
              </div>
              
              {selectedCita.notas && (
                <div className="detail-row notes">
                  <strong>Notas:</strong>
                  <p>{selectedCita.notas}</p>
                </div>
              )}
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowDetalles(false)}>
                Cerrar
              </button>
              <button className="btn-primary">
                Ver Expediente
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Modal de Disponibilidad Completa - M√ÅS ANCHO */}
      {showModalDisponibilidad && (
        <div className="modal-overlay">
          <div className="modal-container modal-extra-large">
            <div className="modal-header">
              <div className="flex-row align-center gap-15">
                <div className="avatar" style={{ background: 'var(--grnb)' }}>
                  <FiUserCheck size={24} />
                </div>
                <div>
                  <h3>Disponibilidad Completa</h3>
                  <p className="text-small">{format(new Date(), 'EEEE dd/MM/yyyy', { locale: es })}</p>
                </div>
              </div>
              <button 
                className="modal-close" 
                onClick={() => setShowModalDisponibilidad(false)}
              >
                √ó
              </button>
            </div>
            
            <div className="modal-content">
              {/* Estad√≠sticas r√°pidas */}
              {disponibilidad && disponibilidad.length > 0 && (
                <div className="modal-stats-grid">
                  <div className="stat-item">
                    <div className="stat-value">{disponibilidad.length}</div>
                    <div className="stat-label">Profesionales</div>
                  </div>
                  <div className="stat-item">
                    <div className="stat-value text-success">
                      {disponibilidad.filter(p => p.estado === 'disponible').length}
                    </div>
                    <div className="stat-label">Disponibles</div>
                  </div>
                  <div className="stat-item">
                    <div className="stat-value text-warning">
                      {disponibilidad.filter(p => p.estado === 'limitado').length}
                    </div>
                    <div className="stat-label">Limitados</div>
                  </div>
                  <div className="stat-item">
                    <div className="stat-value text-danger">
                      {disponibilidad.filter(p => p.estado === 'completo').length}
                    </div>
                    <div className="stat-label">Completos</div>
                  </div>
                </div>
              )}
              
              <div className="scrollable" style={{ maxHeight: '60vh' }}>
                {disponibilidad && disponibilidad.length > 0 ? (
                  <div className="table-container">
                    <table className="data-table wide-table">
                      <thead>
                        <tr>
                          <th style={{ width: '25%' }}>Profesional</th>
                          <th style={{ width: '10%' }}>Rol</th>
                          <th style={{ width: '20%' }}>Especialidad</th>
                          <th style={{ width: '15%' }}>Horario</th>
                          <th style={{ width: '15%' }}>Citas / Cupos</th>
                          <th style={{ width: '15%' }}>Disponibilidad</th>
                        </tr>
                      </thead>
                      <tbody>
                        {disponibilidad.map(profesional => {
                          const porcentaje = profesional.porcentaje_ocupacion || 
                            Math.round((profesional.citas_programadas / profesional.max_citas_dia) * 100);
                          
                          return (
                            <tr key={profesional.id}>
                              <td>
                                <div className="flex-row align-center gap-10">
                                  <div className="avatar-small">
                                    {profesional.profesional.split(' ').map(n => n[0]).join('')}
                                  </div>
                                  <div>
                                    <div className="font-bold">{profesional.profesional}</div>
                                    <div className="text-small">{profesional.email}</div>
                                  </div>
                                </div>
                              </td>
                              <td>
                                <span className={`badge ${
                                  profesional.rol === 'psicologo' ? 'badge-info' : 'badge-warning'
                                }`}>
                                  {profesional.rol}
                                </span>
                              </td>
                              <td>
                                <div className="text-small">{profesional.especialidad}</div>
                              </td>
                              <td>
                                <div className="text-small">
                                  {profesional.hora_inicio} - {profesional.hora_fin}
                                </div>
                              </td>
                              <td>
                                <div className="flex-col gap-5">
                                  <div className="flex-row justify-between">
                                    <span className="text-small">Citas:</span>
                                    <span className="font-bold">{profesional.citas_programadas}/{profesional.max_citas_dia}</span>
                                  </div>
                                  <div className="flex-row justify-between">
                                    <span className="text-small">Cupos:</span>
                                    <span className={`font-bold ${
                                      profesional.cupos_disponibles > 0 ? 'text-success' : 'text-danger'
                                    }`}>
                                      {profesional.cupos_disponibles}
                                    </span>
                                  </div>
                                </div>
                              </td>
                              <td>
                                <div className="flex-col gap-5">
                                  <div className="progress-container">
                                    <div 
                                      className="progress-bar" 
                                      style={{ 
                                        width: `${porcentaje}%`,
                                        background: porcentaje > 80 ? 'var(--rr)' : 
                                                  porcentaje > 60 ? 'var(--yy)' : 'var(--grnb)'
                                      }}
                                    ></div>
                                  </div>
                                  <div className="flex-row justify-between">
                                    <span className="text-small">{porcentaje}% ocupado</span>
                                    <span className={`badge ${
                                      profesional.estado === 'disponible' ? 'badge-success' :
                                      profesional.estado === 'limitado' ? 'badge-warning' :
                                      'badge-danger'
                                    }`}>
                                      {profesional.estado}
                                    </span>
                                  </div>
                                </div>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                ) : (
                  <div className="text-center p-20">
                    <div className="loading-spinner"></div>
                    <div className="text-small mt-10">Cargando disponibilidad...</div>
                  </div>
                )}
              </div>
            </div>
            
            <div className="modal-footer">
              <button 
                className="btn-secondary" 
                onClick={() => setShowModalDisponibilidad(false)}
              >Cerrar
              </button>

            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoordinadorAgenda;

/frontend\src\pages\coordinador\AltasPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiTrendingUp, FiCheckCircle, FiXCircle, FiFilter,
  FiSearch, FiCalendar, FiUser, FiFileText, FiDownload,
  FiUsers, FiActivity, FiBarChart2, FiClock
} from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';
import ApiService from '../../services/api';

const CoordinadorAltas = () => {
  const [altas, setAltas] = useState([]);
  const [candidatosAlta, setCandidatosAlta] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filtroEstado, setFiltroEstado] = useState('');
  const [filtroMes, setFiltroMes] = useState('');
  
  // Estados para el modal de dar de alta
  const [showModalAlta, setShowModalAlta] = useState(false);
  const [selectedPacienteAlta, setSelectedPacienteAlta] = useState(null);
  
  // Estados para el modal de ver detalles
  const [showModalDetalles, setShowModalDetalles] = useState(false);
  const [selectedAltaDetalles, setSelectedAltaDetalles] = useState(null);
  
  const [estadisticas, setEstadisticas] = useState({});
  const [formData, setFormData] = useState({
    paciente_id: '',
    tipo_alta: '',
    motivo_detallado: '',
    recomendaciones: '',
    evaluacion_final: '',
    seguimiento_recomendado: false,
    fecha_seguimiento: ''
  });

  useEffect(() => {
    fetchAltas();
    fetchEstadisticas();
    fetchCandidatosAlta();
  }, []);

  const fetchAltas = async () => {
    try {
      setLoading(true);
      const response = await ApiService.get('/altas');
      if (response.success) {
        setAltas(response.data);
      } else {
        notifications.error(response.message || 'Error al cargar las altas');
      }
    } catch (error) {
      console.error('Error cargando altas:', error);
      notifications.error('Error al cargar el historial de altas');
    } finally {
      setLoading(false);
    }
  };

  const fetchCandidatosAlta = async () => {
    try {
      const response = await ApiService.get('/pacientes/candidatos-alta');
      if (response.success) {
        setCandidatosAlta(response.data.map(paciente => ({
          id: paciente.id,
          paciente_nombre: paciente.paciente_nombre,
          edad: paciente.edad || 'N/A',
          motivo_consulta: paciente.motivo_consulta || 'Sin informaci√≥n',
          fecha_ingreso: paciente.fecha_ingreso,
          sesiones_completadas: paciente.sesiones_completadas || 0,
          progreso: Math.min(100, paciente.progreso_estimado || 0),
          psicologo: paciente.psicologo_nombre || 'Sin asignar',
          becario: paciente.becario_nombre || 'No asignado',
          recomendacion: paciente.sesiones_completadas >= 10 
            ? 'Posible alta en 1-2 sesiones m√°s' 
            : 'Evaluar en pr√≥xima revisi√≥n'
        })));
      }
    } catch (error) {
      console.error('Error cargando candidatos:', error);
      notifications.error('Error al cargar candidatos a alta');
    }
  };

  const fetchEstadisticas = async () => {
    try {
      const response = await ApiService.get('/altas/estadisticas');
      if (response.success) {
        setEstadisticas(response.data);
      }
    } catch (error) {
      console.error('Error cargando estad√≠sticas:', error);
    }
  };

  const procesarAlta = async (pacienteId, decision) => {
    try {
      if (decision === 'aprobar') {
        const paciente = candidatosAlta.find(p => p.id === pacienteId);
        if (paciente) {
          setFormData({
            paciente_id: paciente.id,
            tipo_alta: 'terapeutica',
            motivo_detallado: '',
            recomendaciones: '',
            evaluacion_final: '',
            seguimiento_recomendado: false,
            fecha_seguimiento: ''
          });
          setSelectedPacienteAlta(paciente);
          setShowModalAlta(true);
        }
      } else {
        const confirmado = await confirmations.danger(
          '¬øEst√°s seguro de marcar este paciente como "No Aprobar"? ' +
          'El paciente no ser√° mostrado como candidato a alta por 30 d√≠as.'
        );
        
        if (confirmado) {
          try {
            console.log(`üì§ Enviando solicitud para marcar paciente ${pacienteId} como no aprobado...`);
            
            // Llamar al endpoint
            const response = await ApiService.post(`/pacientes/${pacienteId}/no-aprobar-alta`);
            
            if (response.success) {
              notifications.success(`‚úÖ ${response.message}`);
              console.log('‚úÖ Respuesta del backend:', response.data);
              
              // 1. Eliminar inmediatamente del estado local
              setCandidatosAlta(prev => prev.filter(p => p.id !== pacienteId));
              
              // 2. Recargar despu√©s de 2 segundos para confirmar
              setTimeout(async () => {
                console.log('üîÑ Recargando lista de candidatos...');
                await fetchCandidatosAlta();
              }, 2000);
            } else {
              notifications.error(`‚ùå ${response.message || 'Error desconocido'}`);
            }
          } catch (error) {
            console.error('‚ùå Error al marcar como no aprobado:', error);
            notifications.error(`‚ùå Error: ${error.message || 'Error de conexi√≥n'}`);
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Error en el proceso de alta:', error);
      notifications.error('‚ùå Ocurri√≥ un error al procesar la solicitud');
    }
  };

  const handleSubmitAlta = async (e) => {
    e.preventDefault();
    
    try {
      const confirmado = await confirmations.warning(
        '¬øEst√°s seguro de dar de alta a este paciente? Esta acci√≥n no se puede deshacer.'
      );
      
      if (!confirmado) return;

      const response = await ApiService.post('/altas', formData);
      
      if (response.success) {
        notifications.success(response.message || 'Paciente dado de alta exitosamente');
        
        // Actualizar listas
        setAltas([response.data.alta, ...altas]);
        
        // Recargar la lista de candidatos (para que desaparezca de la lista)
        await fetchCandidatosAlta();
        
        // Recargar estad√≠sticas
        await fetchEstadisticas();
        
        // Limpiar y cerrar modal
        setFormData({
          paciente_id: '',
          tipo_alta: '',
          motivo_detallado: '',
          recomendaciones: '',
          evaluacion_final: '',
          seguimiento_recomendado: false,
          fecha_seguimiento: ''
        });
        setShowModalAlta(false);
        setSelectedPacienteAlta(null);
      } else {
        notifications.error(response.message || 'Error al dar de alta');
      }
    } catch (error) {
      console.error('Error al dar de alta:', error);
      notifications.error('Error al procesar el alta del paciente');
    }
  };

  const handleFilterChange = async () => {
    try {
      setLoading(true);
      let url = '/altas?';
      const params = [];
      
      if (filtroEstado) params.push(`tipo_alta=${filtroEstado}`);
      if (filtroMes) {
        const year = new Date().getFullYear();
        params.push(`fecha_inicio=${year}-${parseInt(filtroMes) + 1}-01`);
        params.push(`fecha_fin=${year}-${parseInt(filtroMes) + 1}-31`);
      }
      
      if (params.length > 0) {
        url += params.join('&');
      }
      
      const response = await ApiService.get(url);
      if (response.success) {
        setAltas(response.data);
      }
    } catch (error) {
      console.error('Error aplicando filtros:', error);
    } finally {
      setLoading(false);
    }
  };

  const exportarReporteAltas = async () => {
    try {
      notifications.info('Generando reporte de altas...');
      
      // Obtener fechas del filtro actual
      const params = new URLSearchParams();
      if (filtroMes) {
        const year = new Date().getFullYear();
        const month = parseInt(filtroMes) + 1;
        params.append('fecha_inicio', `${year}-${month.toString().padStart(2, '0')}-01`);
        params.append('fecha_fin', `${year}-${month.toString().padStart(2, '0')}-31`);
      }
      if (filtroEstado) {
        params.append('tipo_alta', filtroEstado);
      }
      
      const response = await ApiService.get(`/reportes/altas?formato=excel&${params.toString()}`);
      
      if (response.success && response.data.archivo_url) {
        notifications.success(`Reporte generado exitosamente (${response.data.total_registros} registros)`);
      } else {
        notifications.error('Error al generar el reporte');
      }
    } catch (error) {
      console.error('Error exportando reporte:', error);
      notifications.error('Error al generar el reporte de altas');
    }
  };

  const getTipoAltaLabel = (tipo) => {
    switch (tipo) {
        case 'terapeutica':
            return { text: 'Alta Terap√©utica', color: 'success', icon: '‚úÖ' };
        case 'abandono':
            return { text: 'Abandono', color: 'danger', icon: '‚ùå' };
        case 'traslado':
            return { text: 'Traslado', color: 'warning', icon: 'üîÑ' };
        case 'graduacion':
            return { text: 'Graduaci√≥n', color: 'primary', icon: 'üéì' };
        case 'no_continua':
            return { text: 'No Contin√∫a', color: 'info', icon: '‚è∏Ô∏è' };
        case 'no_aprobado':
            return { text: 'No Aprobado', color: 'danger', icon: 'üö´' };
        case 'otro':
            return { text: 'Otro', color: 'info', icon: 'üìã' };
        default:
            return { text: tipo, color: 'info', icon: 'üìã' };
    }
  };

  const calcularSatisfaccion = (paciente) => {
    if (paciente.tipo_alta === 'terapeutica') {
      return Math.min(5, Math.floor((paciente.sesiones_totales || 0) / 4) + 3);
    } else if (paciente.tipo_alta === 'abandono') {
      return 1;
    } else {
      return 3;
    }
  };

  if (loading && altas.length === 0) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando seguimiento de altas...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Seguimiento de Altas</h1>
          <p>Gesti√≥n y seguimiento de altas terap√©uticas</p>
        </div>
      </div>

      {/* Estad√≠sticas de Altas */}
      <div className="grid-4 mb-30">
        <div className="card">
          <div className="stat-box">
            <div className="stat-icon">
              <FiUsers />
            </div>
            <div className="stat-content">
              <div className="stat-value">{estadisticas.totales?.total_altas || 0}</div>
              <div className="stat-label">Total de Altas</div>
            </div>
          </div>
        </div>
        
        <div className="card">
          <div className="stat-box">
            <div className="stat-icon">
              <FiCheckCircle />
            </div>
            <div className="stat-content">
              <div className="stat-value">
                {estadisticas.estadisticas?.find(e => e.tipo_alta === 'terapeutica')?.total || 0}
              </div>
              <div className="stat-label">Altas Terap√©uticas</div>
            </div>
          </div>
        </div>
        
        <div className="card">
          <div className="stat-box">
            <div className="stat-icon">
              <FiClock />
            </div>
            <div className="stat-content">
              <div className="stat-value">
                {estadisticas.totales?.promedio_sesiones_global || 0}
              </div>
              <div className="stat-label">Sesiones Promedio</div>
            </div>
          </div>
        </div>
        
        <div className="card">
          <div className="stat-box">
            <div className="stat-icon">
              <FiTrendingUp />
            </div>
            <div className="stat-content">
              <div className="stat-value">{candidatosAlta.length}</div>
              <div className="stat-label">Candidatos a Alta</div>
            </div>
          </div>
        </div>
      </div>

      {/* Candidatos a Alta */}
      <div className="dashboard-section mb-30">
        <div className="section-header">
          <h3>Candidatos a Alta ({candidatosAlta.length})</h3>
        </div>
        
        {candidatosAlta.length > 0 ? (
          <div className="grid-2">
            {candidatosAlta.map((paciente) => (
              <div key={paciente.id} className="card">
                <div className="flex-row align-center justify-between mb-15">
                  <div className="flex-row align-center gap-10">
                    <div className="avatar">
                      {paciente.paciente_nombre.split(' ').map(n => n[0]).join('')}
                    </div>
                    <div>
                      <h4>{paciente.paciente_nombre}</h4>
                      <p className="text-small">{paciente.edad} a√±os ‚Ä¢ {paciente.motivo_consulta}</p>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="font-bold">{paciente.progreso}%</div>
                    <div className="text-small">progreso</div>
                  </div>
                </div>
                
                <div className="mb-15">
                  <div className="card-progress-label">
                    <span>{paciente.sesiones_completadas} sesiones</span>
                    <span>{paciente.progreso}%</span>
                  </div>
                  <div className="progress-container">
                    <div 
                      className="progress-bar"
                      style={{ width: `${paciente.progreso}%` }}
                    ></div>
                  </div>
                </div>
                
                <div className="grid-2 gap-10 mb-15">
                  <div>
                    <div className="text-small">Psic√≥logo</div>
                    <div className="font-bold">{paciente.psicologo}</div>
                  </div>
                  <div>
                    <div className="text-small">Becario</div>
                    <div className="font-bold">{paciente.becario || 'No asignado'}</div>
                  </div>
                </div>
                
                <div className="mb-15">
                  <div className="text-small">Recomendaci√≥n</div>
                  <div className="font-bold text-success">{paciente.recomendacion}</div>
                </div>
                
                <div className="flex-row gap-10">
                  <button 
                    className="btn-primary flex-1"
                    onClick={() => procesarAlta(paciente.id, 'aprobar')}
                  >
                    <FiCheckCircle /> Procesar Alta
                  </button>
                  <button 
                    className="btn-danger flex-1"
                    onClick={() => procesarAlta(paciente.id, 'rechazar')}
                  >
                    <FiXCircle /> No Aprobar
                  </button>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">‚úÖ</div>
            <div>No hay candidatos a alta pendientes</div>
            <p className="text-small mt-10">Los psic√≥logos propondr√°n pacientes para alta cuando est√©n listos</p>
          </div>
        )}
      </div>

      {/* Historial de Altas */}
      <div className="dashboard-section">
        <div className="section-header">
          <h3>Historial de Altas ({altas.length})</h3>
          <div className="flex-row gap-10">
            <select 
              value={filtroEstado} 
              onChange={(e) => setFiltroEstado(e.target.value)}
              className="select-field"
              style={{ width: '180px' }}
            >
              <option value="">Todos los tipos</option>
              <option value="terapeutica">Altas Terap√©uticas</option>
              <option value="abandono">Abandonos</option>
              <option value="traslado">Traslados</option>
              <option value="graduacion">Graduaciones</option>
              <option value="no_continua">No Contin√∫a</option>
              <option value="no_aprobado">No Aprobado</option>
              <option value="otro">Otro</option>
            </select>
            
            <select 
              value={filtroMes} 
              onChange={(e) => setFiltroMes(e.target.value)}
              className="select-field"
              style={{ width: '150px' }}
            >
              <option value="">Todos los meses</option>
              <option value="0">Enero</option>
              <option value="1">Febrero</option>
              <option value="2">Marzo</option>
              <option value="3">Abril</option>
              <option value="4">Mayo</option>
              <option value="5">Junio</option>
              <option value="6">Julio</option>
              <option value="7">Agosto</option>
              <option value="8">Septiembre</option>
              <option value="9">Octubre</option>
              <option value="10">Noviembre</option>
              <option value="11">Diciembre</option>
            </select>
            
            <button 
              className="btn-secondary" 
              onClick={handleFilterChange}
              disabled={loading}
            >
              <FiFilter /> Aplicar
            </button>
          </div>
        </div>
        
        {loading ? (
          <div className="loading-container" style={{ minHeight: '200px' }}>
            <div className="loading-spinner"></div>
            <div className="loading-text">Cargando altas...</div>
          </div>
        ) : (
          <div className="table-container">
            <table className="data-table">
              <thead>
                <tr>
                  <th>Paciente</th>
                  <th>Tipo de Alta</th>
                  <th>Fecha Alta</th>
                  <th>Sesiones</th>
                  <th>Profesional</th>
                  <th>Acciones</th>
                </tr>
              </thead>
              <tbody>
                {altas.map((alta) => {
                  const tipoInfo = getTipoAltaLabel(alta.tipo_alta);
                  const satisfaccion = calcularSatisfaccion(alta);
                  
                  return (
                    <tr key={alta.id}>
                      <td>
                        <div className="flex-row align-center gap-10">
                          <div className="avatar-small">
                            {(alta.paciente_nombre || '').split(' ').map(n => n[0]).join('')}
                          </div>
                          <div>
                            <div className="font-bold">
                              {alta.paciente_nombre || 'Nombre no disponible'} {alta.paciente_apellido || ''}
                            </div>
                            <div className="text-small">
                              {alta.motivo_detallado?.substring(0, 30) || 'Sin motivo espec√≠fico'}...
                            </div>
                          </div>
                        </div>
                      </td>
                      <td>
                        <span className={`badge badge-${tipoInfo.color}`}>
                          {tipoInfo.icon} {tipoInfo.text}
                        </span>
                      </td>
                      <td>
                        <div className="font-bold">
                          {new Date(alta.fecha_alta).toLocaleDateString()}
                        </div>
                        <div className="text-small">
                          Por: {alta.usuario_nombre} {alta.usuario_apellido}
                        </div>
                      </td>
                      <td>
                        <div className="font-bold">{alta.sesiones_totales || 0}</div>
                        <div className="text-small">sesiones</div>
                      </td>
                      <td>
                        <div className="text-small">Satisfacci√≥n:</div>
                        <div className="flex-row align-center gap-5">
                          {'‚òÖ'.repeat(satisfaccion)}
                          {'‚òÜ'.repeat(5 - satisfaccion)}
                          <span className="ml-5">({satisfaccion}/5)</span>
                        </div>
                      </td>
                      <td>
                        <div className="flex-row gap-5">
                          <button 
                            className="btn-text"
                            onClick={async () => {
                              try {
                                console.log(`üìã Solicitando detalles del alta ID: ${alta.id}`);
                                const response = await ApiService.get(`/altas/${alta.id}`);
                                console.log('üìä Respuesta de detalles:', response);
                                
                                if (response.success) {
                                  setSelectedAltaDetalles(response.data);
                                  setShowModalDetalles(true);
                                } else {
                                  notifications.error('No se pudieron cargar los detalles del alta');
                                }
                              } catch (error) {
                                console.error('‚ùå Error al cargar detalles:', error);
                                notifications.error('Error al cargar detalles: ' + error.message);
                              }
                            }}
                          >
                            <FiFileText /> Ver
                          </button>
                        </div>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Modal de Alta */}
      {showModalAlta && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>Procesar Alta</h3>
              <button className="modal-close" onClick={() => {
                setShowModalAlta(false);
                setSelectedPacienteAlta(null);
              }}>√ó</button>
            </div>
            
            <form onSubmit={handleSubmitAlta}>
              <div className="modal-content">
                {selectedPacienteAlta && (
                  <div className="alert-message info mb-20">
                    <strong>Paciente:</strong> {selectedPacienteAlta.paciente_nombre}
                    <br />
                    <strong>Psic√≥logo asignado:</strong> {selectedPacienteAlta.psicologo}
                    <br />
                    <strong>Sesiones completadas:</strong> {selectedPacienteAlta.sesiones_completadas}
                  </div>
                )}
                
                <div className="grid-2 gap-20">
                  <div className="form-group">
                    <label>Tipo de Alta *</label>
                    <select
                      value={formData.tipo_alta}
                      onChange={(e) => setFormData({...formData, tipo_alta: e.target.value})}
                      className="select-field"
                      required
                    >
                      <option value="">Seleccionar tipo</option>
                      <option value="terapeutica">Alta Terap√©utica</option>
                      <option value="abandono">Abandono</option>
                      <option value="traslado">Traslado</option>
                      <option value="graduacion">Graduaci√≥n</option>
                      <option value="no_continua">No Contin√∫a</option>
                      <option value="otro">Otro</option>
                    </select>
                  </div>
                  
                  <div className="form-group">
                    <label>Evaluaci√≥n Final</label>
                    <select
                      value={formData.evaluacion_final}
                      onChange={(e) => setFormData({...formData, evaluacion_final: e.target.value})}
                      className="select-field"
                    >
                      <option value="">Seleccionar evaluaci√≥n</option>
                      <option value="excelente">Excelente</option>
                      <option value="buena">Buena</option>
                      <option value="regular">Regular</option>
                      <option value="mala">Mala</option>
                    </select>
                  </div>
                </div>
                
                <div className="form-group mt-15">
                  <label>Motivo Detallado *</label>
                  <textarea
                    value={formData.motivo_detallado}
                    onChange={(e) => setFormData({...formData, motivo_detallado: e.target.value})}
                    className="textarea-field"
                    rows="4"
                    placeholder="Describa el motivo del alta..."
                    required
                  />
                </div>
                
                <div className="form-group mt-15">
                  <label>Recomendaciones</label>
                  <textarea
                    value={formData.recomendaciones}
                    onChange={(e) => setFormData({...formData, recomendaciones: e.target.value})}
                    className="textarea-field"
                    rows="3"
                    placeholder="Recomendaciones para el paciente..."
                  />
                </div>
                
                <div className="grid-2 gap-20 mt-15">
                  <div className="form-group">
                    <label className="flex-row align-center gap-10">
                      <input
                        type="checkbox"
                        checked={formData.seguimiento_recomendado}
                        onChange={(e) => setFormData({...formData, seguimiento_recomendado: e.target.checked})}
                      />
                      Seguimiento Recomendado
                    </label>
                  </div>
                  
                  {formData.seguimiento_recomendado && (
                    <div className="form-group">
                      <label>Fecha de Seguimiento</label>
                      <input
                        type="date"
                        value={formData.fecha_seguimiento}
                        onChange={(e) => setFormData({...formData, fecha_seguimiento: e.target.value})}
                        className="input-field"
                        min={new Date().toISOString().split('T')[0]}
                      />
                    </div>
                  )}
                </div>
              </div>
              
              <div className="modal-footer">
                <button 
                  type="button" 
                  className="btn-secondary"
                  onClick={() => {
                    setShowModalAlta(false);  // ‚úÖ CORREGIDO
                    setSelectedPacienteAlta(null);  // ‚úÖ CORREGIDO
                  }}
                >
                  Cancelar
                </button>
                <button 
                  type="submit" 
                  className="btn-primary"
                  disabled={!formData.tipo_alta || !formData.motivo_detallado}
                >
                  <FiCheckCircle /> Confirmar Alta
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
      
      {/* Modal de Detalles de Alta */}
      {showModalDetalles && selectedAltaDetalles && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>
                {selectedAltaDetalles.tipo_alta === 'no_aprobado' 
                  ? 'Detalles de No Aprobaci√≥n' 
                  : 'Detalles de Alta'}
              </h3>
              <button className="modal-close" onClick={() => {
                setShowModalDetalles(false);
                setSelectedAltaDetalles(null);
              }}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="grid-2 gap-20">
                <div>
                  <h4>Informaci√≥n del Paciente</h4>
                  <div className="detail-row">
                    <strong>Nombre:</strong> {selectedAltaDetalles.paciente_nombre} {selectedAltaDetalles.paciente_apellido}
                  </div>
                  <div className="detail-row">
                    <strong>Edad:</strong> {selectedAltaDetalles.edad || 'N/A'} a√±os
                  </div>
                  <div className="detail-row">
                    <strong>Motivo de consulta:</strong> {selectedAltaDetalles.motivo_consulta || 'Sin informaci√≥n'}
                  </div>
                  <div className="detail-row">
                    <strong>Fecha:</strong> 
                    <div>
                      {selectedAltaDetalles.tipo_alta === 'no_aprobado' 
                        ? 'No aprobado: ' 
                        : 'Alta: '}
                      {new Date(selectedAltaDetalles.fecha_alta).toLocaleDateString()}
                    </div>
                  </div>
                </div>
                
                <div>
                  <h4>Informaci√≥n del Proceso</h4>
                  <div className="detail-row">
                    <strong>Tipo:</strong>
                    <span className={`badge badge-${getTipoAltaLabel(selectedAltaDetalles.tipo_alta).color}`}>
                      {getTipoAltaLabel(selectedAltaDetalles.tipo_alta).icon} 
                      {getTipoAltaLabel(selectedAltaDetalles.tipo_alta).text}
                    </span>
                  </div>
                  <div className="detail-row">
                    <strong>Profesional:</strong> {selectedAltaDetalles.usuario_nombre} {selectedAltaDetalles.usuario_apellido}
                  </div>
                  <div className="detail-row">
                    <strong>Sesiones completadas:</strong> {selectedAltaDetalles.sesiones_totales || 0}
                  </div>
                  {selectedAltaDetalles.psicologo_nombre && (
                    <div className="detail-row">
                      <strong>Psic√≥logo asignado:</strong> {selectedAltaDetalles.psicologo_nombre}
                    </div>
                  )}
                  {selectedAltaDetalles.evaluacion_final && (
                    <div className="detail-row">
                      <strong>Evaluaci√≥n final:</strong> {selectedAltaDetalles.evaluacion_final}
                    </div>
                  )}
                </div>
              </div>
              
              <div className="mt-20">
                <h4>
                  {selectedAltaDetalles.tipo_alta === 'no_aprobado' 
                    ? 'Motivo de No Aprobaci√≥n' 
                    : 'Motivo Detallado'}
                </h4>
                <div className="card p-15 mt-10">
                  {selectedAltaDetalles.motivo_detallado || 'Sin informaci√≥n disponible'}
                </div>
              </div>
              
              {selectedAltaDetalles.recomendaciones && (
                <div className="mt-20">
                  <h4>Recomendaciones</h4>
                  <div className="card p-15 mt-10">
                    {selectedAltaDetalles.recomendaciones}
                  </div>
                </div>
              )}
              
              {selectedAltaDetalles.tipo_alta === 'no_aprobado' && (
                <div className="mt-20 alert-message warning">
                  <strong>‚ö†Ô∏è Nota:</strong> Este paciente fue marcado como "No Aprobado" para alta terap√©utica. 
                  Continuar√° en tratamiento y podr√° ser evaluado nuevamente en el futuro.
                </div>
              )}
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => {
                setShowModalDetalles(false);
                setSelectedAltaDetalles(null);
              }}>
                Cerrar
              </button>
              {selectedAltaDetalles.tipo_alta !== 'no_aprobado' && (
                <button className="btn-primary" onClick={() => {
                  notifications.info('Generando informe...');
                }}>
                  <FiDownload /> Descargar Informe
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoordinadorAltas;

/frontend\src\pages\coordinador\AsignacionesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiUsers, FiUserPlus, FiCheckCircle, FiXCircle, 
  FiRefreshCw, FiSearch, FiFilter, FiEdit2
} from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const CoordinadorAsignaciones = () => {
  const [becarios, setBecarios] = useState([]);
  const [psicologos, setPsicologos] = useState([]);
  const [pacientesSinAsignar, setPacientesSinAsignar] = useState([]);
  const [asignaciones, setAsignaciones] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [selectedBecario, setSelectedBecario] = useState(null);
  const [selectedPaciente, setSelectedPaciente] = useState(null);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      
      // Simulaci√≥n de datos
      setTimeout(() => {
        setBecarios([
          { id: 1, nombre: 'Juan P√©rez', especialidad: 'Practicante', pacientes_asignados: 3, capacidad: 5, activo: true },
          { id: 2, nombre: 'Sof√≠a Ram√≠rez', especialidad: 'Practicante', pacientes_asignados: 2, capacidad: 4, activo: true },
          { id: 3, nombre: 'Pedro Hern√°ndez', especialidad: 'Practicante', pacientes_asignados: 1, capacidad: 3, activo: true },
          { id: 4, nombre: 'Nuevo Becario', especialidad: 'Practicante', pacientes_asignados: 0, capacidad: 3, activo: false }
        ]);

        setPsicologos([
          { id: 1, nombre: 'Lic. Luis Fern√°ndez', especialidad: 'TCC', pacientes_total: 12 },
          { id: 2, nombre: 'Lic. Laura Guti√©rrez', especialidad: 'Terapia Familiar', pacientes_total: 8 }
        ]);

        setPacientesSinAsignar([
          { id: 1, nombre: 'Ana Rodr√≠guez', motivo: 'Depresi√≥n', fecha_ingreso: '2024-01-05' },
          { id: 2, nombre: 'Carlos Mart√≠nez', motivo: 'Ansiedad social', fecha_ingreso: '2024-01-08' },
          { id: 3, nombre: 'Mar√≠a Gonz√°lez', motivo: 'Estr√©s postraum√°tico', fecha_ingreso: '2024-01-10' }
        ]);

        setAsignaciones([
          { id: 1, paciente: 'Carlos G√≥mez', becario: 'Juan P√©rez', psicologo: 'Lic. Luis Fern√°ndez', fecha_asignacion: '2023-10-15', estado: 'activa' },
          { id: 2, paciente: 'Mariana L√≥pez', becario: 'Sof√≠a Ram√≠rez', psicologo: 'Lic. Luis Fern√°ndez', fecha_asignacion: '2023-11-20', estado: 'activa' },
          { id: 3, paciente: 'Roberto S√°nchez', becario: 'Pedro Hern√°ndez', psicologo: 'Lic. Luis Fern√°ndez', fecha_asignacion: '2023-12-05', estado: 'activa' },
          { id: 4, paciente: 'Antonio Silva', becario: 'Juan P√©rez', psicologo: 'Lic. Laura Guti√©rrez', fecha_asignacion: '2024-01-03', estado: 'finalizada' }
        ]);

        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error cargando asignaciones:', error);
      setLoading(false);
    }
  };

  const handleAsignarPaciente = (pacienteId, becarioId) => {
    // L√≥gica para asignar paciente
    notifications.success(`Paciente asignado exitosamente al becario`);
    setShowModal(false);
  };

  const handleReasignar = (asignacionId, nuevoBecarioId) => {
    // L√≥gica para reasignar
    notifications.success(`Paciente reasignado exitosamente`);
  };

  const handleFinalizarAsignacion = async (asignacionId) => {
    try {
      const confirmado = await confirmations.warning('¬øEst√°s seguro de finalizar esta asignaci√≥n?');
      
      if (confirmado) {
        notifications.success('Asignaci√≥n finalizada exitosamente');
      }
    } catch (error) {
      console.error('Error al finalizar asignaci√≥n:', error);
      notifications.error('No se pudo finalizar la asignaci√≥n');
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando asignaciones...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Gesti√≥n de Asignaciones</h1>
          <p>Asignaci√≥n de pacientes a becarios y psic√≥logos</p>
        </div>
        <button className="btn-secondary" onClick={fetchData}>
          <FiRefreshCw /> Actualizar
        </button>
      </div>

      {/* Estad√≠sticas R√°pidas */}
      <div className="grid-3 mb-30">
        <div className="card">
          <h4>Becarios Activos</h4>
          <div className="stat-value">{becarios.filter(b => b.activo).length}</div>
          <div className="text-small">de {becarios.length} total</div>
        </div>
        
        <div className="card">
          <h4>Pacientes Sin Asignar</h4>
          <div className="stat-value">{pacientesSinAsignar.length}</div>
          <div className="text-small">esperando asignaci√≥n</div>
        </div>
        
        <div className="card">
          <h4>Asignaciones Activas</h4>
          <div className="stat-value">{asignaciones.filter(a => a.estado === 'activa').length}</div>
          <div className="text-small">en curso</div>
        </div>
      </div>

      {/* Becarios Disponibles */}
      <div className="dashboard-section mb-20">
        <div className="section-header">
          <h3>Becarios Disponibles</h3>
          <button 
            className="btn-primary"
            onClick={() => setShowModal(true)}
          >
            <FiUserPlus /> Asignar Paciente
          </button>
        </div>
        
        <div className="grid-4">
          {becarios.map((becario) => (
            <div key={becario.id} className="card">
              <div className="flex-row align-center justify-between mb-10">
                <div className="flex-row align-center gap-10">
                  <div className="avatar">
                    {becario.nombre.split(' ').map(n => n[0]).join('')}
                  </div>
                  <div>
                    <h4>{becario.nombre}</h4>
                    <p className="text-small">{becario.especialidad}</p>
                  </div>
                </div>
                {becario.activo ? (
                  <span className="badge badge-success">Activo</span>
                ) : (
                  <span className="badge badge-danger">Inactivo</span>
                )}
              </div>
              
              <div className="card-progress">
                <div className="card-progress-label">
                  <span>Capacidad</span>
                  <span>{becario.pacientes_asignados}/{becario.capacidad}</span>
                </div>
                <div className="progress-container">
                  <div 
                    className="progress-bar"
                    style={{ width: `${(becario.pacientes_asignados / becario.capacidad) * 100}%` }}
                  ></div>
                </div>
              </div>
              
              {becario.activo && (
                <button 
                  className="btn-text w-100 mt-10"
                  onClick={() => {
                    setSelectedBecario(becario);
                    setShowModal(true);
                  }}
                >
                  Asignar paciente
                </button>
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Pacientes Sin Asignar */}
      <div className="dashboard-section mb-20">
        <div className="section-header">
          <h3>Pacientes Sin Asignar ({pacientesSinAsignar.length})</h3>
          <button className="btn-text">Ver todos</button>
        </div>
        
        {pacientesSinAsignar.length > 0 ? (
          <div className="table-container">
            <table className="data-table">
              <thead>
                <tr>
                  <th>Paciente</th>
                  <th>Motivo</th>
                  <th>Fecha Ingreso</th>
                  <th>Acciones</th>
                </tr>
              </thead>
              <tbody>
                {pacientesSinAsignar.map((paciente) => (
                  <tr key={paciente.id}>
                    <td>
                      <div className="flex-row align-center gap-10">
                        <div className="avatar-small">
                          {paciente.nombre.split(' ').map(n => n[0]).join('')}
                        </div>
                        <span>{paciente.nombre}</span>
                      </div>
                    </td>
                    <td>
                      <span className="diagnostico-tag">{paciente.motivo}</span>
                    </td>
                    <td>{new Date(paciente.fecha_ingreso).toLocaleDateString()}</td>
                    <td>
                      <div className="flex-row gap-5">
                        <button 
                          className="btn-text"
                          onClick={() => {
                            setSelectedPaciente(paciente);
                            setShowModal(true);
                          }}
                        >
                          Asignar
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">‚úÖ</div>
            <div>Todos los pacientes est√°n asignados</div>
          </div>
        )}
      </div>

      {/* Asignaciones Activas */}
      <div className="dashboard-section">
        <div className="section-header">
          <h3>Asignaciones Activas</h3>
          <div className="flex-row gap-10">
            <select className="select-field" style={{ width: '150px' }}>
              <option value="">Todas las asignaciones</option>
              <option value="activa">Activas</option>
              <option value="finalizada">Finalizadas</option>
            </select>
          </div>
        </div>
        
        <div className="table-container">
          <table className="data-table">
            <thead>
              <tr>
                <th>Paciente</th>
                <th>Becario</th>
                <th>Psic√≥logo Supervisor</th>
                <th>Fecha Asignaci√≥n</th>
                <th>Estado</th>
                <th>Acciones</th>
              </tr>
            </thead>
            <tbody>
              {asignaciones.map((asignacion) => (
                <tr key={asignacion.id}>
                  <td>{asignacion.paciente}</td>
                  <td>
                    <div className="flex-row align-center gap-10">
                      <div className="avatar-small">
                        {asignacion.becario.split(' ').map(n => n[0]).join('')}
                      </div>
                      <span>{asignacion.becario}</span>
                    </div>
                  </td>
                  <td>{asignacion.psicologo}</td>
                  <td>{new Date(asignacion.fecha_asignacion).toLocaleDateString()}</td>
                  <td>
                    <span className={`badge ${asignacion.estado === 'activa' ? 'badge-success' : 'badge-primary'}`}>
                      {asignacion.estado}
                    </span>
                  </td>
                  <td>
                    <div className="flex-row gap-5">
                      <button 
                        className="btn-text"
                        onClick={() => handleReasignar(asignacion.id, 1)}
                      >
                        <FiEdit2 /> Reasignar
                      </button>
                      {asignacion.estado === 'activa' && (
                        <button 
                          className="btn-text text-danger"
                          onClick={() => handleFinalizarAsignacion(asignacion.id)}
                        >
                          <FiXCircle /> Finalizar
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Modal de Asignaci√≥n */}
      {showModal && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3>Asignar Paciente</h3>
              <button className="modal-close" onClick={() => setShowModal(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="form-grid">
                <div className="form-group">
                  <label>Seleccionar Paciente</label>
                  <select className="select-field">
                    <option value="">Seleccionar paciente...</option>
                    {pacientesSinAsignar.map(paciente => (
                      <option key={paciente.id} value={paciente.id}>
                        {paciente.nombre} - {paciente.motivo}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Seleccionar Becario</label>
                  <select className="select-field">
                    <option value="">Seleccionar becario...</option>
                    {becarios.filter(b => b.activo).map(becario => (
                      <option key={becario.id} value={becario.id}>
                        {becario.nombre} ({becario.pacientes_asignados}/{becario.capacidad})
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Psic√≥logo Supervisor</label>
                  <select className="select-field">
                    <option value="">Seleccionar psic√≥logo...</option>
                    {psicologos.map(psicologo => (
                      <option key={psicologo.id} value={psicologo.id}>
                        {psicologo.nombre}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label>Notas de Asignaci√≥n</label>
                  <textarea 
                    className="textarea-field" 
                    placeholder="Observaciones especiales para esta asignaci√≥n..."
                    rows="3"
                  />
                </div>
              </div>
            </div>
            
            <div className="modal-footer">
              <button className="btn-primary">
                <FiCheckCircle /> Confirmar Asignaci√≥n
              </button>
              <button className="btn-danger" onClick={() => setShowModal(false)}>
                Cancelar
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoordinadorAsignaciones;

/frontend\src\pages\coordinador\ConfiguracionPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiSettings, FiSave, FiUpload, FiDownload, 
  FiDatabase, FiBell, FiCalendar, FiUsers,
  FiShield, FiGlobe, FiMail, FiLock
} from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const CoordinadorConfiguracion = () => {
  const [activeTab, setActiveTab] = useState('general');
  const [configuraciones, setConfiguraciones] = useState({});
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState({ type: '', text: '' });

  const tabs = [
    { id: 'general', label: 'General', icon: <FiSettings /> },
    { id: 'clinica', label: 'Cl√≠nica', icon: <FiUsers /> },
    { id: 'citas', label: 'Citas', icon: <FiCalendar /> },
    { id: 'notificaciones', label: 'Notificaciones', icon: <FiBell /> },
    { id: 'seguridad', label: 'Seguridad', icon: <FiShield /> },
    { id: 'avanzada', label: 'Avanzada', icon: <FiDatabase /> }
  ];

  useEffect(() => {
    fetchConfiguraciones();
  }, []);

  const fetchConfiguraciones = async () => {
    try {
      setLoading(true);
      
      // Simulaci√≥n de datos
      setTimeout(() => {
        setConfiguraciones({
          general: {
            nombreConsultorio: 'PsicoGesti√≥n Consultorio',
            direccion: 'Av. Principal 123, Ciudad',
            telefono: '+123 456 7890',
            email: 'contacto@psicogestion.com',
            sitioWeb: 'https://psicogestion.com',
            moneda: 'USD',
            zonaHoraria: 'America/Mexico_City',
            idioma: 'es'
          },
          clinica: {
            duracionSesionDefault: 50,
            sesionesGratuitas: 3,
            edadMinima: 16,
            maxPacientesPsicologo: 15,
            maxPacientesBecario: 5,
            requiereSupervision: true,
            frecuenciaSupervision: 'semanal'
          },
          citas: {
            horarioInicio: '09:00',
            horarioFin: '20:00',
            intervaloCitas: 15,
            antelacionReserva: 30,
            recordatorio24h: true,
            recordatorio1h: true,
            margenCancelacion: 24,
            maxCitasDia: 8
          },
          notificaciones: {
            emailNuevaCita: true,
            emailCancelacion: true,
            emailRecordatorio: true,
            emailReportes: true,
            smsRecordatorio: false,
            notificacionesPush: true,
            emailCoordinador: 'coordinador@psicogestion.com'
          },
          seguridad: {
            requerirVerificacionEmail: true,
            intentosLogin: 3,
            bloqueoTemporal: 30,
            expiracionSesion: 60,
            requerir2FA: false,
            registroIP: true,
            politicasAceptadas: true
          },
          avanzada: {
            backupAutomatico: true,
            frecuenciaBackup: 'diario',
            retencionBackups: 30,
            logsDetallados: true,
            modoMantenimiento: false,
            versionAPI: '1.0.0',
            debugMode: false
          }
        });
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error cargando configuraciones:', error);
      setLoading(false);
    }
  };

  const handleInputChange = (categoria, campo, valor) => {
    setConfiguraciones(prev => ({
      ...prev,
      [categoria]: {
        ...prev[categoria],
        [campo]: valor
      }
    }));
  };

  const guardarConfiguracion = async (categoria) => {
    try {
      setSaving(true);
      setMessage({ type: '', text: '' });
      
      // Simulaci√≥n de guardado
      setTimeout(() => {
        setMessage({ 
          type: 'success', 
          text: `Configuraci√≥n ${categoria} guardada exitosamente` 
        });
        setSaving(false);
        
        setTimeout(() => {
          setMessage({ type: '', text: '' });
        }, 3000);
      }, 1000);
    } catch (error) {
      setMessage({ type: 'error', text: 'Error al guardar la configuraci√≥n' });
      setSaving(false);
    }
  };

  const exportarConfiguracion = () => {
    const dataStr = JSON.stringify(configuraciones, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    const exportFileDefaultName = `configuracion-psicogestion-${new Date().toISOString().split('T')[0]}.json`;
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
    
    setMessage({ type: 'success', text: 'Configuraci√≥n exportada exitosamente' });
    setTimeout(() => setMessage({ type: '', text: '' }), 3000);
  };

  const importarConfiguracion = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const config = JSON.parse(e.target.result);
        setConfiguraciones(config);
        setMessage({ type: 'success', text: 'Configuraci√≥n importada exitosamente' });
        setTimeout(() => setMessage({ type: '', text: '' }), 3000);
      } catch (error) {
        setMessage({ type: 'error', text: 'Error al importar la configuraci√≥n' });
      }
    };
    reader.readAsText(file);
  };

  const restaurarValoresPredeterminados = async (categoria) => {
    const confirmado = await confirmations.warning('¬øEst√°s seguro de restaurar los valores predeterminados?');
    
    if (confirmado) {
      notifications.success('Valores predeterminados restaurados');
    }
  };

  const toggleModoMantenimiento = async () => {
    const nuevoValor = !configuraciones.avanzada?.modoMantenimiento;
    const confirmado = await confirmations.danger(`¬ø${nuevoValor ? 'Activar' : 'Desactivar'} modo mantenimiento? Esto afectar√° a todos los usuarios.`);
    
    if (confirmado) {
      handleInputChange('avanzada', 'modoMantenimiento', nuevoValor);
      notifications.warning(`Modo mantenimiento ${nuevoValor ? 'activado' : 'desactivado'}`);
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando configuraci√≥n...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Configuraci√≥n del Sistema</h1>
          <p>Configuraci√≥n avanzada del sistema de gesti√≥n</p>
        </div>
        <div className="flex-row gap-10">
          <button className="btn-secondary" onClick={exportarConfiguracion}>
            <FiDownload /> Exportar
          </button>
          <label className="btn-warning" style={{ cursor: 'pointer' }}>
            <FiUpload /> Importar
            <input
              type="file"
              accept=".json"
              onChange={importarConfiguracion}
              style={{ display: 'none' }}
            />
          </label>
        </div>
      </div>

      {message.text && (
        <div className={`alert-message ${message.type}`}>
          {message.text}
        </div>
      )}

      <div className="configuracion-container">
        <div className="config-tabs">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              className={`config-tab ${activeTab === tab.id ? 'active' : ''}`}
              onClick={() => setActiveTab(tab.id)}
            >
              {tab.icon}
              <span>{tab.label}</span>
            </button>
          ))}
        </div>

        <div className="config-content">
          {/* Configuraci√≥n General */}
          {activeTab === 'general' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiSettings /> Configuraci√≥n General
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text"
                    onClick={() => restaurarValoresPredeterminados('general')}
                  >
                    Restaurar valores
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('general')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="form-grid">
                <div className="form-group">
                  <label>Nombre del Consultorio</label>
                  <input
                    type="text"
                    value={configuraciones.general?.nombreConsultorio || ''}
                    onChange={(e) => handleInputChange('general', 'nombreConsultorio', e.target.value)}
                    className="input-field"
                    placeholder="Nombre del consultorio"
                  />
                </div>
                
                <div className="form-group">
                  <label>Direcci√≥n</label>
                  <input
                    type="text"
                    value={configuraciones.general?.direccion || ''}
                    onChange={(e) => handleInputChange('general', 'direccion', e.target.value)}
                    className="input-field"
                    placeholder="Direcci√≥n completa"
                  />
                </div>
                
                <div className="form-group">
                  <label>Tel√©fono</label>
                  <input
                    type="tel"
                    value={configuraciones.general?.telefono || ''}
                    onChange={(e) => handleInputChange('general', 'telefono', e.target.value)}
                    className="input-field"
                    placeholder="N√∫mero de tel√©fono"
                  />
                </div>
                
                <div className="form-group">
                  <label>Email de contacto</label>
                  <input
                    type="email"
                    value={configuraciones.general?.email || ''}
                    onChange={(e) => handleInputChange('general', 'email', e.target.value)}
                    className="input-field"
                    placeholder="correo@ejemplo.com"
                  />
                </div>
                
                <div className="form-group">
                  <label>Sitio web</label>
                  <input
                    type="url"
                    value={configuraciones.general?.sitioWeb || ''}
                    onChange={(e) => handleInputChange('general', 'sitioWeb', e.target.value)}
                    className="input-field"
                    placeholder="https://ejemplo.com"
                  />
                </div>
                
                <div className="form-group">
                  <label>Moneda</label>
                  <select
                    value={configuraciones.general?.moneda || 'USD'}
                    onChange={(e) => handleInputChange('general', 'moneda', e.target.value)}
                    className="select-field"
                  >
                    <option value="USD">USD ($)</option>
                    <option value="MXN">MXN ($)</option>
                    <option value="EUR">EUR (‚Ç¨)</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Zona horaria</label>
                  <select
                    value={configuraciones.general?.zonaHoraria || 'UTC'}
                    onChange={(e) => handleInputChange('general', 'zonaHoraria', e.target.value)}
                    className="select-field"
                  >
                    <option value="America/Mexico_City">Ciudad de M√©xico (UTC-6)</option>
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Nueva York (UTC-5)</option>
                    <option value="Europe/Madrid">Madrid (UTC+1)</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Idioma del sistema</label>
                  <select
                    value={configuraciones.general?.idioma || 'es'}
                    onChange={(e) => handleInputChange('general', 'idioma', e.target.value)}
                    className="select-field"
                  >
                    <option value="es">Espa√±ol</option>
                    <option value="en">Ingl√©s</option>
                  </select>
                </div>
              </div>
            </div>
          )}

          {/* Configuraci√≥n Cl√≠nica */}
          {activeTab === 'clinica' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiUsers /> Configuraci√≥n Cl√≠nica
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text"
                    onClick={() => restaurarValoresPredeterminados('clinica')}
                  >
                    Restaurar valores
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('clinica')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="form-grid">
                <div className="form-group">
                  <label>Duraci√≥n de sesi√≥n predeterminada (minutos)</label>
                  <input
                    type="number"
                    value={configuraciones.clinica?.duracionSesionDefault || 50}
                    onChange={(e) => handleInputChange('clinica', 'duracionSesionDefault', parseInt(e.target.value))}
                    className="input-field"
                    min="30"
                    max="120"
                    step="5"
                  />
                </div>
                
                <div className="form-group">
                  <label>Sesiones gratuitas iniciales</label>
                  <input
                    type="number"
                    value={configuraciones.clinica?.sesionesGratuitas || 3}
                    onChange={(e) => handleInputChange('clinica', 'sesionesGratuitas', parseInt(e.target.value))}
                    className="input-field"
                    min="0"
                    max="10"
                  />
                </div>
                
                <div className="form-group">
                  <label>Edad m√≠nima para atenci√≥n</label>
                  <input
                    type="number"
                    value={configuraciones.clinica?.edadMinima || 16}
                    onChange={(e) => handleInputChange('clinica', 'edadMinima', parseInt(e.target.value))}
                    className="input-field"
                    min="12"
                    max="100"
                  />
                </div>
                
                <div className="form-group">
                  <label>M√°x. pacientes por psic√≥logo</label>
                  <input
                    type="number"
                    value={configuraciones.clinica?.maxPacientesPsicologo || 15}
                    onChange={(e) => handleInputChange('clinica', 'maxPacientesPsicologo', parseInt(e.target.value))}
                    className="input-field"
                    min="5"
                    max="30"
                  />
                </div>
                
                <div className="form-group">
                  <label>M√°x. pacientes por becario</label>
                  <input
                    type="number"
                    value={configuraciones.clinica?.maxPacientesBecario || 5}
                    onChange={(e) => handleInputChange('clinica', 'maxPacientesBecario', parseInt(e.target.value))}
                    className="input-field"
                    min="1"
                    max="10"
                  />
                </div>
                
                <div className="form-group">
                  <label>Frecuencia de supervisi√≥n</label>
                  <select
                    value={configuraciones.clinica?.frecuenciaSupervision || 'semanal'}
                    onChange={(e) => handleInputChange('clinica', 'frecuenciaSupervision', e.target.value)}
                    className="select-field"
                  >
                    <option value="semanal">Semanal</option>
                    <option value="quincenal">Quincenal</option>
                    <option value="mensual">Mensual</option>
                  </select>
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.clinica?.requiereSupervision || true}
                      onChange={(e) => handleInputChange('clinica', 'requiereSupervision', e.target.checked)}
                    />
                    <span>Requerir supervisi√≥n para becarios</span>
                  </label>
                </div>
              </div>
              
              <div className="security-info mt-30">
                <h4>Notas importantes:</h4>
                <ul>
                  <li>Los cambios en la duraci√≥n de sesiones afectar√°n a las citas futuras</li>
                  <li>Los l√≠mites de pacientes se aplicar√°n para nuevas asignaciones</li>
                  <li>La edad m√≠nima debe cumplir con las regulaciones locales</li>
                </ul>
              </div>
            </div>
          )}

          {/* Configuraci√≥n de Citas */}
          {activeTab === 'citas' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiCalendar /> Configuraci√≥n de Citas
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text"
                    onClick={() => restaurarValoresPredeterminados('citas')}
                  >
                    Restaurar valores
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('citas')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="form-grid">
                <div className="form-group">
                  <label>Horario de inicio</label>
                  <input
                    type="time"
                    value={configuraciones.citas?.horarioInicio || '09:00'}
                    onChange={(e) => handleInputChange('citas', 'horarioInicio', e.target.value)}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label>Horario de fin</label>
                  <input
                    type="time"
                    value={configuraciones.citas?.horarioFin || '20:00'}
                    onChange={(e) => handleInputChange('citas', 'horarioFin', e.target.value)}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label>Intervalo entre citas (minutos)</label>
                  <select
                    value={configuraciones.citas?.intervaloCitas || 15}
                    onChange={(e) => handleInputChange('citas', 'intervaloCitas', parseInt(e.target.value))}
                    className="select-field"
                  >
                    <option value="15">15 minutos</option>
                    <option value="30">30 minutos</option>
                    <option value="45">45 minutos</option>
                    <option value="60">60 minutos</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Antelaci√≥n para reserva (d√≠as)</label>
                  <input
                    type="number"
                    value={configuraciones.citas?.antelacionReserva || 30}
                    onChange={(e) => handleInputChange('citas', 'antelacionReserva', parseInt(e.target.value))}
                    className="input-field"
                    min="1"
                    max="90"
                  />
                </div>
                
                <div className="form-group">
                  <label>M√°ximo de citas por d√≠a</label>
                  <input
                    type="number"
                    value={configuraciones.citas?.maxCitasDia || 8}
                    onChange={(e) => handleInputChange('citas', 'maxCitasDia', parseInt(e.target.value))}
                    className="input-field"
                    min="1"
                    max="20"
                  />
                </div>
                
                <div className="form-group">
                  <label>Margen para cancelaci√≥n (horas)</label>
                  <input
                    type="number"
                    value={configuraciones.citas?.margenCancelacion || 24}
                    onChange={(e) => handleInputChange('citas', 'margenCancelacion', parseInt(e.target.value))}
                    className="input-field"
                    min="1"
                    max="72"
                  />
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.citas?.recordatorio24h || true}
                      onChange={(e) => handleInputChange('citas', 'recordatorio24h', e.target.checked)}
                    />
                    <span>Recordatorio 24 horas antes</span>
                  </label>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.citas?.recordatorio1h || true}
                      onChange={(e) => handleInputChange('citas', 'recordatorio1h', e.target.checked)}
                    />
                    <span>Recordatorio 1 hora antes</span>
                  </label>
                </div>
              </div>
            </div>
          )}

          {/* Configuraci√≥n de Notificaciones */}
          {activeTab === 'notificaciones' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiBell /> Configuraci√≥n de Notificaciones
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text"
                    onClick={() => restaurarValoresPredeterminados('notificaciones')}
                  >
                    Restaurar valores
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('notificaciones')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="notifications-list">
                <div className="notification-item">
                  <div>
                    <h4>Notificaciones por Email</h4>
                    <p>Enviar notificaciones por correo electr√≥nico</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.emailNuevaCita || true}
                      onChange={(e) => handleInputChange('notificaciones', 'emailNuevaCita', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Email por cancelaci√≥n</h4>
                    <p>Enviar email cuando se cancele una cita</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.emailCancelacion || true}
                      onChange={(e) => handleInputChange('notificaciones', 'emailCancelacion', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Email de recordatorio</h4>
                    <p>Enviar recordatorios autom√°ticos de citas</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.emailRecordatorio || true}
                      onChange={(e) => handleInputChange('notificaciones', 'emailRecordatorio', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Email de reportes</h4>
                    <p>Enviar reportes autom√°ticos por email</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.emailReportes || true}
                      onChange={(e) => handleInputChange('notificaciones', 'emailReportes', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>SMS de recordatorio</h4>
                    <p>Enviar recordatorios por mensaje de texto</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.smsRecordatorio || false}
                      onChange={(e) => handleInputChange('notificaciones', 'smsRecordatorio', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="notification-item">
                  <div>
                    <h4>Notificaciones push</h4>
                    <p>Enviar notificaciones en tiempo real</p>
                  </div>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={configuraciones.notificaciones?.notificacionesPush || true}
                      onChange={(e) => handleInputChange('notificaciones', 'notificacionesPush', e.target.checked)}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                
                <div className="form-group mt-20">
                  <label>Email del coordinador</label>
                  <input
                    type="email"
                    value={configuraciones.notificaciones?.emailCoordinador || ''}
                    onChange={(e) => handleInputChange('notificaciones', 'emailCoordinador', e.target.value)}
                    className="input-field"
                    placeholder="coordinador@ejemplo.com"
                  />
                </div>
              </div>
            </div>
          )}

          {/* Configuraci√≥n de Seguridad */}
          {activeTab === 'seguridad' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiShield /> Configuraci√≥n de Seguridad
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text"
                    onClick={() => restaurarValoresPredeterminados('seguridad')}
                  >
                    Restaurar valores
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('seguridad')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="form-grid">
                <div className="form-group">
                  <label>Intentos de login fallidos</label>
                  <input
                    type="number"
                    value={configuraciones.seguridad?.intentosLogin || 3}
                    onChange={(e) => handleInputChange('seguridad', 'intentosLogin', parseInt(e.target.value))}
                    className="input-field"
                    min="1"
                    max="10"
                  />
                </div>
                
                <div className="form-group">
                  <label>Bloqueo temporal (minutos)</label>
                  <input
                    type="number"
                    value={configuraciones.seguridad?.bloqueoTemporal || 30}
                    onChange={(e) => handleInputChange('seguridad', 'bloqueoTemporal', parseInt(e.target.value))}
                    className="input-field"
                    min="5"
                    max="1440"
                  />
                </div>
                
                <div className="form-group">
                  <label>Expiraci√≥n de sesi√≥n (minutos)</label>
                  <input
                    type="number"
                    value={configuraciones.seguridad?.expiracionSesion || 60}
                    onChange={(e) => handleInputChange('seguridad', 'expiracionSesion', parseInt(e.target.value))}
                    className="input-field"
                    min="15"
                    max="480"
                  />
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.seguridad?.requerirVerificacionEmail || true}
                      onChange={(e) => handleInputChange('seguridad', 'requerirVerificacionEmail', e.target.checked)}
                    />
                    <span>Requerir verificaci√≥n de email</span>
                  </label>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.seguridad?.requerir2FA || false}
                      onChange={(e) => handleInputChange('seguridad', 'requerir2FA', e.target.checked)}
                    />
                    <span>Requerir autenticaci√≥n de dos factores</span>
                  </label>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.seguridad?.registroIP || true}
                      onChange={(e) => handleInputChange('seguridad', 'registroIP', e.target.checked)}
                    />
                    <span>Registrar direcciones IP</span>
                  </label>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.seguridad?.politicasAceptadas || true}
                      onChange={(e) => handleInputChange('seguridad', 'politicasAceptadas', e.target.checked)}
                    />
                    <span>Requerir aceptaci√≥n de pol√≠ticas</span>
                  </label>
                </div>
              </div>
              
              <div className="security-info mt-30">
                <h4>
                  <FiLock /> Recomendaciones de Seguridad
                </h4>
                <ul>
                  <li>Utilice autenticaci√≥n de dos factores para mayor seguridad</li>
                  <li>Revise regularmente los logs de acceso</li>
                  <li>Actualice las contrase√±as peri√≥dicamente</li>
                  <li>Limite el acceso seg√∫n los roles de usuario</li>
                </ul>
              </div>
            </div>
          )}

          {/* Configuraci√≥n Avanzada */}
          {activeTab === 'avanzada' && (
            <div className="tab-content">
              <div className="section-header">
                <h3>
                  <FiDatabase /> Configuraci√≥n Avanzada
                </h3>
                <div className="flex-row gap-10">
                  <button 
                    className="btn-text text-danger"
                    onClick={toggleModoMantenimiento}
                  >
                    {configuraciones.avanzada?.modoMantenimiento ? 'Desactivar' : 'Activar'} Mantenimiento
                  </button>
                  <button 
                    className="btn-primary"
                    onClick={() => guardarConfiguracion('avanzada')}
                    disabled={saving}
                  >
                    <FiSave /> {saving ? 'Guardando...' : 'Guardar'}
                  </button>
                </div>
              </div>
              
              <div className="form-grid">
                <div className="form-group">
                  <label>Backup autom√°tico</label>
                  <select
                    value={configuraciones.avanzada?.backupAutomatico ? 'si' : 'no'}
                    onChange={(e) => handleInputChange('avanzada', 'backupAutomatico', e.target.value === 'si')}
                    className="select-field"
                  >
                    <option value="si">S√≠</option>
                    <option value="no">No</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Frecuencia de backup</label>
                  <select
                    value={configuraciones.avanzada?.frecuenciaBackup || 'diario'}
                    onChange={(e) => handleInputChange('avanzada', 'frecuenciaBackup', e.target.value)}
                    className="select-field"
                  >
                    <option value="diario">Diario</option>
                    <option value="semanal">Semanal</option>
                    <option value="mensual">Mensual</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Retenci√≥n de backups (d√≠as)</label>
                  <input
                    type="number"
                    value={configuraciones.avanzada?.retencionBackups || 30}
                    onChange={(e) => handleInputChange('avanzada', 'retencionBackups', parseInt(e.target.value))}
                    className="input-field"
                    min="7"
                    max="365"
                  />
                </div>
                
                <div className="form-group">
                  <label>Versi√≥n de API</label>
                  <input
                    type="text"
                    value={configuraciones.avanzada?.versionAPI || '1.0.0'}
                    onChange={(e) => handleInputChange('avanzada', 'versionAPI', e.target.value)}
                    className="input-field"
                    readOnly
                  />
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.avanzada?.logsDetallados || true}
                      onChange={(e) => handleInputChange('avanzada', 'logsDetallados', e.target.checked)}
                    />
                    <span>Logs detallados</span>
                  </label>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.avanzada?.debugMode || false}
                      onChange={(e) => handleInputChange('avanzada', 'debugMode', e.target.checked)}
                    />
                    <span>Modo debug</span>
                  </label>
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      checked={configuraciones.avanzada?.modoMantenimiento || false}
                      onChange={() => {}}
                      disabled
                    />
                    <span style={{ color: configuraciones.avanzada?.modoMantenimiento ? 'var(--yy)' : 'inherit' }}>
                      Modo mantenimiento {configuraciones.avanzada?.modoMantenimiento ? 'ACTIVADO' : 'desactivado'}
                    </span>
                  </label>
                </div>
              </div>
              
              <div className="advanced-actions mt-30">
                <h4>Acciones Avanzadas</h4>
                <div className="grid-2 gap-15 mt-15">
                  <button className="btn-secondary">
                    <FiDatabase /> Limpiar cache
                  </button>
                  <button className="btn-warning">
                    <FiDownload /> Descargar logs
                  </button>
                  <button className="btn-danger">
                    Vaciar logs antiguos
                  </button>
                  <button className="btn-primary">
                    <FiGlobe /> Revisar updates
                  </button>
                </div>
              </div>
              
              <div className="security-info mt-30">
                <h4>‚ö†Ô∏è Advertencias</h4>
                <ul>
                  <li>El modo debug solo debe activarse para desarrollo</li>
                  <li>El modo mantenimiento desconectar√° a todos los usuarios</li>
                  <li>Los cambios en configuraci√≥n avanzada pueden afectar el rendimiento</li>
                  <li>Realice backup antes de realizar cambios importantes</li>
                </ul>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Informaci√≥n del Sistema */}
      <div className="card mt-30">
        <div className="section-header">
          <h3>Informaci√≥n del Sistema</h3>
        </div>
        
        <div className="grid-4">
          <div>
            <div className="text-small">Versi√≥n</div>
            <div className="font-bold">1.0.0</div>
          </div>
          <div>
            <div className="text-small">√öltima actualizaci√≥n</div>
            <div className="font-bold">2024-01-10</div>
          </div>
          <div>
            <div className="text-small">Base de datos</div>
            <div className="font-bold">MySQL 8.0</div>
          </div>
          <div>
            <div className="text-small">Estado</div>
            <div className={`font-bold ${configuraciones.avanzada?.modoMantenimiento ? 'text-warning' : 'text-success'}`}>
              {configuraciones.avanzada?.modoMantenimiento ? 'MANTENIMIENTO' : 'OPERATIVO'}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CoordinadorConfiguracion;

/frontend\src\pages\coordinador\coordinador.css:
--------------------------------------------------------------------------------

/* Mejoras para tablas */
.table-container {
  background: var(--blud);
  border-radius: 8px;
  border: 1px solid var(--blub);
  overflow-x: auto;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
}

.data-table th {
  background: var(--blub);
  padding: 12px 15px;
  text-align: left;
  font-weight: 600;
  color: var(--white);
  border-bottom: 2px solid var(--blu);
}

.data-table td {
  padding: 12px 15px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.data-table tr:hover {
  background: rgba(31, 133, 186, 0.1);
}

.data-table tr:last-child td {
  border-bottom: none;
}

/* Badges mejorados */
.badge {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Para .badge-success */
.badge-success {
  background: 
    linear-gradient(var(--bludSET), var(--bludSET)), /* Capa s√≥lida primero */
    rgba(31, 186, 101, 0.2); /* Capa transparente despu√©s */
  color: var(--grnb);
  border: 1px solid var(--grnb);
  background-blend-mode: overlay; /* Mezcla las capas */
}

/* Para .badge-warning */
.badge-warning {
  background: 
    linear-gradient(var(--bludSET), var(--bludSET)),
    rgba(255, 166, 49, 0.2);
  color: var(--yy);
  border: 1px solid var(--yy);
  background-blend-mode: overlay;
}

/* Para .badge-danger */
.badge-danger {
  background: 
    linear-gradient(var(--bludSET), var(--bludSET)),
    rgba(250, 49, 68, 0.2);
  color: var(--rr);
  border: 1px solid var(--rr);
  background-blend-mode: overlay;
}

/* Para .badge-primary */
.badge-primary {
  background: 
    linear-gradient(var(--bludSET), var(--bludSET)),
    rgba(64, 148, 232, 0.2);
  color: var(--blu);
  border: 1px solid var(--blu);
  background-blend-mode: overlay;
}

/* Para .badge-info */
.badge-info {
  background: 
    linear-gradient(var(--bludSET), var(--bludSET)),
    rgba(55, 182, 156, 0.2);
  color: var(--grnd);
  border: 1px solid var(--grnd);
  background-blend-mode: overlay;
}

/* Cards especiales para reportes */
.card-progress {
  margin-top: 15px;
}

.card-progress-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
  font-size: 12px;
  color: var(--gray);
}

/* Calendario semanal mejorado */
.calendar-week-view {
  display: flex;
  flex-direction: column;
  height: 500px;
  background: var(--blud);
  border-radius: 10px;
  border: 1px solid var(--blub);
  overflow: hidden;
}

.week-header {
  display: flex;
  background: var(--blub);
  border-bottom: 2px solid var(--blu);
}

.week-header > div {
  flex: 1;
  padding: 10px;
  text-align: center;
  font-weight: 600;
  color: var(--white);
}

.week-body {
  display: flex;
  flex: 1;
  overflow-y: auto;
}

.time-column {
  width: 80px;
  background: rgba(0, 0, 0, 0.1);
}

.time-slot {
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  color: var(--gray);
  font-size: 12px;
}

.day-column {
  flex: 1;
  border-left: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
}

.hour-cell {
  height: 60px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
}

.week-event {
  position: absolute;
  left: 2px;
  right: 2px;
  padding: 5px;
  border-radius: 4px;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 11px;
  color: var(--white);
}

.week-event:hover {
  transform: scale(1.02);
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
}

.week-event-time {
  font-weight: bold;
  margin-bottom: 2px;
}

.week-event-patient {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.week-event-psicologo {
  font-size: 10px;
  opacity: 0.8;
  margin-top: 2px;
}

.week-event-more {
  position: absolute;
  bottom: 2px;
  right: 2px;
  font-size: 10px;
  background: rgba(0, 0, 0, 0.5);
  padding: 2px 5px;
  border-radius: 3px;
  color: var(--white);
}

.day-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 5px;
}

.day-name {
  font-size: 12px;
  text-transform: uppercase;
  margin-bottom: 5px;
}

.day-number {
  font-size: 18px;
  font-weight: bold;
}

.time-header {
  width: 80px;
}

/* Mejoras para formularios */
.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: var(--white);
  font-weight: 500;
  font-size: 14px;
}

/* Utilidades adicionales */
.mb-30 { margin-bottom: 30px; }
.mt-30 { margin-top: 30px; }
.mt-15 { margin-top: 15px; }
.ml-5 { margin-left: 5px; }

.flex-1 { flex: 1; }
.flex-col { display: flex; flex-direction: column; }
.justify-between { justify-content: space-between; }
.align-start { align-items: flex-start; }

.text-right { text-align: right; }
.font-bold { font-weight: bold; }

/* Responsive */
@media (max-width: 1200px) {
  .form-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .grid-4 {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .form-grid {
    grid-template-columns: 1fr;
  }
  
  .grid-4 {
    grid-template-columns: 1fr;
  }
  
  .calendar-week-view {
    height: 400px;
  }
  
  .week-event {
    font-size: 10px;
    padding: 3px;
  }
}

/* Animaciones para modales */
@keyframes modalFadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.modal-container {
  animation: modalFadeIn 0.3s ease;
}

/* Estilos para switches personalizados */
.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--blub);
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: var(--white);
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: var(--blu);
}

input:checked + .slider:before {
  transform: translateX(26px);
}

/* Scrollbars personalizados */
.scrollable {
  overflow-y: auto;
}

.scrollable::-webkit-scrollbar {
  width: 6px;
}

.scrollable::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 3px;
}

.scrollable::-webkit-scrollbar-thumb {
  background: var(--white);
  border-radius: 3px;
}

.scrollable::-webkit-scrollbar-thumb:hover {
  background: var(--gray);
}



@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Alertas y mensajes */
.alert-message {
  padding: 12px 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  border-left: 4px solid;
  animation: slideIn 0.3s ease;
}

.alert-message.success {
  background: rgba(31, 133, 186, 0.1);
  border-color: var(--grnb);
  color: var(--grnb);
}

.alert-message.error {
  background: rgba(250, 49, 68, 0.1);
  border-color: var(--rr);
  color: var(--rr);
}

.alert-message.warning {
  background: rgba(255, 166, 49, 0.1);
  border-color: var(--yy);
  color: var(--yy);
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Mejoras para accordions */
.accordion {
  border: 1px solid var(--blub);
  border-radius: 8px;
  margin-bottom: 10px;
  overflow: hidden;
}

.accordion-header {
  padding: 15px 20px;
  background: var(--blud);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
  transition: background 0.3s ease;
}

.accordion-header:hover {
  background: var(--blub);
}

.accordion-content {
  padding: 20px;
  background: rgba(0, 0, 0, 0.1);
  border-top: 1px solid var(--blub);
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.accordion.active .accordion-content {
  max-height: 1000px;
}

/* Pagination */
.pagination {
  display: flex;
  justify-content: center;
  gap: 5px;
  margin-top: 20px;
}

.page-item {
  padding: 8px 12px;
  background: var(--blud);
  border: 1px solid var(--blub);
  color: var(--white);
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
  font-size: 14px;
}

.page-item:hover {
  background: var(--blu);
  border-color: var(--blu);
}

.page-item.active {
  background: var(--blu);
  border-color: var(--blu);
  color: var(--blud);
}



/* Mejoras para tabs */
.config-tabs {
  display: flex;
  flex-direction: column;
  gap: 5px;
  min-width: 200px;
}

.config-tab {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 15px;
  background: transparent;
  border: none;
  color: var(--gray);
  text-align: left;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.3s ease;
  font-size: 14px;
}

.config-tab:hover {
  background: rgba(255, 255, 255, 0.05);
  color: var(--white);
}

.config-tab.active {
  background: rgba(31, 133, 186, 0.1);
  color: var(--blu);
  border: 1px solid var(--blu);
}

.config-tab svg {
  font-size: 18px;
}

/* Mejoras para modales grandes */
.modal-large {
  max-width: 800px;
  width: 95%;
  max-height: 90vh;
}



/* Grid responsive mejorado */
.grid-responsive {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

/* Media queries adicionales */
@media (max-width: 1024px) {
  .configuracion-container {
    flex-direction: column;
  }
  
  .config-tabs {
    flex-direction: row;
    overflow-x: auto;
    min-width: 100%;
    margin-bottom: 20px;
  }
  
  .config-tab {
    white-space: nowrap;
  }
}

@media (max-width: 480px) {
  .grid-2, .grid-3, .grid-4 {
    grid-template-columns: 1fr;
  }
  
  .modal-container {
    width: 95%;
    padding: 15px;
  }
  
  .stat-value {
    font-size: 24px;
  }
}

/* frontend/src/pages/coordinador/coordinador.css - A√±adir al final */

/* Alertas */
.alertas-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.alerta-item {
  display: flex;
  align-items: center;
  padding: 12px;
  background: var(--bg);
  border-radius: 8px;
  border-left: 4px solid var(--rl);
  transition: transform 0.2s;
}

.alerta-item:hover {
  transform: translateX(5px);
  background: var(--bgh);
}

.alerta-icon {
  margin-right: 12px;
  font-size: 20px;
}

.alerta-content {
  flex: 1;
}

.alerta-titulo {
  font-weight: 500;
  color: var(--text);
  margin-bottom: 4px;
}

.alerta-subtitulo {
  font-size: 12px;
  color: var(--text-light);
}

/* Alertas de estado */
.alert {
  padding: 12px 16px;
  border-radius: 8px;
  margin: 10px 0;
  display: flex;
  align-items: center;
  gap: 10px;
}

.alert-warning {
  background: rgba(255, 193, 7, 0.1);
  border: 1px solid rgba(255, 193, 7, 0.3);
  color: #ffc107;
}

/* frontend/src/pages/coordinador/coordinador.css - A√±adir estos estilos */

.alert-info {
  background: rgba(13, 110, 253, 0.1);
  border: 1px solid rgba(13, 110, 253, 0.3);
  color: #0d6efd;
}

.btn-secondary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Mejoras para las barras del gr√°fico */
.chart-bars {
  display: flex;
  align-items: flex-end;
  height: 200px;
  padding: 20px;
  gap: 10px;
}

.chart-bar {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 60px;
}

.bar-fill {
  width: 40px;
  border-radius: 4px 4px 0 0;
  transition: height 0.3s ease;
}

.bar-label {
  margin-top: 5px;
  font-size: 12px;
  text-align: center;
  color: var(--text-light);
}

.bar-value {
  font-size: 11px;
  color: var(--text-lighter);
  margin-top: 2px;
}

/* ===== NUEVOS ESTILOS PARA DASHBOARD COORDINADOR ===== */

/* Distribuci√≥n de citas - gr√°fico mejorado */
.distribution-chart {
  height: 250px;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 20px;
  background: var(--blud);
  border-radius: 10px;
  margin-top: 15px;
}

.distribution-bars {
  display: flex;
  align-items: flex-end;
  gap: 25px;
  height: 100%;
  width: 100%;
}

.distribution-bar-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100%;
}

.distribution-bar-wrapper {
  position: relative;
  height: 100%;
  width: 60px;
  display: flex;
  align-items: flex-end;
}

.distribution-bar {
  width: 100%;
  border-radius: 8px 8px 0 0;
  transition: all 0.3s ease;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 30px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.distribution-bar:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.bar-value-inside {
  position: absolute;
  top: -25px;
  left: 0;
  right: 0;
  text-align: center;
  font-weight: bold;
  font-size: 14px;
  color: var(--text);
}

.distribution-label {
  margin-top: 10px;
  text-align: center;
  width: 100px;
}

.psychologist-name {
  font-weight: 600;
  font-size: 12px;
  color: var(--text);
  margin-bottom: 3px;
  white-space: normal;
  word-wrap: break-word;
  line-height: 1.2;
}

.psychologist-sessions {
  font-size: 11px;
  color: var(--text-light);
}

/* Mensaje cuando no hay datos */
.no-data-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 150px;
  color: var(--text-light);
  text-align: center;
}

.no-data-message svg {
  margin-bottom: 10px;
  opacity: 0.5;
}

.no-data-message p {
  font-size: 14px;
}

/* Alertas mejoradas */
.alerta-item-success {
  border-left-color: var(--grnb);
}

.alerta-item-success .alerta-icon {
  color: var(--grnb);
}

/* Quick actions grid */
.quick-actions-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.quick-action-btn {
  display: flex;
  align-items: center;
  padding: 15px;
  background: var(--blud);
  border: 1px solid var(--blub);
  border-radius: 8px;
  text-align: left;
  cursor: pointer;
  transition: all 0.3s ease;
  color: var(--text);
}

.quick-action-btn:hover {
  background: var(--blub);
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.quick-action-icon {
  margin-right: 15px;
  font-size: 24px;
  color: var(--blu);
}

.quick-action-content h4 {
  margin: 0 0 5px 0;
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
}

.quick-action-content p {
  margin: 0;
  font-size: 12px;
  color: var(--text-light);
  line-height: 1.3;
}

.timeline-item:hover {
  transform: translateX(5px);
}

/* Progress bars para carga de pacientes */
.progress-container {
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
  flex: 1;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--blu), var(--blull));
  border-radius: 4px;
  transition: width 0.3s ease;
}

.paciente-progreso {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 60%;
}

.progreso-text {
  font-size: 12px;
  color: var(--text-light);
  min-width: 40px;
}

/* Botones de texto */
.btn-text {
  background: transparent;
  border: none;
  color: var(--blu);
  cursor: pointer;
  font-size: 14px;
  padding: 5px 10px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.btn-text:hover {
  background: rgba(31, 133, 186, 0.1);
}

/* Responsive */
@media (max-width: 1200px) {
  .quick-actions-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .distribution-bars {
    gap: 15px;
  }
  
  .distribution-bar-wrapper {
    width: 50px;
  }
  
  .distribution-label {
    width: 80px;
  }
}

@media (max-width: 768px) {
  .quick-actions-grid {
    grid-template-columns: 1fr;
  }
  
  .distribution-bars {
    flex-direction: column;
    align-items: center;
    height: auto;
    gap: 20px;
  }
  
  .distribution-bar-container {
    flex-direction: row;
    align-items: center;
    height: auto;
    width: 100%;
  }
  
  .distribution-bar-wrapper {
    width: 60px;
    height: 150px;
  }
  
  .distribution-label {
    margin-top: 0;
    margin-left: 15px;
    text-align: left;
    width: auto;
  }
  
  .bar-value-inside {
    top: -20px;
    font-size: 12px;
  }
}

/* A√±ade esto a tu CSS */
.btn-text-modal {
  background: none;
  border: none;
  color: var(--blu);
  text-decoration: underline;
  cursor: pointer;
  font-size: 12px;
  padding: 0;
  transition: all 0.3s ease;
}

.btn-text-modal:hover {
  background: none;
  text-decoration: none;
}

.modal-stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 15px;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 8px;
}

.stat-item {
  text-align: center;
}



.stat-label {
  font-size: 11px;
  color: var(--grayl);
  text-transform: uppercase;
}



/* Estad√≠sticas mejoradas */
.stat-box {
  display: flex;
  margin-top: 10px;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  transition: all 0.3s ease;
}


.stat-icon {
  font-size: 24px;
  min-width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
}

.stat-content {
  flex: 1;
}

.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: var(--white);
}

.stat-label {
  font-size: 12px;
  color: var(--grayl);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Botones de acci√≥n mejorados */
.action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: center;
  min-height: 50px;
}


/* Formularios mejorados */
.form-label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  color: var(--white);
  font-weight: 500;
}

.filters-header {
  padding-bottom: 15px;
  border-bottom: 2px solid var(--blu);
  margin-bottom: 20px;
}

.filters-header h4 {
  color: var(--blu);
  display: flex;
  align-items: center;
  gap: 10px;
}

/* Search box mejorado */
.search-box-wrapper {
  position: relative;
}

.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--blud);
  border: 1px solid var(--blub);
  border-radius: 0 0 8px 8px;
  z-index: 100;
  max-height: 200px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 15px;
  cursor: pointer;
  transition: background 0.3s ease;
  border-bottom: 1px solid var(--blub);
}

.search-result-item:hover {
  background: rgba(31, 133, 186, 0.2);
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-name {
  font-weight: bold;
  color: var(--white);
}

.search-result-email {
  font-size: 11px;
  color: var(--grayl);
  margin-top: 2px;
}

/* Modal extra grande */
.modal-extra-large {
  max-width: 1000px !important;
  width: 95% !important;
}

.wide-table th,
.wide-table td {
  padding: 12px 15px;
}

/* Grid de estad√≠sticas del modal */
.modal-stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 15px;
  margin-bottom: 25px;
  padding: 20px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 10px;
  border: 1px solid var(--blub);
}

.modal-stats-grid .stat-item {
  text-align: center;
  padding: 15px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.modal-stats-grid .stat-value {
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 5px;
}

.modal-stats-grid .stat-label {
  font-size: 11px;
  color: var(--grayl);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Border top para separadores */
.border-top {
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

/* Ajustes responsive */
@media (max-width: 1200px) {
  .modal-extra-large {
    max-width: 95% !important;
    width: 95% !important;
  }
}

@media (max-width: 768px) {
  .grid-3 {
    grid-template-columns: 1fr;
  }
  
  .modal-stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .grid-2.action-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .stat-box {
    flex-direction: column;
    text-align: center;
  }
  
  .modal-stats-grid {
    grid-template-columns: 1fr;
  }
}

/frontend\src\pages\coordinador\DashboardPage.js:
--------------------------------------------------------------------------------
// frontend/src/pages/coordinador/DashboardPage.js
import React, { useState, useEffect } from 'react';
import { 
  FiUsers, FiCalendar, FiTrendingUp, FiBarChart2,
  FiUserCheck, FiClock, FiAlertCircle, FiRefreshCw,
  FiDollarSign, FiActivity, FiInfo, FiUser, FiFileText,
  FiCheckCircle, FiList, FiUserPlus, FiTarget, FiClipboard,
  FiUsers as FiUsersGroup, FiCalendar as FiCalendarGlobal
} from 'react-icons/fi';
import './coordinador.css';
import { useNavigate } from 'react-router-dom'; // Importamos useNavigate
import notifications from '../../utils/notifications';
import DashboardService from '../../services/dashboardService';

const CoordinadorDashboard = () => {
  const navigate = useNavigate(); // Para navegaci√≥n
  
  const [estadisticas, setEstadisticas] = useState({
    becariosActivos: 0,
    psicologosActivos: 0,
    pacientesActivos: 0,
    citasHoy: 0,
    citasCompletadasHoy: 0,
    altasMesActual: 0
  });
  
  const [actividadReciente, setActividadReciente] = useState([]);
  const [distribucionPsicologos, setDistribucionPsicologos] = useState([]);
  const [alertas, setAlertas] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('Cargando dashboard...');
      const response = await DashboardService.obtenerDashboardCoordinador();
      
      const datosTransformados = DashboardService.transformarDatosCoordinador(response);
      
      setEstadisticas(datosTransformados.estadisticas);
      setActividadReciente(datosTransformados.actividadReciente);
      setDistribucionPsicologos(datosTransformados.distribucionPsicologos);
      setAlertas(datosTransformados.alertas);
      
      
    } catch (error) {
      console.error('Error cargando dashboard:', error);
      setError(`Error al cargar datos: ${error.message}`);
      notifications.error('Error', 'No se pudieron cargar los datos del dashboard');
    } finally {
      setLoading(false);
    }
  };

  // Funci√≥n para manejar "Ver todo" en Actividad Reciente
  const handleVerTodaActividad = () => {
    navigate('/coordinador/agenda'); // Redirige a la agenda
  };

  // Funciones para las Acciones de Coordinaci√≥n
  const handleGestionarUsuarios = () => {
    navigate('/coordinador/usuarios');
  };

  const handleAsignarPacientes = () => {
    navigate('/coordinador/asignaciones');
  };

  const handleGenerarReporteMensual = () => {
    navigate('/coordinador/reportes');
  };

  const handleRevisarAltas = () => {
    navigate('/coordinador/altas');
  };

  const handleVerAgendaGlobal = () => {
    navigate('/coordinador/agenda');
  };

  // Funci√≥n para manejar "Reasignar" en Carga de Pacientes
  const handleReasignar = () => {
    navigate('/coordinador/asignaciones');
  };

  // Funci√≥n para manejar "Resolver" en Alertas
  const handleResolverAlertas = () => {
    // Aqu√≠ puedes implementar l√≥gica para marcar alertas como resueltas
    setAlertas([]);
    notifications.success('Alertas resueltas', 'Las alertas han sido marcadas como resueltas');
  };

  const statCards = [
    {
      title: 'Becarios Activos',
      value: estadisticas.becariosActivos,
      icon: <FiUserCheck />,
      color: 'var(--grnb)',
      change: 'En formaci√≥n'
    },
    {
      title: 'Psic√≥logos Activos',
      value: estadisticas.psicologosActivos,
      icon: <FiUsers />,
      color: 'var(--blu)',
      change: 'En supervisi√≥n'
    },
    {
      title: 'Pacientes Activos',
      value: estadisticas.pacientesActivos,
      icon: <FiActivity />,
      color: 'var(--yy)',
      change: 'En tratamiento'
    },
    {
      title: 'Citas Hoy',
      value: estadisticas.citasHoy,
      icon: <FiCalendar />,
      color: 'var(--grnd)',
      change: `${estadisticas.citasCompletadasHoy} completadas`
    },
    {
      title: 'Altas Este Mes',
      value: estadisticas.altasMesActual,
      icon: <FiTrendingUp />,
      color: 'var(--grnl)',
      change: 'Pacientes finalizados'
    },
    {
      title: 'Sesiones Promedio',
      value: '8.5',
      icon: <FiBarChart2 />,
      color: 'var(--rr)',
      change: 'Por paciente/mes'
    },
    {
      title: 'Alertas Pendientes',
      value: alertas.reduce((total, alerta) => total + (alerta.cantidad || 0), 0),
      icon: <FiAlertCircle />,
      color: 'var(--rl)',
      change: 'Requieren atenci√≥n'
    },
    {
      title: 'Ingresos Estimados',
      value: '$24,500',
      icon: <FiDollarSign />,
      color: 'var(--grnb)',
      change: 'Este mes'
    }
  ];

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando panel de coordinaci√≥n...</div>
      </div>
    );
  }

  return (
    <div className="dashboard-page">
      <div className="page-header">
        <div>
          <h1>Panel de Coordinaci√≥n</h1>
          <p>Vista general del sistema y gesti√≥n administrativa</p>
          {error && (
            <div className="alert alert-warning mt-10">
              <FiAlertCircle /> {error}
            </div>
          )}
        </div>
        <button className="btn-secondary" onClick={fetchDashboardData} disabled={loading}>
          <FiRefreshCw /> {loading ? 'Cargando...' : 'Actualizar'}
        </button>
      </div>

      {/* Stats Grid */}
      <div className="stats-grid">
        {statCards.map((stat, index) => (
          <div key={index} className="stat-card">
            <div className="stat-header">
              <div className="stat-icon" style={{ color: stat.color }}>
                {stat.icon}
              </div>
              <h3>{stat.title}</h3>
            </div>
            <div className="stat-value">{stat.value}</div>
            <div className="stat-change">{stat.change}</div>
          </div>
        ))}
      </div>

      {/* Main Content Grid */}
      <div className="dashboard-content-grid">
        {/* Actividad Reciente */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Actividad Reciente del Sistema</h3>
            <button className="btn-text" onClick={handleVerTodaActividad}>
              Ver todo
            </button>
          </div>
          
          <div className="timeline">
            {actividadReciente.length > 0 ? (
              actividadReciente.map((actividad) => (
                <div key={actividad.id} className="timeline-item">
                  <div className="timeline-content">
                    <div className="flex-row justify-between">
                      <strong>{actividad.descripcion}</strong>
                      <span className="text-small">
                        {new Date(actividad.fecha).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                      </span>
                    </div>
                    <div className="text-small mt-5">
                      Por: {actividad.usuario} ‚Ä¢ {new Date(actividad.fecha).toLocaleDateString()}
                    </div>
                  </div>
                </div>
              ))
            ) : (
              <div className="timeline-item">
                <div className="timeline-content">
                  <div className="flex-row justify-between">
                    <strong>No hay actividad reciente</strong>
                    <FiClock className="text-small" />
                  </div>
                  <div className="text-small mt-5">
                    El sistema no registra actividad en este momento
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Distribuci√≥n de Citas */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Distribuci√≥n de Citas por Psic√≥logo</h3>
          </div>
          
          <div className="distribution-chart">
            {distribucionPsicologos.length > 0 ? (
              <div className="distribution-bars">
                {distribucionPsicologos.map((psicologo, index) => {
                  // Calcular altura m√°xima basada en el m√°ximo de citas
                  const maxCitas = Math.max(...distribucionPsicologos.map(p => p.citas || 0), 1);
                  const porcentaje = ((psicologo.citas || 0) / maxCitas) * 100;
                  
                  return (
                    <div key={index} className="distribution-bar-container">
                      <div className="distribution-bar-wrapper">
                        <div 
                          className="distribution-bar"
                          style={{ 
                            height: `${porcentaje}%`,
                            backgroundColor: psicologo.color || 'var(--grnb)'
                          }}
                        >
                          <div className="bar-value-inside">{psicologo.citas || 0}</div>
                        </div>
                      </div>
                      <div className="distribution-label">
                        <div className="psychologist-name">
                          {psicologo.nombre || 'Sin nombre'}
                        </div>
                        <div className="psychologist-sessions">
                          {psicologo.citas || 0} citas
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            ) : (
              <div className="no-data-message">
                <FiBarChart2 size={40} />
                <p>No hay datos de distribuci√≥n disponibles</p>
              </div>
            )}
          </div>
        </div>

        {/* Becarios por Carga */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Carga de Pacientes por Becario</h3>
            <button className="btn-text" onClick={handleReasignar}>
              Reasignar
            </button>
          </div>
          
          <div className="pacientes-list">
            {/* Aqu√≠ puedes obtener datos reales de becarios */}
            <div className="no-data-message">
              <FiUser size={40} />
              <p>Los datos de becarios se cargar√°n pr√≥ximamente</p>
            </div>
          </div>
        </div>

        {/* Alertas Pendientes */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Alertas Pendientes</h3>
            <button className="btn-text" onClick={handleResolverAlertas}>
              Resolver
            </button>
          </div>
          
          <div className="alertas-list">
            {alertas.length > 0 ? (
              alertas.map((alerta, index) => (
                <div key={index} className="alerta-item">
                  <div className="alerta-icon">
                    <FiAlertCircle style={{ color: 'var(--rl)' }} />
                  </div>
                  <div className="alerta-content">
                    <div className="alerta-titulo">{alerta.descripcion}</div>
                    <div className="alerta-subtitulo">
                      {alerta.cantidad} {alerta.cantidad === 1 ? 'elemento' : 'elementos'} pendientes
                    </div>
                  </div>
                </div>
              ))
            ) : (
              <div className="alerta-item alerta-item-success">
                <div className="alerta-icon">
                  <FiCheckCircle style={{ color: 'var(--grnb)' }} />
                </div>
                <div className="alerta-content">
                  <div className="alerta-titulo">Sin alertas pendientes</div>
                  <div className="alerta-subtitulo">Todo est√° al d√≠a en el sistema</div>
                </div>
              </div>
            )}
          </div>
        </div>

        
      </div>
    </div>
  );
};

export default CoordinadorDashboard;

/frontend\src\pages\coordinador\PacientesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiUserPlus, FiEdit2, FiTrash2, FiFilter, FiUser, FiCalendar, FiPhone, FiMail, FiFileText, FiXCircle, FiCheckCircle } from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const CoordinadorPacientes = () => {
  const [pacientes, setPacientes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterEstado, setFilterEstado] = useState('');
  const [includeInactivos, setIncludeInactivos] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [modalType, setModalType] = useState('nuevo');
  const [formData, setFormData] = useState({
    nombre: '',
    apellido: '',
    fecha_nacimiento: '',
    genero: '',
    telefono: '',
    email: '',
    direccion: '',
    es_estudiante: false,
    matricula: '',
    institucion_educativa: '',
    contacto_emergencia_nombre: '',
    contacto_emergencia_telefono: '',
    motivo_consulta: '',
    antecedentes: '',
    activo: true,
    estado: 'activo'
  });

  useEffect(() => {
    fetchPacientes();
  }, []);

  const fetchPacientes = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const res = await fetch('http://localhost:3000/api/pacientes', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        }
      });

      if (!res.ok) {
        console.error('Error fetching pacientes:', res.status);
        setLoading(false);
        return;
      }

      const data = await res.json();
      setPacientes(data);
    } catch (error) {
      console.error('Error al obtener pacientes:', error);
    } finally {
      setLoading(false);
    }
  };

  const filteredPacientes = pacientes.filter(paciente => {
    const matchesSearch = 
      `${paciente.nombre} ${paciente.apellido}`.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (paciente.email || '').toLowerCase().includes(searchTerm.toLowerCase()) ||
      (paciente.motivo_consulta || paciente.notas || '').toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesEstado = !filterEstado || paciente.estado === filterEstado;
    const matchesActivo = includeInactivos ? true : paciente.activo;
    
    return matchesSearch && matchesEstado && matchesActivo;
  });

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData({
      ...formData,
      [name]: type === 'checkbox' ? checked : value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (modalType === 'nuevo') {
      try {
        const token = localStorage.getItem('token');
        const res = await fetch('http://localhost:3000/api/pacientes', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
          },
          body: JSON.stringify(formData)
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          notifications.error(err.message || 'Error creando paciente');
          return;
        }

        const created = await res.json();
        setPacientes(prev => [...prev, created]);
        notifications.success('Paciente creado exitosamente');
      } catch (error) {
        console.error('Error creando paciente:', error);
        notifications.error('Error creando paciente');
      }
    } else {
      // Editar paciente: enviar al backend
      try {
        const token = localStorage.getItem('token');
        const res = await fetch(`http://localhost:3000/api/pacientes/${formData.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
          },
          body: JSON.stringify(formData)
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          notifications.error(err.message || 'Error actualizando paciente');
          return;
        }

        const updated = await res.json();
        setPacientes(prev => prev.map(p => p.id === updated.id ? updated : p));
        notifications.success('Paciente actualizado exitosamente');
      } catch (error) {
        console.error('Error actualizando paciente:', error);
        notifications.error('Error actualizando paciente');
      }
    }
    
    setShowModal(false);
    resetForm();
  };

  const editarPaciente = (paciente) => {
    setFormData({ ...paciente });
    setModalType('editar');
    setShowModal(true);
  };

  const toggleActivoPaciente = async (id) => {
    try {
      const paciente = pacientes.find(p => p.id === id);
      if (!paciente) return;
      const token = localStorage.getItem('token');
      const res = await fetch(`http://localhost:3000/api/pacientes/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        },
        body: JSON.stringify({ activo: !paciente.activo })
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        notifications.error(err.message || 'Error cambiando estado');
        return;
      }

      const updated = await res.json();
      setPacientes(prev => prev.map(p => p.id === id ? updated : p));
    } catch (error) {
      console.error('Error toggling paciente activo:', error);
      notifications.error('Error cambiando estado del paciente');
    }
  };

  const deletePaciente = async (id) => {
    const confirmado = await confirmations.danger('¬øSeguro que desea eliminar (inactivar) este paciente?');
    if (!confirmado) return;
    
    try {
      const token = localStorage.getItem('token');
      const res = await fetch(`http://localhost:3000/api/pacientes/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        }
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        notifications.error(err.message || 'Error eliminando paciente');
        return;
      }

      setPacientes(prev => prev.filter(p => p.id !== id));
      notifications.success('Paciente eliminado (inactivado) correctamente');
    } catch (error) {
      console.error('Error eliminando paciente:', error);
      notifications.error('Error eliminando paciente');
    }
  };

  const getEstadoLabel = (estado) => {
    switch (estado) {
      case 'activo':
        return { text: 'Activo', color: 'success' };
      case 'alta_terapeutica':
        return { text: 'Alta Terap√©utica', color: 'primary' };
      case 'abandono':
        return { text: 'Abandono', color: 'danger' };
      case 'traslado':
        return { text: 'Traslado', color: 'warning' };
      default:
        return { text: estado, color: 'info' };
    }
  };

  const calcularEdad = (fechaNacimiento) => {
    if (!fechaNacimiento) return 'N/A';
    const hoy = new Date();
    const nacimiento = new Date(fechaNacimiento);
    let edad = hoy.getFullYear() - nacimiento.getFullYear();
    const mes = hoy.getMonth() - nacimiento.getMonth();
    if (mes < 0 || (mes === 0 && hoy.getDate() < nacimiento.getDate())) {
      edad--;
    }
    return edad;
  };

  const resetForm = () => {
    setFormData({
      nombre: '',
      apellido: '',
      fecha_nacimiento: '',
      genero: '',
      telefono: '',
      email: '',
      direccion: '',
      es_estudiante: false,
      matricula: '',
      institucion_educativa: '',
      contacto_emergencia_nombre: '',
      contacto_emergencia_telefono: '',
      motivo_consulta: '',
      antecedentes: '',
      activo: true,
      estado: 'activo'
    });
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando pacientes...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Gesti√≥n de Pacientes</h1>
          <p>Administraci√≥n de pacientes del sistema</p>
        </div>
        <button 
          className="btn-primary"
          onClick={() => {
            resetForm();
            setModalType('nuevo');
            setShowModal(true);
          }}
        >
          <FiUserPlus /> Nuevo Paciente
        </button>
      </div>

      {/* Filtros y B√∫squeda */}
      <div className="filters-container mb-20">
        <div className="search-box">
          <FiSearch />
          <input
            type="text"
            className="search-input"
            placeholder="Buscar paciente por nombre, email o motivo de consulta..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
        
        <div className="filter-buttons">
          <select 
            value={filterEstado} 
            onChange={(e) => setFilterEstado(e.target.value)}
            className="select-field"
            style={{ width: '200px' }}
          >
            <option value="">Todos los estados</option>
            <option value="activo">Activos</option>
            <option value="alta_terapeutica">Altas Terap√©uticas</option>
            <option value="abandono">Abandonos</option>
            <option value="traslado">Traslados</option>
          </select>

          <label className="ml-10 flex-row align-center">
            <input
              type="checkbox"
              checked={includeInactivos}
              onChange={(e) => setIncludeInactivos(e.target.checked)}
            />
            <span className="ml-5">Incluir inactivos</span>
          </label>

          <button
            className="btn-secondary ml-10"
            onClick={() => { setFilterEstado(''); setSearchTerm(''); setIncludeInactivos(true); fetchPacientes(); }}
            title="Mostrar todos"
          >
            Mostrar todos
          </button>

          <button
            className="btn-secondary ml-10"
            onClick={() => fetchPacientes()}
            title="Refrescar"
          >
            Actualizar
          </button>
        </div>
      </div>

      {/* Tabla de Pacientes */}
      <div className="table-container">
        <table className="data-table">
          <thead>
            <tr>
              <th>Paciente</th>
              <th>Contacto</th>
              <th>Edad</th>
              <th>Motivo</th>
              <th>Asignaciones</th>
              <th>Sesiones</th>
              <th>Estado</th>
              <th>Acciones</th>
            </tr>
          </thead>
          <tbody>
            {filteredPacientes.map((paciente) => {
              const estadoInfo = getEstadoLabel(paciente.estado);
              const edad = calcularEdad(paciente.fecha_nacimiento);
              
              return (
                <tr key={paciente.id}>
                  <td>
                    <div className="flex-row align-center gap-10">
                      <div className="avatar">
                        {paciente.nombre[0]}{paciente.apellido[0]}
                      </div>
                      <div>
                        <div className="font-bold">{paciente.nombre} {paciente.apellido}</div>
                        <div className="text-small">
                          {paciente.es_estudiante ? 'Estudiante' : 'No estudiante'}
                        </div>
                      </div>
                    </div>
                  </td>
                  <td>
                    <div>{paciente.email}</div>
                    <div className="text-small">{paciente.telefono}</div>
                  </td>
                  <td>{edad} a√±os</td>
                  <td>
                    <div className="diagnostico-tag">
                      {paciente.motivo_consulta}
                    </div>
                  </td>
                  <td>
                    <div className="text-small">{paciente.psicologo_asignado}</div>
                    <div className="text-small">
                      {paciente.becario_asignado || 'Sin becario'}
                    </div>
                  </td>
                  <td>
                    <div className="font-bold">{paciente.sesiones_completadas}</div>
                    <div className="text-small">sesiones</div>
                  </td>
                  <td>
                    <span className={`badge badge-${estadoInfo.color}`}>
                      {estadoInfo.text}
                    </span>
                  </td>
                  <td>
                    <div className="flex-row gap-5">
                      <button 
                        className="btn-text"
                        onClick={() => editarPaciente(paciente)}
                        title="Editar"
                      >
                        <FiEdit2 />
                      </button>

                      <button 
                        className={`btn-text ${paciente.activo ? 'text-danger' : 'text-success'}`}
                        onClick={() => toggleActivoPaciente(paciente.id)}
                        title={paciente.activo ? 'Desactivar' : 'Activar'}
                      >
                        {paciente.activo ? <FiXCircle /> : <FiCheckCircle />}
                      </button>

                      <button
                        className="btn-text text-danger"
                        onClick={() => deletePaciente(paciente.id)}
                        title="Eliminar"
                      >
                        <FiTrash2 />
                      </button>

                      <button 
                        className="btn-text"
                        title="Ver expediente"
                      >
                        <FiFileText />
                      </button>
                    </div>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Resumen */}
      <div className="grid-3 mt-20">
        <div className="card">
          <h4>Resumen de Pacientes</h4>
          <div className="mt-10">
            <p>Total: {pacientes.length}</p>
            <p>Activos: {pacientes.filter(p => p.activo).length}</p>
            <p>Estudiantes: {pacientes.filter(p => p.es_estudiante).length}</p>
            <p>Con becario: {pacientes.filter(p => p.becario_asignado).length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Estad√≠sticas</h4>
          <div className="mt-10">
            <p>Sesiones totales: {pacientes.reduce((sum, p) => sum + (p.sesiones_completadas || 0), 0)}</p>
            <p>Promedio por paciente: {
              Math.round(pacientes.reduce((sum, p) => sum + (p.sesiones_completadas || 0), 0) / Math.max(pacientes.length, 1))
            }</p>
            <p>Altas este mes: {pacientes.filter(p => p.estado === 'alta_terapeutica').length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Acciones</h4>
          <div className="mt-10 flex-col gap-10">
            <button className="btn-primary w-100">
              Asignar Pacientes
            </button>
            <button className="btn-secondary w-100">
              Exportar Listado
            </button>
            <button className="btn-warning w-100">
              Revisar Altas
            </button>
          </div>
        </div>
      </div>

      {/* Modal de Paciente */}
      {showModal && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>{modalType === 'nuevo' ? 'Nuevo Paciente' : 'Editar Paciente'}</h3>
              <button className="modal-close" onClick={() => setShowModal(false)}>√ó</button>
            </div>
            
            <form onSubmit={handleSubmit}>
              <div className="form-grid">
                <div className="form-group">
                  <label>Nombre</label>
                  <input
                    type="text"
                    name="nombre"
                    value={formData.nombre}
                    onChange={handleInputChange}
                    className="input-field"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>Apellido</label>
                  <input
                    type="text"
                    name="apellido"
                    value={formData.apellido}
                    onChange={handleInputChange}
                    className="input-field"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>Fecha de nacimiento</label>
                  <input
                    type="date"
                    name="fecha_nacimiento"
                    value={formData.fecha_nacimiento}
                    onChange={handleInputChange}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label>G√©nero</label>
                  <select
                    name="genero"
                    value={formData.genero}
                    onChange={handleInputChange}
                    className="select-field"
                  >
                    <option value="">Seleccionar...</option>
                    <option value="masculino">Masculino</option>
                    <option value="femenino">Femenino</option>
                    <option value="otro">Otro</option>
                    <option value="prefiero_no_decir">Prefiero no decir</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Tel√©fono</label>
                  <input
                    type="tel"
                    name="telefono"
                    value={formData.telefono}
                    onChange={handleInputChange}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label>Email</label>
                  <input
                    type="email"
                    name="email"
                    value={formData.email}
                    onChange={handleInputChange}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label>Direcci√≥n</label>
                  <input
                    type="text"
                    name="direccion"
                    value={formData.direccion}
                    onChange={handleInputChange}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      name="es_estudiante"
                      checked={formData.es_estudiante}
                      onChange={handleInputChange}
                    />
                    <span>Es estudiante</span>
                  </label>
                </div>
                
                {formData.es_estudiante && (
                  <>
                    <div className="form-group">
                      <label>Matr√≠cula</label>
                      <input
                        type="text"
                        name="matricula"
                        value={formData.matricula}
                        onChange={handleInputChange}
                        className="input-field"
                      />
                    </div>
                    
                    <div className="form-group">
                      <label>Instituci√≥n educativa</label>
                      <input
                        type="text"
                        name="institucion_educativa"
                        value={formData.institucion_educativa}
                        onChange={handleInputChange}
                        className="input-field"
                      />
                    </div>
                  </>
                )}
                
                <div className="form-group">
                  <label>Contacto de emergencia</label>
                  <input
                    type="text"
                    name="contacto_emergencia_nombre"
                    value={formData.contacto_emergencia_nombre}
                    onChange={handleInputChange}
                    className="input-field"
                    placeholder="Nombre"
                  />
                </div>
                
                <div className="form-group">
                  <label>Tel√©fono emergencia</label>
                  <input
                    type="tel"
                    name="contacto_emergencia_telefono"
                    value={formData.contacto_emergencia_telefono}
                    onChange={handleInputChange}
                    className="input-field"
                    placeholder="Tel√©fono"
                  />
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label>Motivo de consulta</label>
                  <textarea
                    name="motivo_consulta"
                    value={formData.motivo_consulta}
                    onChange={handleInputChange}
                    className="textarea-field"
                    rows="3"
                    required
                  />
                </div>
                
                <div className="form-group" style={{ gridColumn: 'span 2' }}>
                  <label>Antecedentes</label>
                  <textarea
                    name="antecedentes"
                    value={formData.antecedentes}
                    onChange={handleInputChange}
                    className="textarea-field"
                    rows="3"
                  />
                </div>
                
                <div className="form-group">
                  <label>Estado</label>
                  <select
                    name="estado"
                    value={formData.estado}
                    onChange={handleInputChange}
                    className="select-field"
                  >
                    <option value="activo">Activo</option>
                    <option value="alta_terapeutica">Alta Terap√©utica</option>
                    <option value="abandono">Abandono</option>
                    <option value="traslado">Traslado</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      name="activo"
                      checked={formData.activo}
                      onChange={handleInputChange}
                    />
                    <span>Paciente activo</span>
                  </label>
                </div>
              </div>
              
              <div className="modal-footer">
                <button type="submit" className="btn-primary">
                  {modalType === 'nuevo' ? 'Crear Paciente' : 'Guardar Cambios'}
                </button>
                <button 
                  type="button" 
                  className="btn-danger"
                  onClick={() => setShowModal(false)}
                >
                  Cancelar
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoordinadorPacientes;

/frontend\src\pages\coordinador\ReportesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiBarChart2, FiDownload, FiCalendar, FiUsers, 
  FiTrendingUp, FiFilter, FiRefreshCw, FiPrinter
} from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';


const CoordinadorReportes = () => {
  const [reportes, setReportes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [tipoReporte, setTipoReporte] = useState('mensual');
  const [fechaInicio, setFechaInicio] = useState('');
  const [fechaFin, setFechaFin] = useState('');
  const [estadisticas, setEstadisticas] = useState({});
  const [reporteGenerado, setReporteGenerado] = useState(null);

  useEffect(() => {
    fetchReportes();
    generarEstadisticas();
  }, []);

  const fetchReportes = async () => {
    try {
      setLoading(true);
      
      // Simulaci√≥n de datos
      setTimeout(() => {
        setReportes([
          { id: 1, nombre: 'Reporte Mensual Enero 2024', tipo: 'mensual', fecha: '2024-01-31', generado_por: 'Sistema', descargas: 12 },
          { id: 2, nombre: 'Reporte de Altas Diciembre 2023', tipo: 'especial', fecha: '2023-12-31', generado_por: 'Coordinador', descargas: 8 },
          { id: 3, nombre: 'Reporte de Actividad Becarios', tipo: 'becarios', fecha: '2024-01-15', generado_por: 'Sistema', descargas: 15 },
          { id: 4, nombre: 'Reporte Financiero 2023', tipo: 'financiero', fecha: '2024-01-10', generado_por: 'Coordinador', descargas: 5 },
          { id: 5, nombre: 'Reporte de Eficiencia Terap√©utica', tipo: 'clinico', fecha: '2024-01-20', generado_por: 'Sistema', descargas: 7 }
        ]);
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error cargando reportes:', error);
      setLoading(false);
    }
  };

  const generarEstadisticas = () => {
    // Simulaci√≥n de estad√≠sticas
    setEstadisticas({
      pacientesActivos: 25,
      pacientesNuevosMes: 8,
      citasCompletadas: 120,
      promedioSesiones: 8.5,
      tasaRetencion: 85,
      satisfaccionPacientes: 4.2
    });
  };

  const generarReporte = () => {
    // Simulaci√≥n de generaci√≥n de reporte
    setLoading(true);
    setTimeout(() => {
      const nuevoReporte = {
        id: reportes.length + 1,
        nombre: `Reporte ${tipoReporte} ${new Date().toLocaleDateString()}`,
        tipo: tipoReporte,
        fecha: new Date().toISOString().split('T')[0],
        generado_por: 'Coordinador',
        descargas: 0,
        contenido: {
          resumen: `Reporte generado el ${new Date().toLocaleDateString()}`,
          estadisticas: estadisticas,
          datos: 'Aqu√≠ ir√≠an los datos del reporte generado...'
        }
      };
      
      setReportes([nuevoReporte, ...reportes]);
      setReporteGenerado(nuevoReporte);
      setLoading(false);
      notifications.success('Reporte generado exitosamente');
    }, 1500);
  };

  const descargarReporte = (reporteId) => {
    const reporte = reportes.find(r => r.id === reporteId);
    if (reporte) {
      notifications.success(`Descargando reporte: ${reporte.nombre}`);
      // En una implementaci√≥n real, aqu√≠ se generar√≠a y descargar√≠a el archivo
    }
  };

  const imprimirReporte = (reporteId) => {
    const reporte = reportes.find(r => r.id === reporteId);
    if (reporte) {
      notifications.success(`Imprimiendo reporte: ${reporte.nombre}`);
      // En una implementaci√≥n real, aqu√≠ se abrir√≠a el di√°logo de impresi√≥n
    }
  };

  const getColorByTipo = (tipo) => {
    switch (tipo) {
      case 'mensual': return 'var(--grnb)';
      case 'especial': return 'var(--blu)';
      case 'becarios': return 'var(--yy)';
      case 'financiero': return 'var(--grnd)';
      case 'clinico': return 'var(--rr)';
      default: return 'var(--gray)';
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando reportes...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Reportes y Estad√≠sticas</h1>
          <p>Generaci√≥n y gesti√≥n de reportes del sistema</p>
        </div>
        <button className="btn-secondary" onClick={fetchReportes}>
          <FiRefreshCw /> Actualizar
        </button>
      </div>

      {/* Panel de Generaci√≥n de Reportes */}
      <div className="card mb-30">
        <div className="section-header">
          <h3>
            <FiBarChart2 /> Generar Nuevo Reporte
          </h3>
          <button className="btn-primary" onClick={generarReporte}>
            <FiBarChart2 /> Generar Reporte
          </button>
        </div>
        
        <div className="form-grid">
          <div className="form-group">
            <label>Tipo de Reporte</label>
            <select 
              value={tipoReporte} 
              onChange={(e) => setTipoReporte(e.target.value)}
              className="select-field"
            >
              <option value="mensual">Reporte Mensual</option>
              <option value="trimestral">Reporte Trimestral</option>
              <option value="anual">Reporte Anual</option>
              <option value="becarios">Reporte de Becarios</option>
              <option value="clinico">Reporte Cl√≠nico</option>
              <option value="financiero">Reporte Financiero</option>
              <option value="especial">Reporte Especial</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>Fecha Inicio</label>
            <input
              type="date"
              value={fechaInicio}
              onChange={(e) => setFechaInicio(e.target.value)}
              className="input-field"
            />
          </div>
          
          <div className="form-group">
            <label>Fecha Fin</label>
            <input
              type="date"
              value={fechaFin}
              onChange={(e) => setFechaFin(e.target.value)}
              className="input-field"
            />
          </div>
          
          <div className="form-group">
            <label>Formato</label>
            <select className="select-field">
              <option value="pdf">PDF</option>
              <option value="excel">Excel</option>
              <option value="html">HTML</option>
            </select>
          </div>
          
          <div className="form-group" style={{ gridColumn: 'span 2' }}>
            <label>Par√°metros Adicionales</label>
            <div className="grid-2 gap-10">
              <label className="flex-row align-center gap-10">
                <input type="checkbox" defaultChecked />
                <span>Incluir gr√°ficos</span>
              </label>
              <label className="flex-row align-center gap-10">
                <input type="checkbox" defaultChecked />
                <span>Incluir datos detallados</span>
              </label>
              <label className="flex-row align-center gap-10">
                <input type="checkbox" />
                <span>Incluir datos financieros</span>
              </label>
              <label className="flex-row align-center gap-10">
                <input type="checkbox" defaultChecked />
                <span>Incluir comparativas</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      {/* Estad√≠sticas R√°pidas */}
      <div className="grid-3 mb-30">
        <div className="card">
          <div className="flex-row align-center gap-10 mb-10">
            <FiUsers size={24} style={{ color: 'var(--grnb)' }} />
            <div>
              <h4>Pacientes Activos</h4>
              <div className="stat-value">{estadisticas.pacientesActivos || 0}</div>
            </div>
          </div>
          <div className="text-small">+{estadisticas.pacientesNuevosMes || 0} este mes</div>
        </div>
        
        <div className="card">
          <div className="flex-row align-center gap-10 mb-10">
            <FiCalendar size={24} style={{ color: 'var(--blu)' }} />
            <div>
              <h4>Citas Completadas</h4>
              <div className="stat-value">{estadisticas.citasCompletadas || 0}</div>
            </div>
          </div>
          <div className="text-small">este mes</div>
        </div>
        
        <div className="card">
          <div className="flex-row align-center gap-10 mb-10">
            <FiTrendingUp size={24} style={{ color: 'var(--yy)' }} />
            <div>
              <h4>Tasa de Retenci√≥n</h4>
              <div className="stat-value">{estadisticas.tasaRetencion || 0}%</div>
            </div>
          </div>
          <div className="text-small">de pacientes contin√∫an tratamiento</div>
        </div>
      </div>

      {/* Reportes Generados */}
      <div className="dashboard-section">
        <div className="section-header">
          <h3>Reportes Generados</h3>
          <div className="flex-row gap-10">
            <select className="select-field" style={{ width: '150px' }}>
              <option value="">Todos los tipos</option>
              <option value="mensual">Mensuales</option>
              <option value="especial">Especiales</option>
              <option value="becarios">Becarios</option>
              <option value="financiero">Financieros</option>
            </select>
            <input 
              type="text" 
              className="input-field" 
              placeholder="Buscar reporte..."
              style={{ width: '200px' }}
            />
          </div>
        </div>
        
        <div className="table-container">
          <table className="data-table">
            <thead>
              <tr>
                <th>Nombre del Reporte</th>
                <th>Tipo</th>
                <th>Fecha</th>
                <th>Generado por</th>
                <th>Descargas</th>
                <th>Acciones</th>
              </tr>
            </thead>
            <tbody>
              {reportes.map((reporte) => (
                <tr key={reporte.id}>
                  <td>
                    <div className="flex-row align-center gap-10">
                      <FiBarChart2 style={{ color: getColorByTipo(reporte.tipo) }} />
                      <span>{reporte.nombre}</span>
                    </div>
                  </td>
                  <td>
                    <span className="badge" style={{ 
                      background: getColorByTipo(reporte.tipo) + '20',
                      color: getColorByTipo(reporte.tipo),
                      borderColor: getColorByTipo(reporte.tipo)
                    }}>
                      {reporte.tipo}
                    </span>
                  </td>
                  <td>{new Date(reporte.fecha).toLocaleDateString()}</td>
                  <td>{reporte.generado_por}</td>
                  <td>{reporte.descargas}</td>
                  <td>
                    <div className="flex-row gap-5">
                      <button 
                        className="btn-text"
                        onClick={() => descargarReporte(reporte.id)}
                        title="Descargar"
                      >
                        <FiDownload />
                      </button>
                      <button 
                        className="btn-text"
                        onClick={() => imprimirReporte(reporte.id)}
                        title="Imprimir"
                      >
                        <FiPrinter />
                      </button>
                      <button className="btn-text">
                        Ver Vista Previa
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Reporte Reci√©n Generado */}
      {reporteGenerado && (
        <div className="card mt-20" style={{ borderLeft: `4px solid ${getColorByTipo(reporteGenerado.tipo)}` }}>
          <div className="section-header">
            <h3>üìã Reporte Generado Recientemente</h3>
            <button className="btn-text" onClick={() => setReporteGenerado(null)}>√ó</button>
          </div>
          
          <div className="grid-2 gap-20">
            <div>
              <strong>Nombre:</strong> {reporteGenerado.nombre}
            </div>
            <div>
              <strong>Tipo:</strong> {reporteGenerado.tipo}
            </div>
            <div>
              <strong>Fecha generaci√≥n:</strong> {new Date(reporteGenerado.fecha).toLocaleString()}
            </div>
            <div>
              <strong>Generado por:</strong> {reporteGenerado.generado_por}
            </div>
          </div>
          
          <div className="flex-row gap-10 mt-15">
            <button 
              className="btn-primary"
              onClick={() => descargarReporte(reporteGenerado.id)}
            >
              <FiDownload /> Descargar Reporte
            </button>
            <button 
              className="btn-secondary"
              onClick={() => imprimirReporte(reporteGenerado.id)}
            >
              <FiPrinter /> Imprimir
            </button>
          </div>
        </div>
      )}

      {/* Tipos de Reportes Disponibles */}
      <div className="grid-4 mt-30">
        <div className="card">
          <h4>üìä Reportes Mensuales</h4>
          <p className="text-small mt-10">Resumen completo de actividad mensual del consultorio</p>
          <ul className="text-small mt-10">
            <li>Estad√≠sticas de pacientes</li>
            <li>Citas realizadas</li>
            <li>Ingresos generados</li>
            <li>Indicadores clave</li>
          </ul>
        </div>
        
        <div className="card">
          <h4>üë®‚Äç‚öïÔ∏è Reportes Cl√≠nicos</h4>
          <p className="text-small mt-10">An√°lisis de efectividad terap√©utica y progreso</p>
          <ul className="text-small mt-10">
            <li>Evoluci√≥n de pacientes</li>
            <li>Tasas de √©xito</li>
            <li>Tiempos promedio de tratamiento</li>
            <li>Satisfacci√≥n del paciente</li>
          </ul>
        </div>
        
        <div className="card">
          <h4>üë®‚Äçüéì Reportes de Becarios</h4>
          <p className="text-small mt-10">Seguimiento y evaluaci√≥n de becarios</p>
          <ul className="text-small mt-10">
            <li>Carga de trabajo</li>
            <li>Evaluaci√≥n de supervisiones</li>
            <li>Desempe√±o cl√≠nico</li>
            <li>√Åreas de mejora</li>
          </ul>
        </div>
        
        <div className="card">
          <h4>üí∞ Reportes Financieros</h4>
          <p className="text-small mt-10">An√°lisis econ√≥mico y de rentabilidad</p>
          <ul className="text-small mt-10">
            <li>Ingresos vs gastos</li>
            <li>Proyecciones financieras</li>
            <li>An√°lisis de rentabilidad</li>
            <li>Reportes fiscales</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default CoordinadorReportes;

/frontend\src\pages\coordinador\UsuariosPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiUserPlus, FiEdit2, FiTrash2, FiFilter, FiUser, FiMail, FiPhone, FiCheckCircle, FiXCircle } from 'react-icons/fi';
import './coordinador.css';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const CoordinadorUsuarios = () => {
  const [usuarios, setUsuarios] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterRol, setFilterRol] = useState('');
  const [includeInactivos, setIncludeInactivos] = useState(true); // mostrar inactivos por defecto
  const [showModal, setShowModal] = useState(false);
  const [modalType, setModalType] = useState('nuevo');
  const [formData, setFormData] = useState({
    nombre: '',
    apellido: '',
    email: '',
    telefono: '',
    rol: 'becario',
    especialidad: '',
    fundacion_id: '',
    activo: true,
    password: 'P@ssw0rd123' // contrase√±a temporal por defecto
  });

  useEffect(() => {
    fetchUsuarios();
  }, []);

  const fetchUsuarios = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const res = await fetch('http://localhost:3000/api/users', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        }
      });

      if (!res.ok) {
        // Si no es coordinador o token inv√°lido, podemos mostrar un mensaje y seguir
        console.error('Error fetching users:', res.status);
        setLoading(false);
        return;
      }

      const data = await res.json();
      setUsuarios(data);
    } catch (error) {
      console.error('Error al obtener usuarios:', error);
    } finally {
      setLoading(false);
    }
  };

  const filteredUsuarios = usuarios.filter(usuario => {
    const matchesSearch = 
      `${usuario.nombre} ${usuario.apellido}`.toLowerCase().includes(searchTerm.toLowerCase()) ||
      usuario.email.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesRol = !filterRol || usuario.rol === filterRol;
    const matchesActivo = includeInactivos ? true : usuario.activo;
    
    return matchesSearch && matchesRol && matchesActivo;
  });

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    // Si cambia el rol y estamos creando un nuevo usuario, establecer contrase√±a temporal por defecto
    setFormData(prev => {
      const next = {
        ...prev,
        [name]: type === 'checkbox' ? checked : value
      };

      if (name === 'rol' && modalType === 'nuevo') {
        // Mantener la contrase√±a temporal por defecto
        next.password = 'P@ssw0rd123';
      }

      return next;
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (modalType === 'nuevo') {
      try {
        const token = localStorage.getItem('token');
        const res = await fetch('http://localhost:3000/api/users', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
          },
          body: JSON.stringify(formData)
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          notifications.error(err.message || 'Error creando usuario');
          return;
        }

        const created = await res.json();
        // A√±adir a la lista local (asegura compatibilidad de campos)
        setUsuarios(prev => [...prev, created]);
        notifications.success('Usuario creado exitosamente');
      } catch (error) {
        console.error('Error creando usuario:', error);
        notifications.error('Error creando usuario');
      }
    } else {
      // Editar usuario: enviar al backend
      try {
        const token = localStorage.getItem('token');
        const res = await fetch(`http://localhost:3000/api/users/${formData.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
          },
          body: JSON.stringify(formData)
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          notifications.error(err.message || 'Error actualizando usuario');
          return;
        }

        const updated = await res.json();
        setUsuarios(prev => prev.map(u => u.id === updated.id ? updated : u));
        notifications.success('Usuario actualizado exitosamente');
      } catch (error) {
        console.error('Error actualizando usuario:', error);
        notifications.error('Error actualizando usuario');
      }
    }
    
    setShowModal(false);
    resetForm();
  };

  const deleteUsuario = async (id) => {
    const confirmado = await confirmations.danger('¬øSeguro que desea eliminar este usuario?');
    if (!confirmado) return;
    
    try {
      const token = localStorage.getItem('token');
      const res = await fetch(`http://localhost:3000/api/users/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        }
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        notifications.error(err.message || 'Error eliminando usuario');
        return;
      }

      setUsuarios(prev => prev.filter(u => u.id !== id));
      notifications.success('Usuario eliminado correctamente');
    } catch (error) {
      console.error('Error eliminando usuario:', error);
      notifications.error('Error eliminando usuario');
    }
  };

  const editarUsuario = (usuario) => {
    // Mapear fecha si es string
    const mapped = {
      ...usuario,
      password: 'P@ssw0rd123'
    };
    setFormData(mapped);
    setModalType('editar');
    setShowModal(true);
  };

  const toggleEstadoUsuario = async (id) => {
    try {
      const token = localStorage.getItem('token');
      // Encontrar usuario actual
      const usuario = usuarios.find(u => u.id === id);
      if (!usuario) return;

      const res = await fetch(`http://localhost:3000/api/users/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : ''
        },
        body: JSON.stringify({ activo: !usuario.activo })
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        notifications.error(err.message || 'Error al cambiar estado');
        return;
      }

      const updated = await res.json();
      setUsuarios(prev => prev.map(u => u.id === id ? updated : u));
    } catch (error) {
      console.error('Error toggling activo:', error);
      notifications.error('Error cambiando estado de usuario');
    }
  };

  const resetForm = () => {
    setFormData({
      nombre: '',
      apellido: '',
      email: '',
      telefono: '',
      rol: 'becario',
      especialidad: '',
      fundacion_id: '',
      activo: true,
      password: 'P@ssw0rd123'
    });
  };

  const getRolLabel = (rol) => {
    switch (rol) {
      case 'coordinador':
        return { text: 'Coordinador', color: 'danger' };
      case 'psicologo':
        return { text: 'Psic√≥logo', color: 'primary' };
      case 'becario':
        return { text: 'Becario', color: 'warning' };
      default:
        return { text: rol, color: 'info' };
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando usuarios...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Gesti√≥n de Usuarios</h1>
          <p>Administraci√≥n de coordinadores, psic√≥logos y becarios</p>
        </div>
        <button 
          className="btn-primary"
          onClick={() => {
            resetForm();
            setModalType('nuevo');
            setShowModal(true);
          }}
        >
          <FiUserPlus /> Nuevo Usuario
        </button>
      </div>

      {/* Filtros y B√∫squeda */}
      <div className="filters-container mb-20">
        <div className="search-box">
          <FiSearch />
          <input
            type="text"
            className="search-input"
            placeholder="Buscar usuario por nombre o email..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
        
        <div className="filter-buttons">
          <select 
            value={filterRol} 
            onChange={(e) => setFilterRol(e.target.value)}
            className="select-field"
            style={{ width: '200px' }}
          >
            <option value="">Todos los roles</option>
            <option value="coordinador">Coordinadores</option>
            <option value="psicologo">Psic√≥logos</option>
            <option value="becario">Becarios</option>
          </select>

          <label className="ml-10 flex-row align-center">
            <input
              type="checkbox"
              checked={includeInactivos}
              onChange={(e) => setIncludeInactivos(e.target.checked)}
            />
            <span className="ml-5">Incluir inactivos</span>
          </label>

          <button
            className="btn-secondary ml-10"
            onClick={() => { setFilterRol(''); setSearchTerm(''); setIncludeInactivos(true); fetchUsuarios(); }}
            title="Mostrar todos"
          >
            Mostrar todos
          </button>

          <button
            className="btn-secondary ml-10"
            onClick={() => fetchUsuarios()}
            title="Refrescar"
          >
            Actualizar
          </button>
        </div>
      </div>

      {/* Tabla de Usuarios */}
      <div className="table-container">
        <table className="data-table">
          <thead>
            <tr>
              <th>Usuario</th>
              <th>Contacto</th>
              <th>Rol</th>
              <th>Especialidad</th>
              <th>Fecha Registro</th>
              <th>Estado</th>
              <th>Acciones</th>
            </tr>
          </thead>
          <tbody>
            {filteredUsuarios.map((usuario) => {
              const rolInfo = getRolLabel(usuario.rol);
              
              return (
                <tr key={usuario.id}>
                  <td>
                    <div className="flex-row align-center gap-10">
                      <div className="avatar">
                        {usuario.nombre[0]}{usuario.apellido[0]}
                      </div>
                      <div>
                        <div className="font-bold">{usuario.nombre} {usuario.apellido}</div>
                        <div className="text-small">ID: {usuario.id}</div>
                      </div>
                    </div>
                  </td>
                  <td>
                    <div>{usuario.email}</div>
                    <div className="text-small">{usuario.telefono}</div>
                  </td>
                  <td>
                    <span className={`badge badge-${rolInfo.color}`}>
                      {rolInfo.text}
                    </span>
                  </td>
                  <td>{usuario.especialidad}</td>
                  <td>
                    {new Date(usuario.fecha_registro).toLocaleDateString()}
                  </td>
                  <td>
                    {usuario.activo ? (
                      <span className="badge badge-success">Activo</span>
                    ) : (
                      <span className="badge badge-danger">Inactivo</span>
                    )}
                  </td>
                  <td>
                    <div className="flex-row gap-5">
                      <button 
                        className="btn-text"
                        onClick={() => editarUsuario(usuario)}
                        title="Editar"
                      >
                        <FiEdit2 />
                      </button>
                      <button 
                        className={`btn-text ${usuario.activo ? 'text-danger' : 'text-success'}`}
                        onClick={() => toggleEstadoUsuario(usuario.id)}
                        title={usuario.activo ? 'Desactivar' : 'Activar'}
                      >
                        {usuario.activo ? <FiXCircle /> : <FiCheckCircle />}
                      </button>
                      <button
                        className="btn-text text-danger"
                        onClick={() => deleteUsuario(usuario.id)}
                        title="Eliminar"
                      >
                        <FiTrash2 />
                      </button>
                    </div>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Resumen */}
      <div className="grid-3 mt-20">
        <div className="card">
          <h4>Resumen de Usuarios</h4>
          <div className="mt-10">
            <p>Total: {usuarios.length}</p>
            <p>Activos: {usuarios.filter(u => u.activo).length}</p>
            <p>Becarios: {usuarios.filter(u => u.rol === 'becario').length}</p>
            <p>Psic√≥logos: {usuarios.filter(u => u.rol === 'psicologo').length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Distribuci√≥n por Rol</h4>
          <div className="mt-10">
            {Object.entries(
              usuarios.reduce((acc, user) => {
                acc[user.rol] = (acc[user.rol] || 0) + 1;
                return acc;
              }, {})
            ).map(([rol, count]) => (
              <div key={rol} className="flex-row justify-between mb-5">
                <span>{getRolLabel(rol).text}:</span>
                <span className="font-bold">{count}</span>
              </div>
            ))}
          </div>
        </div>
        
        <div className="card">
          <h4>Acciones</h4>
          <div className="mt-10 flex-col gap-10">
            <button className="btn-primary w-100">
              Exportar Listado
            </button>
            <button className="btn-secondary w-100">
              Enviar Recordatorios
            </button>
          </div>
        </div>
      </div>

      {/* Modal de Usuario */}
      {showModal && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3>{modalType === 'nuevo' ? 'Nuevo Usuario' : 'Editar Usuario'}</h3>
              <button className="modal-close" onClick={() => setShowModal(false)}>√ó</button>
            </div>
            
            <form onSubmit={handleSubmit}>
              <div className="form-grid">
                <div className="form-group">
                  <label>Nombre</label>
                  <input
                    type="text"
                    name="nombre"
                    value={formData.nombre}
                    onChange={handleInputChange}
                    className="input-field"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>Apellido</label>
                  <input
                    type="text"
                    name="apellido"
                    value={formData.apellido}
                    onChange={handleInputChange}
                    className="input-field"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>Email</label>
                  <input
                    type="email"
                    name="email"
                    value={formData.email}
                    onChange={handleInputChange}
                    className="input-field"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>Tel√©fono</label>
                  <input
                    type="tel"
                    name="telefono"
                    value={formData.telefono}
                    onChange={handleInputChange}
                    className="input-field"
                  />
                </div>
                
                <div className="form-group">
                  <label>Rol</label>
                  <select
                    name="rol"
                    value={formData.rol}
                    onChange={handleInputChange}
                    className="select-field"
                    required
                  >
                    <option value="becario">Becario</option>
                    <option value="psicologo">Psic√≥logo</option>
                    <option value="coordinador">Coordinador</option>
                  </select>
                </div>
                
                <div className="form-group">
                  <label>Especialidad</label>
                  <input
                    type="text"
                    name="especialidad"
                    value={formData.especialidad}
                    onChange={handleInputChange}
                    className="input-field"
                    placeholder="Ej: Terapia Cognitivo-Conductual"
                  />
                </div>
                
                {formData.rol === 'psicologo' && (
                  <div className="form-group" style={{ gridColumn: 'span 2' }}>
                    <label>Contrase√±a Temporal</label>
                    <input
                      type="text"
                      name="password"
                      value={formData.password}
                      className="input-field"
                      readOnly
                    />
                    <p className="text-small mt-5">El usuario deber√° cambiar la contrase√±a en su primer inicio</p>
                  </div>
                )}
                
                <div className="form-group">
                  <label className="flex-row align-center gap-10">
                    <input
                      type="checkbox"
                      name="activo"
                      checked={formData.activo}
                      onChange={handleInputChange}
                    />
                    <span>Usuario activo</span>
                  </label>
                </div>
              </div>
              
              <div className="modal-footer">
                <button type="submit" className="btn-primary">
                  {modalType === 'nuevo' ? 'Crear Usuario' : 'Guardar Cambios'}
                </button>
                <button 
                  type="button" 
                  className="btn-danger"
                  onClick={() => setShowModal(false)}
                >
                  Cancelar
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoordinadorUsuarios;

/frontend\src\pages\psicologo\CitasPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiCalendar, FiClock, FiUser, FiFilter, 
  FiChevronLeft, FiChevronRight, FiRefreshCw,
  FiCheckCircle, FiXCircle, FiEdit2
} from 'react-icons/fi';
import { format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoCitas = () => {
  const [citas, setCitas] = useState([]);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [loading, setLoading] = useState(true);
  const [filterBecario, setFilterBecario] = useState('');
  const [filterEstado, setFilterEstado] = useState('');
  const [becarios, setBecarios] = useState([]);

  useEffect(() => {
    fetchData();
  }, [selectedDate]);

  const fetchData = async () => {
    try {
      setLoading(true);
      
      // Simulaci√≥n de datos
      setTimeout(() => {
        setCitas([
          {
            id: 1,
            paciente_nombre: 'Carlos G√≥mez',
            fecha: format(new Date(), 'yyyy-MM-dd'),
            hora: '10:00',
            tipo_consulta: 'presencial',
            estado: 'confirmada',
            duracion: 50,
            becario_nombre: 'Juan P√©rez',
            notas: 'Segunda sesi√≥n de exposici√≥n gradual'
          },
          {
            id: 2,
            paciente_nombre: 'Mariana L√≥pez',
            fecha: format(new Date(), 'yyyy-MM-dd'),
            hora: '11:30',
            tipo_consulta: 'virtual',
            estado: 'programada',
            duracion: 45,
            becario_nombre: 'Sof√≠a Ram√≠rez',
            notas: 'Seguimiento de tareas asignadas'
          },
          {
            id: 3,
            paciente_nombre: 'Roberto S√°nchez',
            fecha: format(new Date(), 'yyyy-MM-dd'),
            hora: '14:00',
            tipo_consulta: 'presencial',
            estado: 'completada',
            duracion: 60,
            becario_nombre: null,
            notas: 'Evaluaci√≥n de progreso'
          }
        ]);
        
        setBecarios([
          { id: 1, nombre: 'Juan P√©rez', apellido: 'P√©rez' },
          { id: 2, nombre: 'Sof√≠a', apellido: 'Ram√≠rez' }
        ]);
        
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al cargar citas:', error);
      setLoading(false);
    }
  };

  const filteredCitas = citas.filter(cita => {
    const matchesBecario = !filterBecario || cita.becario_nombre?.includes(filterBecario);
    const matchesEstado = !filterEstado || cita.estado === filterEstado;
    return matchesBecario && matchesEstado;
  });

  const goToPreviousDay = () => {
    setSelectedDate(prev => subDays(prev, 1));
  };

  const goToNextDay = () => {
    setSelectedDate(prev => addDays(prev, 1));
  };

  const goToToday = () => {
    setSelectedDate(new Date());
  };

  const formatDateSpanish = (date) => {
    return format(date, "EEEE d 'de' MMMM, yyyy", { locale: es });
  };

  const handleEstadoCita = (citaId, nuevoEstado) => {
    setCitas(prev => 
      prev.map(cita => 
        cita.id === citaId ? { ...cita, estado: nuevoEstado } : cita
      )
    );
    notifications.success(`Cita ${nuevoEstado === 'completada' ? 'marcada como completada' : 'cancelada'}`);
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando citas...</div>
      </div>
    );
  }

  return (
    <div className="citas-page">
      <div className="page-header">
        <div>
          <h1>Mis Citas</h1>
          <p>Agenda de sesiones y supervisiones</p>
        </div>
        <button className="btn-secondary" onClick={fetchData}>
          <FiRefreshCw /> Actualizar
        </button>
      </div>

      <div className="calendar-controls">
        <div className="date-navigation">
          <button className="btn-text" onClick={goToPreviousDay}>
            <FiChevronLeft /> Ayer
          </button>
          
          <div className="current-date">
            <h3>{formatDateSpanish(selectedDate)}</h3>
          </div>
          
          <button className="btn-text" onClick={goToNextDay}>
            Ma√±ana <FiChevronRight />
          </button>
        </div>

        <div className="quick-actions">
          <button className="btn-secondary" onClick={goToToday}>
            Hoy
          </button>
        </div>
      </div>

      {/* Filtros */}
      <div className="filters-container mb-20">
        <div className="grid-2 gap-20">
          <div className="form-group">
            <label>Filtrar por becario</label>
            <select 
              value={filterBecario} 
              onChange={(e) => setFilterBecario(e.target.value)}
              className="select-field"
            >
              <option value="">Todos los becarios</option>
              {becarios.map(becario => (
                <option key={becario.id} value={becario.nombre}>
                  {becario.nombre} {becario.apellido}
                </option>
              ))}
              <option value="sin_becario">Sin becario</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>Filtrar por estado</label>
            <select 
              value={filterEstado} 
              onChange={(e) => setFilterEstado(e.target.value)}
              className="select-field"
            >
              <option value="">Todos los estados</option>
              <option value="programada">Programadas</option>
              <option value="confirmada">Confirmadas</option>
              <option value="completada">Completadas</option>
              <option value="cancelada">Canceladas</option>
            </select>
          </div>
        </div>
      </div>

      {/* Vista de Calendario */}
      <div className="calendar-day-view mb-20">
        <div className="time-column">
          {[9, 10, 11, 12, 13, 14, 15, 16, 17, 18].map(hour => (
            <div key={hour} className="time-slot">
              <span className="time-label">{hour}:00</span>
            </div>
          ))}
        </div>

        <div className="events-column">
          {[9, 10, 11, 12, 13, 14, 15, 16, 17, 18].map(hour => {
            const hourCitas = filteredCitas.filter(cita => 
              parseInt(cita.hora.split(':')[0]) === hour
            );

            return (
              <div key={hour} className="hour-slot">
                {hourCitas.map((cita) => (
                  <div 
                    key={cita.id}
                    className={`event-item ${
                      cita.estado === 'confirmada' ? 'event-confirmed' :
                      cita.estado === 'completada' ? 'event-completed' :
                      cita.estado === 'programada' ? 'event-pending' :
                      'event-cancelled'
                    }`}
                  >
                    <div className="event-header">
                      <div className="event-time">
                        <FiClock /> {cita.hora}
                      </div>
                      <div className="event-type">{cita.tipo_consulta}</div>
                    </div>
                    <div className="event-content">
                      <div className="event-patient">
                        <FiUser /> {cita.paciente_nombre}
                      </div>
                      {cita.becario_nombre && (
                        <div className="event-becario">üë®‚Äçüéì {cita.becario_nombre}</div>
                      )}
                      {cita.notas && (
                        <div className="event-notes">{cita.notas}</div>
                      )}
                    </div>
                    <div className="event-footer">
                      <span className={`badge ${
                        cita.estado === 'confirmada' ? 'badge-success' :
                        cita.estado === 'completada' ? 'badge-primary' :
                        cita.estado === 'programada' ? 'badge-warning' :
                        'badge-danger'
                      }`}>
                        {cita.estado}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            );
          })}
        </div>
      </div>

      {/* Lista de Citas */}
      <div className="day-citas-list">
        <h3>Citas para {formatDateSpanish(selectedDate)} ({filteredCitas.length})</h3>
        
        {filteredCitas.length > 0 ? (
          <div className="citas-cards">
            {filteredCitas.map((cita) => (
              <div key={cita.id} className="cita-card">
                <div className="cita-card-header">
                  <div className="cita-time">
                    <FiClock /> {cita.hora} ({cita.duracion} min)
                  </div>
                  <div className={`cita-status badge ${
                    cita.estado === 'confirmada' ? 'badge-success' :
                    cita.estado === 'completada' ? 'badge-primary' :
                    cita.estado === 'programada' ? 'badge-warning' :
                    'badge-danger'
                  }`}>
                    {cita.estado}
                  </div>
                </div>
                
                <div className="cita-card-body">
                  <div className="cita-paciente">
                    <FiUser /> {cita.paciente_nombre}
                  </div>
                  
                  <div className="cita-info">
                    <div className="cita-tipo">
                      {cita.tipo_consulta === 'presencial' ? 'üìã Presencial' : 'üíª Virtual'}
                    </div>
                    
                    {cita.becario_nombre && (
                      <div className="cita-becario">
                        üë®‚Äçüéì {cita.becario_nombre}
                      </div>
                    )}
                    
                    {cita.notas && (
                      <div className="cita-notas">
                        <strong>Notas:</strong> {cita.notas}
                      </div>
                    )}
                  </div>
                </div>
                
                <div className="cita-card-footer">
                  <button className="btn-text">
                    <FiEdit2 /> Editar
                  </button>
                  
                  {cita.estado === 'confirmada' && (
                    <button 
                      className="btn-text text-success"
                      onClick={() => handleEstadoCita(cita.id, 'completada')}
                    >
                      <FiCheckCircle /> Completar
                    </button>
                  )}
                  
                  {(cita.estado === 'programada' || cita.estado === 'confirmada') && (
                    <button 
                      className="btn-text text-danger"
                      onClick={() => handleEstadoCita(cita.id, 'cancelada')}
                    >
                      <FiXCircle /> Cancelar
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">üìÖ</div>
            <div>No hay citas programadas para este d√≠a</div>
            <p className="text-small mt-10">Prueba con otros filtros o selecciona otra fecha</p>
          </div>
        )}
      </div>

      {/* Estad√≠sticas del D√≠a */}
      <div className="grid-3 mt-20">
        <div className="card">
          <h4>Resumen del D√≠a</h4>
          <div className="mt-10">
            <p>Total: {citas.length}</p>
            <p>Confirmadas: {citas.filter(c => c.estado === 'confirmada').length}</p>
            <p>Con becario: {citas.filter(c => c.becario_nombre).length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Tipos de Consulta</h4>
          <div className="mt-10">
            <p>Presencial: {citas.filter(c => c.tipo_consulta === 'presencial').length}</p>
            <p>Virtual: {citas.filter(c => c.tipo_consulta === 'virtual').length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Acciones</h4>
          <div className="mt-10 flex-col gap-10">
            <button className="btn-primary w-100">
              Agendar Cita
            </button>
            <button className="btn-secondary w-100">
              Ver Agenda Semanal
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PsicologoCitas;

/frontend\src\pages\psicologo\DashboardPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  FiUsers, FiCalendar, FiTrendingUp, FiBarChart2,
  FiUserCheck, FiClock, FiRefreshCw
} from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoDashboard = () => {
  const [estadisticas, setEstadisticas] = useState({
    pacientesActivos: 0,
    citasHoy: 0,
    citasSemana: 0,
    becariosAsignados: 0,
    sesionesMes: 0,
    altasMes: 0
  });
  const [citasHoy, setCitasHoy] = useState([]);
  const [becarios, setBecarios] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setEstadisticas({
          pacientesActivos: 12,
          citasHoy: 4,
          citasSemana: 15,
          becariosAsignados: 2,
          sesionesMes: 48,
          altasMes: 2
        });
        
        setCitasHoy([
          { id: 1, paciente: 'Carlos G√≥mez', hora: '10:00 AM', tipo: 'presencial' },
          { id: 2, paciente: 'Mariana L√≥pez', hora: '11:30 AM', tipo: 'virtual' },
          { id: 3, paciente: 'Roberto S√°nchez', hora: '02:00 PM', tipo: 'presencial' },
          { id: 4, paciente: 'Ana Rodr√≠guez', hora: '04:30 PM', tipo: 'virtual' }
        ]);
        
        setBecarios([
          { id: 1, nombre: 'Juan P√©rez', pacientes: 3, observaciones: 5 },
          { id: 2, nombre: 'Sof√≠a Ram√≠rez', pacientes: 2, observaciones: 3 }
        ]);
        
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error cargando dashboard:', error);
      setLoading(false);
    }
  };

  const statCards = [
    {
      title: 'Pacientes Activos',
      value: estadisticas.pacientesActivos,
      icon: <FiUsers />,
      color: 'var(--grnb)',
      change: 'En tratamiento'
    },
    {
      title: 'Citas Hoy',
      value: estadisticas.citasHoy,
      icon: <FiCalendar />,
      color: 'var(--blu)',
      change: 'Programadas'
    },
    {
      title: 'Citas Esta Semana',
      value: estadisticas.citasSemana,
      icon: <FiClock />,
      color: 'var(--yy)',
      change: 'Pr√≥ximos 7 d√≠as'
    },
    {
      title: 'Becarios Asignados',
      value: estadisticas.becariosAsignados,
      icon: <FiUserCheck />,
      color: 'var(--grnd)',
      change: 'En supervisi√≥n'
    },
    {
      title: 'Sesiones Mes',
      value: estadisticas.sesionesMes,
      icon: <FiTrendingUp />,
      color: 'var(--grnl)',
      change: 'Realizadas'
    },
    {
      title: 'Altas Este Mes',
      value: estadisticas.altasMes,
      icon: <FiBarChart2 />,
      color: 'var(--rr)',
      change: 'Pacientes dados de alta'
    }
  ];

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando panel del psic√≥logo...</div>
      </div>
    );
  }

  return (
    <div className="dashboard-page">
      <div className="page-header">
        <div>
          <h1>Panel del Psic√≥logo</h1>
          <p>Supervisi√≥n y gesti√≥n de pacientes</p>
        </div>
        <button className="btn-secondary" onClick={fetchDashboardData}>
          <FiRefreshCw /> Actualizar
        </button>
      </div>

      {/* Stats Grid */}
      <div className="stats-grid">
        {statCards.map((stat, index) => (
          <div key={index} className="stat-card">
            <div className="stat-header">
              <div className="stat-icon" style={{ color: stat.color }}>
                {stat.icon}
              </div>
              <h3>{stat.title}</h3>
            </div>
            <div className="stat-value">{stat.value}</div>
            <div className="stat-change">{stat.change}</div>
          </div>
        ))}
      </div>

      {/* Main Content Grid */}
      <div className="dashboard-content-grid">
        {/* Citas de Hoy */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Citas de Hoy</h3>
            <button className="btn-text">Ver Agenda</button>
          </div>
          
          <div className="citas-list">
            {citasHoy.map((cita) => (
              <div key={cita.id} className="cita-item">
                <div className="cita-info">
                  <div className="cita-paciente">{cita.paciente}</div>
                  <div className="cita-hora">{cita.hora} ‚Ä¢ {cita.tipo === 'presencial' ? 'Presencial' : 'Virtual'}</div>
                </div>
                <button className="btn-text">Ver</button>
              </div>
            ))}
          </div>
        </div>

        {/* Becarios Asignados */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Becarios en Supervisi√≥n</h3>
            <button className="btn-text">Ver todos</button>
          </div>
          
          <div className="pacientes-list">
            {becarios.map((becario) => (
              <div key={becario.id} className="paciente-item">
                <div className="paciente-info">
                  <div className="paciente-nombre">{becario.nombre}</div>
                  <div className="paciente-fecha">
                    {becario.pacientes} pacientes ‚Ä¢ {becario.observaciones} observaciones
                  </div>
                </div>
                <div className="paciente-progreso">
                  <div className="progress-container">
                    <div 
                      className="progress-bar"
                      style={{ width: `${(becario.observaciones / 10) * 100}%` }}
                    ></div>
                  </div>
                  <span className="progreso-text">
                    {Math.round((becario.observaciones / 10) * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Estad√≠sticas Mensuales */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Estad√≠sticas del Mes</h3>
          </div>
          
          <div className="activity-chart">
            <div className="chart-placeholder">
              <div className="chart-bars">
                {[65, 80, 45, 90, 75, 60, 85, 70, 95, 50, 65, 80].map((height, index) => (
                  <div key={index} className="chart-bar">
                    <div 
                      className="bar-fill"
                      style={{ height: `${height}%` }}
                    ></div>
                    <div className="bar-label">
                      {['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'][index]}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* Quick Actions */}
        <div className="dashboard-section">
          <div className="section-header">
            <h3>Acciones R√°pidas</h3>
          </div>
          
          <div className="quick-actions">
            <button className="btn-primary w-100 mb-10">
              Ver Mis Pacientes
            </button>
            <button className="btn-secondary w-100 mb-10">
              Registrar Sesi√≥n
            </button>
            <button className="btn-warning w-100 mb-10">
              Revisar Observaciones
            </button>
            <button className="btn-text w-100">
              Generar Reporte Mensual
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PsicologoDashboard;

/frontend\src\pages\psicologo\ExpedientesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiFileText, FiCalendar, FiUser, FiPhone, FiMail, FiDownload } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoExpedientes = () => {
  const [expedientes, setExpedientes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedExpediente, setSelectedExpediente] = useState(null);
  const [showDetalles, setShowDetalles] = useState(false);

  useEffect(() => {
    fetchExpedientes();
  }, []);

  const fetchExpedientes = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setExpedientes([
          {
            id: 1,
            paciente_nombre: 'Carlos G√≥mez',
            edad: 25,
            fecha_ingreso: '2023-10-15',
            diagnostico: 'Trastorno de ansiedad generalizada',
            motivo_consulta: 'Ansiedad acad√©mica',
            antecedentes: 'No significativos',
            tratamiento_actual: 'Terapia cognitivo-conductual',
            medicacion: 'No',
            ultima_evaluacion: '2024-01-10',
            proxima_cita: '2024-01-17',
            sesiones_totales: 8,
            evolucion: 'Mejor√≠a progresiva en manejo de ansiedad'
          },
          {
            id: 2,
            paciente_nombre: 'Mariana L√≥pez',
            edad: 28,
            fecha_ingreso: '2023-09-20',
            diagnostico: 'S√≠ndrome de burnout',
            motivo_consulta: 'Estr√©s laboral',
            antecedentes: 'Antecedentes familiares de ansiedad',
            tratamiento_actual: 'Terapia de aceptaci√≥n y compromiso',
            medicacion: 'No',
            ultima_evaluacion: '2024-01-09',
            proxima_cita: '2024-01-16',
            sesiones_totales: 12,
            evolucion: 'Mejor manejo de l√≠mites laborales'
          }
        ]);
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al obtener expedientes:', error);
      setLoading(false);
    }
  };

  const filteredExpedientes = expedientes.filter(expediente =>
    expediente.paciente_nombre.toLowerCase().includes(searchTerm.toLowerCase()) ||
    expediente.diagnostico.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const showExpedienteDetalles = (expediente) => {
    setSelectedExpediente(expediente);
    setShowDetalles(true);
  };

  const exportarExpediente = (expediente) => {
    // Simulaci√≥n de exportaci√≥n
    notifications.success(`Exportando expediente de ${expediente.paciente_nombre}...`);
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando expedientes...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Expedientes Cl√≠nicos</h1>
          <p>Historial cl√≠nico completo de pacientes</p>
        </div>
      </div>

      {/* B√∫squeda */}
      <div className="search-box mb-20">
        <FiSearch />
        <input
          type="text"
          className="search-input"
          placeholder="Buscar expediente por nombre o diagn√≥stico..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      {/* Lista de Expedientes */}
      <div className="grid-2 gap-20">
        {filteredExpedientes.map((expediente) => (
          <div key={expediente.id} className="card">
            <div className="flex-row align-center justify-between mb-10">
              <div className="flex-row align-center gap-10">
                <div className="avatar">
                  {expediente.paciente_nombre.split(' ').map(n => n[0]).join('')}
                </div>
                <div>
                  <h3>{expediente.paciente_nombre}</h3>
                  <p className="text-small">{expediente.edad} a√±os</p>
                </div>
              </div>
              <button 
                className="btn-text"
                onClick={() => exportarExpediente(expediente)}
                title="Exportar expediente"
              >
                <FiDownload />
              </button>
            </div>

            <div className="mb-10">
              <p><strong>Diagn√≥stico:</strong> {expediente.diagnostico}</p>
              <p><strong>Tratamiento:</strong> {expediente.tratamiento_actual}</p>
              <p><strong>Sesiones totales:</strong> {expediente.sesiones_totales}</p>
            </div>

            <div className="flex-row gap-10">
              <button 
                className="btn-primary flex-1"
                onClick={() => showExpedienteDetalles(expediente)}
              >
                <FiFileText /> Ver Expediente
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Modal de Detalles del Expediente */}
      {showDetalles && selectedExpediente && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>Expediente Cl√≠nico de {selectedExpediente.paciente_nombre}</h3>
              <button className="modal-close" onClick={() => setShowDetalles(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="grid-2 gap-20">
                <div>
                  <h4>Datos Generales</h4>
                  <div className="detail-row">
                    <strong>Paciente:</strong> {selectedExpediente.paciente_nombre}
                  </div>
                  <div className="detail-row">
                    <strong>Edad:</strong> {selectedExpediente.edad} a√±os
                  </div>
                  <div className="detail-row">
                    <strong>Fecha de ingreso:</strong> {new Date(selectedExpediente.fecha_ingreso).toLocaleDateString()}
                  </div>
                  <div className="detail-row">
                    <strong>Motivo de consulta:</strong> {selectedExpediente.motivo_consulta}
                  </div>
                </div>
                
                <div>
                  <h4>Informaci√≥n Cl√≠nica</h4>
                  <div className="detail-row">
                    <strong>Diagn√≥stico:</strong> {selectedExpediente.diagnostico}
                  </div>
                  <div className="detail-row">
                    <strong>Antecedentes:</strong> {selectedExpediente.antecedentes}
                  </div>
                  <div className="detail-row">
                    <strong>Tratamiento actual:</strong> {selectedExpediente.tratamiento_actual}
                  </div>
                  <div className="detail-row">
                    <strong>Medicaci√≥n:</strong> {selectedExpediente.medicacion}
                  </div>
                </div>
              </div>
              
              <div className="mt-20">
                <h4>Evoluci√≥n y Seguimiento</h4>
                <div className="detail-row">
                  <strong>Evoluci√≥n cl√≠nica:</strong> {selectedExpediente.evolucion}
                </div>
                <div className="detail-row">
                  <strong>Sesiones totales:</strong> {selectedExpediente.sesiones_totales}
                </div>
                <div className="detail-row">
                  <strong>√öltima evaluaci√≥n:</strong> {new Date(selectedExpediente.ultima_evaluacion).toLocaleDateString()}
                </div>
                <div className="detail-row">
                  <strong>Pr√≥xima cita:</strong> {selectedExpediente.proxima_cita ? new Date(selectedExpediente.proxima_cita).toLocaleDateString() : 'No programada'}
                </div>
              </div>
              
              <div className="mt-20">
                <h4>Historial de Sesiones</h4>
                <div className="timeline mt-10">
                  <div className="timeline-item">
                    <div className="timeline-content">
                      <strong>2024-01-10 - Sesi√≥n 8</strong>
                      <p>Continuaci√≥n trabajo en exposici√≥n gradual. Paciente reporta menor ansiedad anticipatoria.</p>
                    </div>
                  </div>
                  <div className="timeline-item">
                    <div className="timeline-content">
                      <strong>2024-01-03 - Sesi√≥n 7</strong>
                      <p>Introducci√≥n de t√©cnicas de exposici√≥n. Paciente colaborador y motivado.</p>
                    </div>
                  </div>
                  <div className="timeline-item">
                    <div className="timeline-content">
                      <strong>2023-12-27 - Sesi√≥n 6</strong>
                      <p>Revisi√≥n de tareas. Buen progreso en identificaci√≥n de pensamientos autom√°ticos.</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowDetalles(false)}>
                Cerrar
              </button>
              <button className="btn-primary" onClick={() => exportarExpediente(selectedExpediente)}>
                <FiDownload /> Exportar Expediente
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PsicologoExpedientes;

/frontend\src\pages\psicologo\PacientesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiSearch, FiUser, FiCalendar, FiPhone, FiMail, FiFileText, FiFilter } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoPacientes = () => {
  const [pacientes, setPacientes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedPaciente, setSelectedPaciente] = useState(null);
  const [showDetalles, setShowDetalles] = useState(false);
  const [filterEstado, setFilterEstado] = useState('');

  useEffect(() => {
    fetchPacientes();
  }, []);

  const fetchPacientes = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setPacientes([
          {
            id: 1,
            nombre: 'Carlos G√≥mez',
            edad: 25,
            telefono: '555-1234',
            email: 'carlos@email.com',
            motivo_consulta: 'Ansiedad acad√©mica',
            diagnostico: 'Trastorno de ansiedad generalizada',
            ultima_sesion: '2024-01-10',
            proxima_cita: '2024-01-17',
            sesiones_completadas: 8,
            estado: 'activo',
            becario: 'Juan P√©rez'
          },
          {
            id: 2,
            nombre: 'Mariana L√≥pez',
            edad: 28,
            telefono: '555-5678',
            email: 'mariana@email.com',
            motivo_consulta: 'Estr√©s laboral',
            diagnostico: 'S√≠ndrome de burnout',
            ultima_sesion: '2024-01-09',
            proxima_cita: '2024-01-16',
            sesiones_completadas: 12,
            estado: 'activo',
            becario: 'Sof√≠a Ram√≠rez'
          },
          {
            id: 3,
            nombre: 'Roberto S√°nchez',
            edad: 22,
            telefono: '555-9012',
            email: 'roberto@email.com',
            motivo_consulta: 'Problemas de adaptaci√≥n',
            diagnostico: 'Trastorno adaptativo',
            ultima_sesion: '2024-01-08',
            proxima_cita: '2024-01-15',
            sesiones_completadas: 5,
            estado: 'activo',
            becario: null
          },
          {
            id: 4,
            nombre: 'Ana Rodr√≠guez',
            edad: 35,
            telefono: '555-3456',
            email: 'ana@email.com',
            motivo_consulta: 'Depresi√≥n',
            diagnostico: 'Episodio depresivo moderado',
            ultima_sesion: '2024-01-05',
            proxima_cita: null,
            sesiones_completadas: 20,
            estado: 'alta_terapeutica',
            becario: 'Juan P√©rez'
          }
        ]);
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al obtener pacientes:', error);
      setLoading(false);
    }
  };

  const filteredPacientes = pacientes.filter(paciente => {
    const matchesSearch = 
      paciente.nombre.toLowerCase().includes(searchTerm.toLowerCase()) ||
      paciente.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
      paciente.diagnostico.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesEstado = !filterEstado || paciente.estado === filterEstado;
    
    return matchesSearch && matchesEstado;
  });

  const showPacienteDetalles = (paciente) => {
    setSelectedPaciente(paciente);
    setShowDetalles(true);
  };

  const getEstadoLabel = (estado) => {
    switch (estado) {
      case 'activo':
        return { text: 'Activo', color: 'success' };
      case 'alta_terapeutica':
        return { text: 'Alta Terap√©utica', color: 'primary' };
      case 'abandono':
        return { text: 'Abandono', color: 'danger' };
      default:
        return { text: estado, color: 'warning' };
    }
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando pacientes...</div>
      </div>
    );
  }

  return (
    <div className="pacientes-page">
      <div className="page-header">
        <div>
          <h1>Mis Pacientes</h1>
          <p>Gesti√≥n de pacientes en tratamiento</p>
        </div>
      </div>

      {/* Filtros y B√∫squeda */}
      <div className="filters-container mb-20">
        <div className="search-box">
          <FiSearch />
          <input
            type="text"
            className="search-input"
            placeholder="Buscar paciente por nombre, email o diagn√≥stico..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
        
        <div className="filter-buttons">
          <select 
            value={filterEstado} 
            onChange={(e) => setFilterEstado(e.target.value)}
            className="select-field"
            style={{ width: '200px' }}
          >
            <option value="">Todos los estados</option>
            <option value="activo">Activos</option>
            <option value="alta_terapeutica">Altas Terap√©uticas</option>
            <option value="abandono">Abandonos</option>
          </select>
        </div>
      </div>

      {/* Tabla de Pacientes */}
      <div className="table-container">
        <table className="data-table">
          <thead>
            <tr>
              <th>Paciente</th>
              <th>Contacto</th>
              <th>Diagn√≥stico</th>
              <th>Sesiones</th>
              <th>√öltima Sesi√≥n</th>
              <th>Becario</th>
              <th>Estado</th>
              <th>Acciones</th>
            </tr>
          </thead>
          <tbody>
            {filteredPacientes.map((paciente) => {
              const estadoInfo = getEstadoLabel(paciente.estado);
              
              return (
                <tr key={paciente.id}>
                  <td>
                    <div className="flex-row align-center gap-10">
                      <div className="avatar">
                        {paciente.nombre.split(' ').map(n => n[0]).join('')}
                      </div>
                      <div>
                        <div className="font-bold">{paciente.nombre}</div>
                        <div className="text-small">{paciente.edad} a√±os</div>
                      </div>
                    </div>
                  </td>
                  <td>
                    <div>{paciente.email}</div>
                    <div className="text-small">{paciente.telefono}</div>
                  </td>
                  <td>
                    <div className="diagnostico-tag">{paciente.diagnostico}</div>
                  </td>
                  <td>
                    <div className="font-bold">{paciente.sesiones_completadas}</div>
                    <div className="text-small">sesiones</div>
                  </td>
                  <td>
                    {paciente.ultima_sesion ? new Date(paciente.ultima_sesion).toLocaleDateString() : 'N/A'}
                  </td>
                  <td>
                    {paciente.becario || 'Sin asignar'}
                  </td>
                  <td>
                    <span className={`badge badge-${estadoInfo.color}`}>
                      {estadoInfo.text}
                    </span>
                  </td>
                  <td>
                    <div className="flex-row gap-5">
                      <button 
                        className="btn-text"
                        onClick={() => showPacienteDetalles(paciente)}
                        title="Ver detalles"
                      >
                        <FiFileText />
                      </button>
                      <button 
                        className="btn-text"
                        title="Agendar cita"
                      >
                        <FiCalendar />
                      </button>
                    </div>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Resumen */}
      <div className="grid-3 mt-20">
        <div className="card">
          <h4>Resumen de Pacientes</h4>
          <div className="mt-10">
            <p>Total: {pacientes.length}</p>
            <p>Activos: {pacientes.filter(p => p.estado === 'activo').length}</p>
            <p>Con becario: {pacientes.filter(p => p.becario).length}</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Sesiones Totales</h4>
          <div className="mt-10">
            <p className="stat-value">{pacientes.reduce((sum, p) => sum + p.sesiones_completadas, 0)}</p>
            <p className="text-small">sesiones realizadas</p>
          </div>
        </div>
        
        <div className="card">
          <h4>Acciones</h4>
          <div className="mt-10 flex-col gap-10">
            <button className="btn-primary w-100">
              Agendar Cita Grupal
            </button>
            <button className="btn-secondary w-100">
              Generar Reporte
            </button>
          </div>
        </div>
      </div>

      {/* Modal de Detalles */}
      {showDetalles && selectedPaciente && (
        <div className="modal-overlay">
          <div className="modal-container modal-large">
            <div className="modal-header">
              <h3>Expediente de {selectedPaciente.nombre}</h3>
              <button className="modal-close" onClick={() => setShowDetalles(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="grid-2 gap-20">
                <div>
                  <h4>Datos Personales</h4>
                  <div className="detail-row">
                    <strong>Nombre:</strong> {selectedPaciente.nombre}
                  </div>
                  <div className="detail-row">
                    <strong>Edad:</strong> {selectedPaciente.edad} a√±os
                  </div>
                  <div className="detail-row">
                    <strong>Contacto:</strong> {selectedPaciente.telefono} ‚Ä¢ {selectedPaciente.email}
                  </div>
                  <div className="detail-row">
                    <strong>Motivo de consulta:</strong> {selectedPaciente.motivo_consulta}
                  </div>
                </div>
                
                <div>
                  <h4>Informaci√≥n Cl√≠nica</h4>
                  <div className="detail-row">
                    <strong>Diagn√≥stico:</strong> {selectedPaciente.diagnostico}
                  </div>
                  <div className="detail-row">
                    <strong>Estado:</strong> 
                    <span className={`badge badge-${getEstadoLabel(selectedPaciente.estado).color} ml-10`}>
                      {getEstadoLabel(selectedPaciente.estado).text}
                    </span>
                  </div>
                  <div className="detail-row">
                    <strong>Sesiones completadas:</strong> {selectedPaciente.sesiones_completadas}
                  </div>
                  <div className="detail-row">
                    <strong>Becario asignado:</strong> {selectedPaciente.becario || 'No asignado'}
                  </div>
                </div>
              </div>
              
              <div className="mt-20">
                <h4>Historial de Sesiones</h4>
                <div className="table-container mt-10">
                  <table className="data-table">
                    <thead>
                      <tr>
                        <th>Fecha</th>
                        <th>Tipo</th>
                        <th>Duraci√≥n</th>
                        <th>Observaciones</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>{new Date(selectedPaciente.ultima_sesion).toLocaleDateString()}</td>
                        <td>Presencial</td>
                        <td>50 min</td>
                        <td>Avance en t√©cnicas de relajaci√≥n</td>
                      </tr>
                      <tr>
                        <td>2024-01-03</td>
                        <td>Virtual</td>
                        <td>45 min</td>
                        <td>Trabajo en identificaci√≥n de pensamientos autom√°ticos</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowDetalles(false)}>
                Cerrar
              </button>
              <button className="btn-primary">
                Agendar Nueva Sesi√≥n
              </button>
              <button className="btn-warning">
                Registrar Sesi√≥n
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PsicologoPacientes;

/frontend\src\pages\psicologo\SesionesPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiCalendar, FiUser, FiFileText, FiPlus, FiEdit2, FiSave } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoSesiones = () => {
  const [sesiones, setSesiones] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [formData, setFormData] = useState({
    paciente_id: '',
    fecha: new Date().toISOString().split('T')[0],
    hora_inicio: '10:00',
    hora_fin: '11:00',
    motivo_consulta: '',
    contenido_sesion: '',
    observaciones: '',
    tareas_asignadas: '',
    proxima_sesion: ''
  });
  const [pacientes, setPacientes] = useState([]);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setPacientes([
          { id: 1, nombre: 'Carlos G√≥mez' },
          { id: 2, nombre: 'Mariana L√≥pez' },
          { id: 3, nombre: 'Roberto S√°nchez' }
        ]);
        
        setSesiones([
          {
            id: 1,
            paciente_nombre: 'Carlos G√≥mez',
            fecha: '2024-01-10',
            hora_inicio: '10:00',
            hora_fin: '11:00',
            motivo_consulta: 'Ansiedad acad√©mica',
            contenido_sesion: 'Exposici√≥n gradual a situaciones acad√©micas estresantes',
            observaciones: 'Paciente mostr√≥ buena disposici√≥n y colaboraci√≥n',
            tareas_asignadas: 'Practicar t√©cnicas de relajaci√≥n 10 min/d√≠a',
            proxima_sesion: '2024-01-17'
          },
          {
            id: 2,
            paciente_nombre: 'Mariana L√≥pez',
            fecha: '2024-01-09',
            hora_inicio: '11:30',
            hora_fin: '12:15',
            motivo_consulta: 'Estr√©s laboral',
            contenido_sesion: 'Trabajo en establecimiento de l√≠mites laborales',
            observaciones: 'Paciente reporta mejor manejo de situaciones laborales',
            tareas_asignadas: 'Registrar situaciones estresantes en el trabajo',
            proxima_sesion: '2024-01-16'
          }
        ]);
        
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al cargar datos:', error);
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    const nuevaSesion = {
      id: sesiones.length + 1,
      paciente_nombre: pacientes.find(p => p.id == formData.paciente_id)?.nombre || 'Paciente',
      ...formData
    };
    
    setSesiones([nuevaSesion, ...sesiones]);
    setShowForm(false);
    resetForm();
    
    notifications.success('Sesi√≥n registrada exitosamente');
  };

  const resetForm = () => {
    setFormData({
      paciente_id: '',
      fecha: new Date().toISOString().split('T')[0],
      hora_inicio: '10:00',
      hora_fin: '11:00',
      motivo_consulta: '',
      contenido_sesion: '',
      observaciones: '',
      tareas_asignadas: '',
      proxima_sesion: ''
    });
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando sesiones...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Registro de Sesiones</h1>
          <p>Registro detallado de sesiones terap√©uticas</p>
        </div>
        <button 
          className="btn-primary"
          onClick={() => setShowForm(true)}
        >
          <FiPlus /> Nueva Sesi√≥n
        </button>
      </div>

      {/* Formulario de Nueva Sesi√≥n */}
      {showForm && (
        <div className="card mb-20">
          <div className="modal-header">
            <h3>Registrar Nueva Sesi√≥n</h3>
            <button className="modal-close" onClick={() => setShowForm(false)}>√ó</button>
          </div>
          
          <form onSubmit={handleSubmit}>
            <div className="form-grid">
              <div className="form-group">
                <label>Paciente</label>
                <select
                  name="paciente_id"
                  value={formData.paciente_id}
                  onChange={handleInputChange}
                  className="select-field"
                  required
                >
                  <option value="">Seleccionar paciente</option>
                  {pacientes.map(paciente => (
                    <option key={paciente.id} value={paciente.id}>
                      {paciente.nombre}
                    </option>
                  ))}
                </select>
              </div>
              
              <div className="form-group">
                <label>Fecha de sesi√≥n</label>
                <input
                  type="date"
                  name="fecha"
                  value={formData.fecha}
                  onChange={handleInputChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group">
                <label>Hora inicio</label>
                <input
                  type="time"
                  name="hora_inicio"
                  value={formData.hora_inicio}
                  onChange={handleInputChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group">
                <label>Hora fin</label>
                <input
                  type="time"
                  name="hora_fin"
                  value={formData.hora_fin}
                  onChange={handleInputChange}
                  className="input-field"
                  required
                />
              </div>
              
              <div className="form-group" style={{ gridColumn: 'span 2' }}>
                <label>Motivo de consulta</label>
                <input
                  type="text"
                  name="motivo_consulta"
                  value={formData.motivo_consulta}
                  onChange={handleInputChange}
                  className="input-field"
                  required
                  placeholder="Motivo principal de la sesi√≥n"
                />
              </div>
              
              <div className="form-group" style={{ gridColumn: 'span 2' }}>
                <label>Contenido de la sesi√≥n</label>
                <textarea
                  name="contenido_sesion"
                  value={formData.contenido_sesion}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="4"
                  required
                  placeholder="Descripci√≥n detallada de lo trabajado en la sesi√≥n..."
                />
              </div>
              
              <div className="form-group">
                <label>Observaciones</label>
                <textarea
                  name="observaciones"
                  value={formData.observaciones}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="3"
                  placeholder="Observaciones relevantes del paciente..."
                />
              </div>
              
              <div className="form-group">
                <label>Tareas asignadas</label>
                <textarea
                  name="tareas_asignadas"
                  value={formData.tareas_asignadas}
                  onChange={handleInputChange}
                  className="textarea-field"
                  rows="3"
                  placeholder="Tareas o ejercicios para el paciente..."
                />
              </div>
              
              <div className="form-group">
                <label>Pr√≥xima sesi√≥n</label>
                <input
                  type="date"
                  name="proxima_sesion"
                  value={formData.proxima_sesion}
                  onChange={handleInputChange}
                  className="input-field"
                  placeholder="Fecha de pr√≥xima sesi√≥n"
                />
              </div>
            </div>
            
            <div className="form-actions">
              <button type="submit" className="btn-primary">
                <FiSave /> Guardar Sesi√≥n
              </button>
              <button 
                type="button" 
                className="btn-danger"
                onClick={() => {
                  setShowForm(false);
                  resetForm();
                }}
              >
                Cancelar
              </button>
            </div>
          </form>
        </div>
      )}

      {/* Lista de Sesiones Registradas */}
      <div className="config-content">
        <h3>Sesiones Registradas</h3>
        
        {sesiones.length > 0 ? (
          <div className="sesiones-list">
            {sesiones.map((sesion) => (
              <div key={sesion.id} className="accordion">
                <div className="accordion-header">
                  <div className="flex-row align-center gap-10">
                    <FiCalendar />
                    <span>{new Date(sesion.fecha).toLocaleDateString()}</span>
                  </div>
                  <div className="flex-row align-center gap-10">
                    <FiUser />
                    <span>{sesion.paciente_nombre}</span>
                  </div>
                  <div className="flex-row align-center gap-10">
                    <span>{sesion.hora_inicio} - {sesion.hora_fin}</span>
                  </div>
                </div>
                
                <div className="accordion-content">
                  <div className="grid-2 gap-20">
                    <div>
                      <h4>Motivo de consulta</h4>
                      <p>{sesion.motivo_consulta}</p>
                      
                      <h4 className="mt-10">Contenido de la sesi√≥n</h4>
                      <p>{sesion.contenido_sesion}</p>
                    </div>
                    
                    <div>
                      <h4>Observaciones</h4>
                      <p>{sesion.observaciones}</p>
                      
                      <h4 className="mt-10">Tareas asignadas</h4>
                      <p>{sesion.tareas_asignadas}</p>
                      
                      {sesion.proxima_sesion && (
                        <>
                          <h4 className="mt-10">Pr√≥xima sesi√≥n</h4>
                          <p>{new Date(sesion.proxima_sesion).toLocaleDateString()}</p>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="no-citas">
            <div className="no-citas-icon">üìã</div>
            <div>No hay sesiones registradas</div>
            <p className="text-small mt-10">
              Registra las sesiones terap√©uticas para mantener un historial completo.
            </p>
            <button 
              className="btn-text mt-10"
              onClick={() => setShowForm(true)}
            >
              <FiPlus /> Registrar tu primera sesi√≥n
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default PsicologoSesiones;

/frontend\src\pages\psicologo\SupervisionPage.js:
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { FiUser, FiFileText, FiCalendar, FiMessageSquare, FiCheckCircle, FiAlertCircle } from 'react-icons/fi';
import notifications from '../../utils/notifications';
import confirmations from '../../utils/confirmations';

const PsicologoSupervision = () => {
  const [becarios, setBecarios] = useState([]);
  const [observaciones, setObservaciones] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedBecario, setSelectedBecario] = useState(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [feedback, setFeedback] = useState('');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      // Simulaci√≥n de datos
      setTimeout(() => {
        setBecarios([
          {
            id: 1,
            nombre: 'Juan P√©rez',
            email: 'becario1@psicogestion.com',
            fecha_inicio: '2023-09-01',
            pacientes_asignados: 3,
            sesiones_supervisadas: 15,
            observaciones_pendientes: 2,
            ultima_supervision: '2024-01-08'
          },
          {
            id: 2,
            nombre: 'Sof√≠a Ram√≠rez',
            email: 'becario2@psicogestion.com',
            fecha_inicio: '2023-10-15',
            pacientes_asignados: 2,
            sesiones_supervisadas: 8,
            observaciones_pendientes: 1,
            ultima_supervision: '2024-01-05'
          }
        ]);
        
        setObservaciones([
          {
            id: 1,
            becario_nombre: 'Juan P√©rez',
            paciente_nombre: 'Carlos G√≥mez',
            fecha: '2024-01-10',
            contenido: 'El becario mostr√≥ buena empat√≠a y habilidades de escucha activa.',
            areas_mejora: 'Necesita trabajar en el manejo de silencios inc√≥modos.',
            feedback: 'Excelente manejo de la exposici√≥n gradual.',
            estado: 'revisada'
          },
          {
            id: 2,
            becario_nombre: 'Sof√≠a Ram√≠rez',
            paciente_nombre: 'Mariana L√≥pez',
            fecha: '2024-01-09',
            contenido: 'Buen trabajo en el establecimiento de l√≠mites laborales.',
            areas_mejora: 'Podr√≠a profundizar m√°s en el an√°lisis de pensamientos autom√°ticos.',
            feedback: '',
            estado: 'pendiente'
          }
        ]);
        
        setLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error al cargar datos:', error);
      setLoading(false);
    }
  };

  const enviarFeedback = (becarioId) => {
    if (!feedback.trim()) {
      notifications.success('Por favor, escribe alg√∫n feedback');
      return;
    }
    
    // Aqu√≠ se enviar√≠a al backend
    notifications.success(`Feedback enviado a ${becarios.find(b => b.id === becarioId)?.nombre}`);
    setFeedback('');
    setShowFeedback(false);
  };

  const getBecarioObservaciones = (becarioId) => {
    return observaciones.filter(obs => 
      obs.becario_nombre === becarios.find(b => b.id === becarioId)?.nombre
    );
  };

  if (loading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner"></div>
        <div className="loading-text">Cargando supervisi√≥n...</div>
      </div>
    );
  }

  return (
    <div className="configuracion-page">
      <div className="page-header">
        <div>
          <h1>Supervisi√≥n de Becarios</h1>
          <p>Gesti√≥n y seguimiento de becarios en formaci√≥n</p>
        </div>
      </div>

      {/* Lista de Becarios */}
      <div className="config-content">
        <h3>Becarios en Supervisi√≥n</h3>
        
        <div className="grid-2 gap-20 mt-20">
          {becarios.map((becario) => {
            const becarioObservaciones = getBecarioObservaciones(becario.id);
            const observacionesPendientes = becarioObservaciones.filter(o => o.estado === 'pendiente').length;
            
            return (
              <div key={becario.id} className="card">
                <div className="flex-row align-center justify-between mb-10">
                  <div className="flex-row align-center gap-10">
                    <div className="avatar">
                      {becario.nombre.split(' ').map(n => n[0]).join('')}
                    </div>
                    <div>
                      <h3>{becario.nombre}</h3>
                      <p className="text-small">{becario.email}</p>
                    </div>
                  </div>
                  {observacionesPendientes > 0 && (
                    <span className="badge badge-warning">
                      {observacionesPendientes} pendientes
                    </span>
                  )}
                </div>

                <div className="mb-10">
                  <div className="grid-2 gap-10">
                    <div>
                      <p><strong>Pacientes:</strong> {becario.pacientes_asignados}</p>
                      <p><strong>Sesiones:</strong> {becario.sesiones_supervisadas}</p>
                    </div>
                    <div>
                      <p><strong>Inicio:</strong> {new Date(becario.fecha_inicio).toLocaleDateString()}</p>
                      <p><strong>√öltima supervisi√≥n:</strong> {new Date(becario.ultima_supervision).toLocaleDateString()}</p>
                    </div>
                  </div>
                </div>

                <div className="flex-row gap-10">
                  <button 
                    className="btn-primary flex-1"
                    onClick={() => {
                      setSelectedBecario(becario);
                      setShowFeedback(true);
                    }}
                  >
                    <FiMessageSquare /> Dar Feedback
                  </button>
                  <button className="btn-text">
                    <FiFileText /> Ver Observaciones
                  </button>
                </div>
              </div>
            );
          })}
        </div>

        {/* Observaciones de Becarios */}
        <div className="mt-30">
          <h3>Observaciones Recientes</h3>
          
          <div className="observaciones-list mt-10">
            {observaciones.map((obs) => (
              <div key={obs.id} className="accordion">
                <div className="accordion-header">
                  <div className="flex-row align-center gap-10">
                    <FiCalendar />
                    <span>{new Date(obs.fecha).toLocaleDateString()}</span>
                  </div>
                  <div className="flex-row align-center gap-10">
                    <FiUser />
                    <span>{obs.becario_nombre} ‚Üí {obs.paciente_nombre}</span>
                  </div>
                  <div className={`badge ${
                    obs.estado === 'revisada' ? 'badge-success' : 'badge-warning'
                  }`}>
                    {obs.estado === 'revisada' ? 'Revisada' : 'Pendiente'}
                  </div>
                </div>
                
                <div className="accordion-content">
                  <div className="grid-2 gap-20">
                    <div>
                      <h4>Observaciones</h4>
                      <p>{obs.contenido}</p>
                      
                      <h4 className="mt-10">√Åreas de mejora</h4>
                      <p>{obs.areas_mejora}</p>
                    </div>
                    
                    <div>
                      <h4>Feedback del supervisor</h4>
                      {obs.feedback ? (
                        <p>{obs.feedback}</p>
                      ) : (
                        <p className="text-danger">Sin feedback a√∫n</p>
                      )}
                      
                      <button 
                        className="btn-text mt-10"
                        onClick={() => {
                          setSelectedBecario(becarios.find(b => b.nombre === obs.becario_nombre));
                          setShowFeedback(true);
                        }}
                      >
                        <FiMessageSquare /> {obs.feedback ? 'Editar Feedback' : 'Agregar Feedback'}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Estad√≠sticas */}
        <div className="grid-3 mt-30 gap-20">
          <div className="card">
            <h4>Resumen de Supervisi√≥n</h4>
            <div className="mt-10">
              <p>Total becarios: {becarios.length}</p>
              <p>Observaciones pendientes: {observaciones.filter(o => o.estado === 'pendiente').length}</p>
              <p>Sesiones supervisadas: {becarios.reduce((sum, b) => sum + b.sesiones_supervisadas, 0)}</p>
            </div>
          </div>
          
          <div className="card">
            <h4>Pr√≥ximas Supervisiones</h4>
            <div className="mt-10">
              <p>Juan P√©rez: 2024-01-15</p>
              <p>Sof√≠a Ram√≠rez: 2024-01-12</p>
              <p className="text-small mt-10">Agenda programada</p>
            </div>
          </div>
          
          <div className="card">
            <h4>Acciones</h4>
            <div className="mt-10 flex-col gap-10">
              <button className="btn-primary w-100">
                Programar Supervisi√≥n
              </button>
              <button className="btn-secondary w-100">
                Generar Informe
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Modal para Feedback */}
      {showFeedback && selectedBecario && (
        <div className="modal-overlay">
          <div className="modal-container">
            <div className="modal-header">
              <h3>Feedback para {selectedBecario.nombre}</h3>
              <button className="modal-close" onClick={() => setShowFeedback(false)}>√ó</button>
            </div>
            
            <div className="modal-content">
              <div className="form-group">
                <label>Escribe tu feedback</label>
                <textarea
                  value={feedback}
                  onChange={(e) => setFeedback(e.target.value)}
                  className="textarea-field"
                  rows="6"
                  placeholder="Comparte tus observaciones, sugerencias y √°reas de mejora..."
                />
              </div>
              
              <div className="mt-10">
                <p className="text-small">
                  <FiAlertCircle /> El feedback debe ser constructivo y espec√≠fico.
                </p>
              </div>
            </div>
            
            <div className="modal-footer">
              <button 
                className="btn-secondary"
                onClick={() => setShowFeedback(false)}
              >
                Cancelar
              </button>
              <button 
                className="btn-primary"
                onClick={() => enviarFeedback(selectedBecario.id)}
              >
                <FiCheckCircle /> Enviar Feedback
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PsicologoSupervision;

/frontend\src\services\api.js:
--------------------------------------------------------------------------------
// frontend/src/services/api.js
const API_BASE_URL = 'http://localhost:3000/api';

class ApiService {
  static getToken() {
    return localStorage.getItem('token');
  }

  static getHeaders() {
    const token = this.getToken();
    const headers = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    return headers;
  }

  static async request(url, options = {}) {
    const { method = 'GET', data } = options;
    
    const config = {
      method,
      headers: this.getHeaders(),
      credentials: 'include' // Importante para cookies si las usas
    };
    
    if (data) {
      config.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(`${API_BASE_URL}${url}`, config);
      return this.handleResponse(response);
    } catch (error) {
      console.error('Fetch error:', error);
      throw error;
    }
  }

  static async get(url) {
    return this.request(url);
  }

  static async post(url, data) {
    return this.request(url, { method: 'POST', data });
  }

  static async put(url, data) {
    return this.request(url, { method: 'PUT', data });
  }

  static async delete(url) {
    return this.request(url, { method: 'DELETE' });
  }

  static async handleResponse(response) {
      // Primero verificar si hay contenido
      if (response.status === 204 || response.status === 205) {
          return {};
      }
      
      const contentType = response.headers.get('content-type');
      
      // IMPORTANTE: Si es CSV, devolver como texto sin parsear como JSON
      if (contentType && contentType.includes('text/csv')) {
          const text = await response.text();
          
          if (!response.ok) {
              throw new Error(text || `HTTP error! status: ${response.status}`);
          }
          
          // Para CSV, devolvemos el texto directamente
          return text;
      }
      
      // Si no es CSV, verificar si es JSON
      if (!contentType || !contentType.includes('application/json')) {
          const text = await response.text();
          
          if (!response.ok) {
              throw new Error(text || `HTTP error! status: ${response.status}`);
          }
          
          // Intentar parsear como JSON si es posible
          try {
              return text ? JSON.parse(text) : {};
          } catch {
              return text;
          }
      }
      
      // Si es JSON, parsearlo normalmente
      const data = await response.json();
      
      if (!response.ok) {
          const errorMessage = data.message || data.error || `HTTP error! status: ${response.status}`;
          const error = new Error(errorMessage);
          error.status = response.status;
          error.data = data;
          throw error;
      }
      
      return data;
  }

  // M√©todos espec√≠ficos para el dashboard
  static async getDashboardCoordinador() {
    return this.get('/dashboard/coordinador');
  }

  static async getMetricasGlobales(periodo = 'mes') {
    return this.get(`/dashboard/metricas-globales?periodo=${periodo}`);
  }

  static async getEstadisticas() {
    return this.get('/estadisticas/generales');
  }

  // M√©todo para obtener informaci√≥n del usuario actual
  static async getCurrentUser() {
    return this.get('/auth/me');
  }
}

export default ApiService;

/frontend\src\services\dashboardService.js:
--------------------------------------------------------------------------------
// frontend/src/services/dashboardService.js
import ApiService from './api';

class DashboardService {
  static async obtenerDashboardCoordinador() {
    try {
      console.log('Obteniendo dashboard coordinador...');
      const response = await ApiService.getDashboardCoordinador();
      console.log('Respuesta recibida:', response);
      return response.data;
    } catch (error) {
      console.error('Error obteniendo dashboard coordinador:', error);
      throw error;
    }
  }

  static async obtenerMetricasGlobales(periodo = 'mes') {
    try {
      const response = await ApiService.getMetricasGlobales(periodo);
      return response.data;
    } catch (error) {
      console.error('Error obteniendo m√©tricas globales:', error);
      throw error;
    }
  }

  static async obtenerEstadisticas() {
    try {
      const response = await ApiService.getEstadisticas();
      return response.data;
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas:', error);
      throw error;
    }
  }

  // M√©todo para transformar los datos del backend al formato que usa el frontend
  static transformarDatosCoordinador(datosBackend) {
    if (!datosBackend) {
      throw new Error('No se recibieron datos del backend');
    }
    
    const { estadisticas = {}, top_psicologos = [], alertas = [], evolucion_mensual = [], citas_por_dia = [] } = datosBackend;
    
    // Transformar estad√≠sticas principales
    const estadisticasTransformadas = {
      becariosActivos: estadisticas.becarios_activos || 0,
      psicologosActivos: estadisticas.psicologos_activos || 0,
      pacientesActivos: estadisticas.pacientes_activos || 0,
      citasHoy: estadisticas.citas_hoy || 0,
      citasCompletadasHoy: estadisticas.citas_completadas_hoy || 0,
      altasMesActual: estadisticas.altas_mes || 0
    };

    // Transformar actividad reciente
    const actividadReciente = this.generarActividadReciente(datosBackend);

    // Transformar distribuci√≥n de citas por psic√≥logo
    const distribucionPsicologos = top_psicologos.map(psicologo => ({
      nombre: psicologo.nombre_completo || psicologo.nombre || 'Psic√≥logo',
      citas: psicologo.total_citas || psicologo.citas_completadas || 0,
      color: this.asignarColor(psicologo.id || 0)
    }));

    // Transformar alertas
    const alertasTransformadas = alertas.map((alerta, index) => ({
      id: index + 1,
      tipo: alerta.tipo || 'alerta',
      descripcion: alerta.descripcion || 'Alerta del sistema',
      cantidad: alerta.cantidad || 1
    }));

    return {
      estadisticas: estadisticasTransformadas,
      actividadReciente,
      distribucionPsicologos,
      alertas: alertasTransformadas,
      evolucionMensual: evolucion_mensual,
      citasPorDia: citas_por_dia
    };
  }

  static asignarColor(id) {
    const colores = [
      'var(--grnb)',  // Verde azulado
      'var(--blu)',   // Azul
      'var(--yy)',    // Amarillo
      'var(--grnd)',  // Verde oscuro
      'var(--grnl)',  // Verde claro
      'var(--rr)',    // Rojo
      'var(--rl)'     // Rojo claro
    ];
    return colores[id % colores.length];
  }

  static generarActividadReciente(datosBackend) {
    const actividades = [];
    const ahora = new Date().toISOString();
    
    if (datosBackend.estadisticas) {
      // Si hay nuevas altas hoy
      if (datosBackend.estadisticas.altas_hoy > 0) {
        actividades.push({
          id: 1,
          tipo: 'alta_paciente',
          descripcion: `${datosBackend.estadisticas.altas_hoy} paciente(s) dado(s) de alta hoy`,
          fecha: ahora,
          usuario: 'Sistema'
        });
      }

      // Si hay pacientes nuevos hoy
      if (datosBackend.estadisticas.pacientes_nuevos_hoy > 0) {
        actividades.push({
          id: 2,
          tipo: 'nuevo_paciente',
          descripcion: `${datosBackend.estadisticas.pacientes_nuevos_hoy} nuevo(s) paciente(s) registrado(s) hoy`,
          fecha: ahora,
          usuario: 'Sistema'
        });
      }

      // Si hay citas hoy
      if (datosBackend.estadisticas.citas_hoy > 0) {
        actividades.push({
          id: 3,
          tipo: 'citas_hoy',
          descripcion: `${datosBackend.estadisticas.citas_hoy} cita(s) programada(s) para hoy`,
          fecha: ahora,
          usuario: 'Sistema'
        });
      }

      // Si hay citas completadas hoy
      if (datosBackend.estadisticas.citas_completadas_hoy > 0) {
        actividades.push({
          id: 4,
          tipo: 'citas_completadas',
          descripcion: `${datosBackend.estadisticas.citas_completadas_hoy} cita(s) completada(s) hoy`,
          fecha: ahora,
          usuario: 'Sistema'
        });
      }
    }

    // Si no hay actividades espec√≠ficas, mostrar mensaje de sistema
    if (actividades.length === 0) {
      actividades.push({
        id: 1,
        tipo: 'sistema',
        descripcion: 'Sistema sincronizado con el backend',
        fecha: ahora,
        usuario: 'Sistema'
      });
    }

    return actividades;
  }
}

export default DashboardService;

/frontend\src\utils\confirmations.js:
--------------------------------------------------------------------------------
import { showConfirm } from '../components/Common/ConfirmModal'

// Funci√≥n para confirmaciones de peligro (rojo - para eliminar)
export const confirmDanger = (message) => {
  return showConfirm(message, 'danger')
}

// Funci√≥n para confirmaciones de advertencia (amarillo - est√°ndar)
export const confirmWarning = (message) => {
  return showConfirm(message, 'warning')
}

// Funci√≥n para confirmaciones de informaci√≥n (azul - neutral)
export const confirmInfo = (message) => {
  return showConfirm(message, 'info')
}

// Alias para la funci√≥n principal
export const confirm = showConfirm

// Exporta como objeto global
export default {
  danger: confirmDanger,
  warning: confirmWarning,
  info: confirmInfo,
  show: confirm
}

/frontend\src\utils\notifications.js:
--------------------------------------------------------------------------------
import { showNotification } from '../components/Common/NotificationModal'

// Funci√≥n para notificaciones de √©xito (verde)
export const notifySuccess = (message) => {
  showNotification(message, 'success')
}

// Funci√≥n para notificaciones de error (rojo)
export const notifyError = (message) => {
  showNotification(message, 'error')
}

// Funci√≥n para notificaciones de advertencia (amarillo)
export const notifyWarning = (message) => {
  showNotification(message, 'warning')
}

// Funci√≥n para notificaciones de informaci√≥n (azul)
export const notifyInfo = (message) => {
  showNotification(message, 'info')
}

// Alias para la funci√≥n principal
export const notify = showNotification

// Exporta como objeto global
export default {
  success: notifySuccess,
  error: notifyError,
  warning: notifyWarning,
  info: notifyInfo,
  show: notify
}